<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当Kotlin遇上Parcelable]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%BD%93Kotlin%E9%81%87%E4%B8%8AParcelable%2F</url>
    <content type="text"><![CDATA[由来 因为现在项目里面都是用 kotlin 在编写项目，在跨界面传递数据的时候经常需要传递对象数据，这就需要使用到 对象的序列化 ，就难免和 Parcelable 打交道。 序列化的方式 在Android中，对象的序列化方式是有两种的，一种是Java中的 Serializable ，一种是Android特有的 Parcelable 。既然Google新增加了一种 Parcelable 的方式，那必然有它的道理，我们先来看看两者有啥不可告人的秘密。 Serializable的序列化方式 这种序列化方式给我们的第一印象就是 简洁 。因为你只需要实现 Serializable 接口就可以了。这是一个标识接口，你不需要实现任何方法，Java就会对其进行序列化操作。但但但是，这种序列化的方式使用了 反射，而且在序列化过程中产生很多的临时对象，造成过多的内存消耗 。1234567891011package com.yanfangxiong.kotlinparcelabledemoimport java.io.Serializable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Serializable Parcelable的序列化方式 这种序列化方式是Android所特有的。而且使用起来 比较复杂 ，我们先来举个栗子。12345678910111213141516171819202122232425262728293031323334353637package com.yanfangxiong.kotlinparcelabledemoimport android.os.Parcelimport android.os.Parcelable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Parcelable &#123; companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(parcel: Parcel, flags: Int) &#123; parcel.writeString(name) parcel.writeString(sex) &#125; override fun describeContents(): Int &#123; return 0 &#125;&#125; 详解Parcelable writeToParcel() 通过这个方法你可以将对象的属性都写入到parcel中； describeContents() 这个方法一般情况下默认就好了。关于这个方法，API中是这么描述的，它表示这个Parcelable对象序列化内容的类别。举个栗子，如果你要序列化对象里面包含文件描述符，那么你需要将这个方法修改为返回 CONTENTS_FILE_DESCRIPTOR ； 编写一个类CREATOR继承自 Parcelable.Cretor ，这个接口包含两个方法，createFromParcel()从Parcel容器中值，newArray()这个方法是 供外部类反序列化本类数组使用的 。 从上面的代码我们就可以看出，如何序列化这个对象已经非常清楚的表现出来，根本不需要通过反射来知道来推断类型，所以能够更加高效的序列化对象。 区别与抉择 Serializable实现方式简单，但是比较消耗内存，一般建议使用在序列化对象保存到文件中的时候使用； Parcelable实现方式较为复杂，但是效率高，消耗内存小，在代码中建议使用这种方式。 问题所在 我们知道，在kotlin中伴生对象只能存在一个 ，一般一些在java中的静态常量我们可能会定义在伴生对象中，但是我们可以看上面的Person的Parcelable实现，系统默认给我们创建的CREATOR对象就直接指定为了伴生对象，这样虽然是没有问题的，但是你定义的一些常量就是属于CREATOR对象了，实际上这是不必要的，所以我们需要一种方式将伴生对象 “释放” 出来。 这里我们就直接上代码了。只需要使用 ＠JVMField 注解就可以解决这个问题。12345678910111213141516companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = object : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 但但但是，前面说了，使用Parcelable的序列化方式，类里面的方法会增加很多，所以我们打算来优化优化。 首先，kotlin像java 8一样，接口中的方法可以有默认的实现 ，于是我决定写一个KParcelable的接口，如下12345interface KParcelable : Parcelable &#123; override fun describeContents() = 0 override fun writeToParcel(dest: Parcel, flags: Int)&#125; 这样就减少了对象中的 describeContents 方法的实现。然后我们再来优化CREATOR的实现方式。对此我写了下面的函数123456inline fun &lt;reified T&gt; parcelableCreator(crossinline creator: (Parcel) -&gt; T) = object : Parcelable.Creator&lt;T&gt; &#123; override fun createFromParcel(source: Parcel): T = creator(source) override fun newArray(size: Int): Array&lt;T?&gt; = arrayOfNulls(size) &#125; 它接受一个名为 creator 的方法，然后返回一个 Parcelable.Creator 的实现类，这样我的Person类就可以简化为如下的方式。12345678910111213141516171819202122data class Person( var name: String?, var sex: String?) : KParcelable &#123; companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = parcelableCreator(::Person) &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(dest: Parcel, flags: Int) = with(dest) &#123; writeString(name) writeString(sex) &#125;&#125; 这样看着就舒服多了，哈哈哈。 毒鸡汤 生活不如意时是上帝给你放的长假～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装Recycler适配器]]></title>
    <url>%2F2018%2F01%2F23%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85Recycler%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 前段时间就说要用kotlin写RecyclerView的适配器，但一直在忙于项目的迭代，所以就没抽出时间来落地。其实也不算封装，只是简化了开发的过程而已。 直奔主题 这里我就不废话了，直接上代码吧。123456789101112131415161718192021222324252627282930313233343536373839404142import android.content.Contextimport android.support.annotation.LayoutResimport android.support.v7.widget.RecyclerViewimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroup/** * @author fxYan */abstract class CommonRecyclerAdapter&lt;T&gt;( val context: Context, @LayoutRes val resId: Int, val data: List&lt;T&gt;) : RecyclerView.Adapter&lt;CommonRecyclerAdapter.ViewHolder&gt;() &#123; private var onItemClickListener: OnItemClickListener&lt;T&gt;? = null fun setOnItemClickListener(listener: OnItemClickListener&lt;T&gt;) &#123; onItemClickListener = listener &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; onItemClickListener?.apply &#123; holder.itemView.setOnClickListener &#123; onItemClick(position, data[position]) &#125; &#125; bindData(holder.itemView, position, data[position]) &#125; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder = ViewHolder(LayoutInflater.from(context).inflate(resId, parent, false)) override fun getItemCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T) class ViewHolder(view: View) : RecyclerView.ViewHolder(view) interface OnItemClickListener&lt;in T&gt; &#123; fun onItemClick(position: Int, data: T) &#125;&#125; LayoutRes是什么 这个注解是 android support annotation 库中的一个注解，表示这里resId是一个布局文件的id，如果你在调用的时候不是传递的布局文件的id，编译的时候就可以检测出来，很方便，有时间会写一篇关于 android support annotation 的文章。 毒鸡汤 生活不止眼前的枸杞，还有远方的西洋参。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera的使用]]></title>
    <url>%2F2018%2F01%2F10%2FCamera%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介 Android的framework支持通过android.hardware.camera2API或者是过时的Camera来拍摄图片和视频。这篇文章讲解的是Camera的使用，后续会写一篇关于camera2使用的文章。当然，如果你等不及的话可以去看看google博客关于camera2的文章，camera2文章地址，请翻墙查看。 基础 android.hardware.camera2，这个包是控制设备相机的主要API，它可以被用来拍摄图片或者视频当你想构建一个相机app的时候； Camera，这个类也是用来控制设备相机的，但是在API21之后过时了； SurfaceView，这个类用来给用户呈现相机的预览； MediaRecorder，这个类通过相机来录制视频； Intent，如果你的目的仅仅只是简单的拍摄一张图片或者一段视频，你完全可以调用系统的相机让它来完成这些事情，而不需要直接操控系统相机。你可以使用MediaStore.ACTION_IMAGE_CAPTURE来调用系统相机来拍摄图片，或者通过MediaStore.ACTION_VIDEO_CAPTURE来调用系统相机来拍摄视频。 Manifest声明 当你使用Camera API进行开发的时候，你必须确保你的manifest文件中声明了相关的东西。 Camera Permission，当app需要使用设备相机的时候必须声明这个权限 1&lt;uses-permission android:name="android.permission.CAMERA" /&gt; Camera Features，同时得声明使用相机相关的特性，比如。关于camera features的列表，可以查看Features Reference。添加camera features到manifest文件中会导致Google Play防止你的应用安装在那些没有相机或者是不支持相机特性的设备上。如果你的app并不是一定需要camera，你可以在manifest中通过 android:required 来指定。 1&lt;uses-permission android:name="android.hardware.camera" android:required="false" /&gt; Storage Permission，如果应用程序需要将图片或者视频保存到external storage中，还需要声明这个权限； 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; Audio Recording Permission，视频录制的过程中还需要录制音频，所以得添加音频录制的权限，音频录制在之前的文章中已经讲过，不懂的可以去 Android录制系列之音频录制进行查阅； 1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; Location Permission，如果app需要给图片打上GPS定位信息的tag，你需要申请 ACCESS_FINE_LOCATION 权限，这里需要注意，Android5.0及以上版本需要声明使用设备的GPS； 123&lt;uses-permission android:name ="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;!-- targetSdkVersion &gt;= 21 的需要添加 --&gt;&lt;uses-feature android:name="android.hardware.location.gps" /&gt; 如何使用访问相机 检索并访问相机，如果你的app没有在manifest文件中声明是否只能安装在有相机的设备上，那么在使用之前，请检测设备是否有相机的硬件支持。1fun hasFeatureCamera(context: Context) = context.packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) Android2.3 之后你可以直接通过 Camera.getNumberOfCameras() 方法直接获取到设备上可用的相机数量。如果你非常清楚你app运行在有相机支持的设备上运行时，你可以直接通过 Camera.open() 方法去请求并获取一个Camera的实例，它会 访问设备上的第一个后置摄像头。12345678910fun getCamera(): Camera? &#123; var camera: Camera? = null try &#123; camera = Camera.open() &#125; catch (e: Exception) &#123; //如果不捕获异常，相机在被其他的app使用，或者设备上根本没有相机的时候，就会导致app crash Log.d("Amoryan", "open camera error!") &#125; return camera&#125; Android 2.3 之后你可以通过 Camera.open(int) 访问指定的相机。比如，你可以这么玩。123456789101112131415fun getCameraInfo() &#123; try &#123; for (i in 0 until Camera.getNumberOfCameras()) &#123; val cameraInfo: Camera.CameraInfo = Camera.CameraInfo() Camera.getCameraInfo(i, cameraInfo) if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; Log.d("Amoryan", "$i is back facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; else &#123; Log.d("Amoryan", "$i is front facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125;&#125; 设置预览 设置预览界面，你可以直接使用SurfaceView，或写一个SurfaceView的子类，然后实现SurfaceHolder.Callback的相关回调，这里我为了方便起见，直接在布局文件中使用SurfaceView了12345678&lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; 然后实现相对应的回调接口12345678910111213141516171819class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125; 拍摄图片 通过 takePicture 方法拍摄图片，这里只是简单的将拍摄的图片显示在ImageView上了。1234567891011captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125;private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125;&#125; 释放Camera Camera是设备上的共享资源，当app获取到Camera的实例后就可以使用它，但是在app不需要Camera或者当界面变得不可见的时候应该正确的释放。举个栗子，当界面变得不可见的时候，如果你没有正确的释放掉资源，就会导致接下来想要访问Camera的app获取失败，而没办法正常工作。12345override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null&#125; 完整代码 github项目地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.yanfangxiong.camerademoimport android.Manifestimport android.content.pm.PackageManagerimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.hardware.Cameraimport android.os.Bundleimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.view.SurfaceHolderimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; companion object &#123; val REQUEST_CAMERA_PERMISSION = 1 &#125; private var camera: Camera? = null private var bitmap: Bitmap? = null private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125; &#125; private fun checkCameraPermission() &#123; val cameraPermissionStatus = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) if (cameraPermissionStatus == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; &#125; private fun openCamera() &#123; camera = safeOpenCamera() setupCamera() &#125; private fun setupCamera() &#123; camera?.apply &#123; setDisplayOrientation(90) setPreviewDisplay(surfaceView.holder) safeStartPreview() &#125; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; if (camera == null) &#123; checkCameraPermission() &#125; else &#123; setupCamera() &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; camera?.safeStopPreview() setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null &#125; private fun releaseBitmap() &#123; bitmap?.recycle() bitmap = null &#125;&#125; 毒鸡汤 人生不如意的时候是上帝给的长假。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之视频录制]]></title>
    <url>%2F2018%2F01%2F09%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 视频录制使用的是 Camera 和前面讲过的 MediaRecorder。在视频录制的过程中你需要通过 Camera.unlock() 和 Camera.lock() 方法来允许MediaRecorder来访问硬件相机。和使用 Camera 拍摄图片不一样，拍摄视频有 严格的调用顺序。 如何使用 接下来我们就来看看该怎么玩这个玩意。 获取Camera 首先我们得获取到 Camera 。获取相机的方式这里就不在过多的说明了，如果你还是不知道可以去查看我的另外一个文章 Camera的使用。 设置预览界面 这里使用的是SurfaceView，你也可以去查看Camera的使用这篇文章。1234567891011121314151617181920212223242526override fun onCreate(savedInstanceState: Bundle?) &#123; //... surfaceView.holder.addCallback(this) //...&#125;override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera()&#125;override fun surfaceDestroyed(holder: SurfaceHolder?) &#123;&#125;override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission()&#125; 开始录制 相机的准备工作做好之后就可以开始录制了。 通过 Camera.unlock() 允许MediaRecorder访问Camera； 通过 MediaRecorder.setCamera() 将MediaRecorder和Camera关联； 设置音频源，通过 MediaRecorder.setAudioSource() 设置音频源为 MediaRecorder.AudioSource.CAMCORDER； 设置视频源，通过 MediaRecorder.setVideoSource() 设置视频源为 MediaRecorder.VideoSource.CAMERA； 设置输出格式和编码方式，不过在 Android2.2 之后你就可以通过 MediaRecorder.setProfile() 方法来设置一个录制视频的配置； 通过 MediaRecorder.setOutputFile() 设置录制视频后保存的文件路径； 通过 MediaRecorder.setPreviewDisplay() 设置预览界面是SurfaceView； 经过以上的配置之后MediaRecorder就已经准备完成，之后你就可以调用 MediaRecorder.prepare() 表示你已经准备完成了； 通过 MediaRecorder.start() 开始录制； 停止录制 当你录制完成之后，也需要正确的释放资源。 通过 MediaRecorder.stop() 停止当前的录制； 通过 MediaRecorder.reset() 重置当前的MediaRecorder配置，以便之后其他app的使用； 通过 MediaRecorder.release() 将MediaRecorder释放； 通过 Camera.lock() 将相机资源锁住，方便其他的app进行使用； 通过 Camera.stopPreview() 停止相机的预览； 通过 Camera.release() 释放相机的资源，方便其他的app进行使用。 小技巧 如果你使用Camera来录制视频，你可以通过 setRecordingHint() 在开启预览前设置为true，这个方法能够减少开始录制的时间。 项目地址 github项目地址 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package com.yanfangxiong.mediarecorderdemoimport android.Manifestimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.hardware.Cameraimport android.media.CamcorderProfileimport android.media.MediaRecorderimport android.os.Bundleimport android.os.Environmentimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.util.Logimport android.view.SurfaceHolderimport android.view.Viewimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_video_recorder.*import java.io.File/** * @author fxYan */class VideoRecorderActivity : AppCompatActivity(), View.OnClickListener, SurfaceHolder.Callback &#123; companion object &#123; const val REQUEST_CAMERA_PERMISSION = 1 const val REQUEST_RECORD_AUDIO_PERMISSION = 2 fun jumpToActivity(context: Context) &#123; val intent = Intent(context, VideoRecorderActivity::class.java) val queryIntentActivities = context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY) if (queryIntentActivities != null &amp;&amp; queryIntentActivities.isNotEmpty()) &#123; context.startActivity(intent) &#125; &#125; &#125; private var camera: Camera? = null private var mediaRecorder: MediaRecorder? = null private var isRecording = false override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_video_recorder) surfaceView.holder.addCallback(this) controlIv.setOnClickListener(this) &#125; override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.controlIv -&gt; &#123; if (camera == null) &#123; return &#125; if (isRecording) &#123; //如果在录制中 try &#123; mediaRecorder?.stop() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop media recorder error!") &#125; releaseMediaRecorder() &#125; else &#123; //开启录制 checkRecordAudioPermission() &#125; &#125; &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission() &#125; private fun checkCameraPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -&gt; &#123; openCamera() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; &#125; private fun checkRecordAudioPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -&gt; &#123; startRecord() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION) &#125; &#125; &#125; private fun openCamera() &#123; try &#123; camera = Camera.open() setupCamera() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125; &#125; private fun setupCamera() &#123; try &#123; camera?.apply &#123; parameters.focusMode = Camera.Parameters.FOCUS_MODE_AUTO setPreviewDisplay(surfaceView.holder) setDisplayOrientation(90) startPreview() autoFocus(null) &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "set up camera error!") releaseCamera() &#125; &#125; private fun releaseCamera() &#123; try &#123; camera?.stopPreview() camera?.release() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release camera error!") &#125; camera = null &#125; private fun startRecord() &#123; try &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; reset() camera?.unlock() setCamera(camera) setAudioSource(MediaRecorder.AudioSource.CAMCORDER) setVideoSource(MediaRecorder.VideoSource.CAMERA) setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_1080P)) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "videoRecorder.mp4") setOutputFile(file.absolutePath) setPreviewDisplay(surfaceView.holder.surface) prepare() start() isRecording = true Toast.makeText(this@VideoRecorderActivity, "开启录制...", Toast.LENGTH_SHORT).show() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "mediaRecorder error!") releaseMediaRecorder() &#125; &#125; private fun releaseMediaRecorder() &#123; try &#123; mediaRecorder?.apply &#123; reset() release() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release media recorder error!") &#125; camera?.lock() mediaRecorder = null isRecording = false &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecord() &#125; &#125; override fun onPause() &#123; super.onPause() releaseMediaRecorder() releaseCamera() &#125;&#125; 毒鸡汤 走过一些弯路，也好过原地踏步～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之音频录制]]></title>
    <url>%2F2018%2F01%2F06%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介 Android的多媒体框架包含并支持录制和解码多种多样的音视频格式。如果设备支持，你可以使用MediaRecorder来进行这些操作。( Android模拟器无法录制音频 ) MediaRecorder的使用权限 如果你想进行音频录制，你必须添加RECORDER_AUDIO的权限，这是一个 危险权限 ，如果你不知道如何请求权限，你可以查看之前的一篇文章 Android运行时权限的处理。1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; 配置MediaRecorder 配置一个MediaRecorder你只需要简单的几步就可以了。 首先，我们得创建一个 MediaRecorder 的实例对象； 1val mediaRecorder = MediaRecorder() 通过 setAudioSource() 方法设置音频源，音频源的取值你可以直接查看 MediaRecorder.AudioSource，一般情况下我们会选择 MIC 也就是麦克风作为音频源； 1mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC) 通过 setOutputFormat() 方法设置输出格式，输出格式的取值你可以直接查看 MediaRecorder.OutputFormat； 1mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) 通过 setAudioEncoder() 方法设置音频解码方式，解码方式的取值你可以直接查看 MediaRecorder.AudioEncoder 1mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC) 通过 setOutputFile() 方法设置保存文件的路径， 12val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "audioRecorder.3gp")mediaRecorder.setOutputFile(file.absolutePath) 完成初始化配置后，你就可以调用 prepare()方法 ；然后调用 start() 你就可以开始录制了。 12mediaRecorder.prepare()mediaRecorder.start() 值得注意的 大部分(包括DEFAULT)的音频源 都会对音频信号做处理 ，如果你想录制原始的音频，你可以选择MediaRecorder.AudioSource.UNPROCESSED(当然你也可以选择AudioRecorder这个更接近底层的类，后面会找时间写一篇关于AudioRecorder录制的文章)。 有些设备是不支持录制未处理的音频，你可以通过下面的这种方式来获取设备是否支持录制原始音频。1234567val audioManager: AudioManager? = getSystemService(Context.AUDIO_SERVICE) as? AudioManagervar isSupportedRawAudioInput = "false"audioManager?.apply &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; isSupportedRawAudioInput = getProperty("android.media.property.SUPPORT_AUDIO_SOURCE_UNPROCESSED") &#125;&#125; 嗯~what，我相信你也发现了，这个方法是 API 17 才出现的。目前公司项目的最低支持是16，所以得找一种方式在 API 16 上也能够获取到这个属性。结合之前的一些经验，我最初的想法是先看看API16的AudioManager的源码，希望这个方法是本身存在的，只是被隐藏了，这样我就可以直接通过反射的方式去调用，但是事实不是如此，在API16中，AudioManager确实是没有getProperty()方法 ；于是，本着学习的态度，我翻看了更高版本的AudioManager的源码，发现它的调用链是这个样子的。123if (PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED.equals(key)) &#123; return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportAudioSourceUnprocessed));&#125; 仿佛抓到一颗救命稻草，于是我想我直接在代码里面获取这个属性不就好了，这里给你萌看一张图吧，上面代码是这个样子的，找不到com.android.interal.R。 然后，我去google上搜索了关于如何引用这个资源文件，首先，通过反射是肯定可以获取到的，但是google会有一个警告告诉你 通过反射的方式访问内部APIs可能会在某些设备上不支持 ，所以还是用下面这个安全的方式吧。1resources.getBoolean(Resources.getSystem().getIdentifier("config_supportAudioSourceUnprocessed", "bool", "android")) 嗯哼，高兴的太早了，于是乎我就开启了API16的模拟器运行了起来，当走到这一行代码的时候，就出现了下面的结果，好吧，这个属性的判断似乎只能是API17才能用，所以还是用官方推荐的那种方式吧。 如果不支持的情况下，你可以尝试使用 MediaRecorder.AudioSource.VOICE_RECOGNITION 。它不使用AGC(Auto Gain Control，自动增益控制，当信号源较强的时候，使其增益自动降低；当信号源较弱的时候，使其增益自动增高)，并且不会做降噪处理。当然，即使设备不支持UNPROCESSED，你仍旧可以设置为这个，只是这样你就不知道音频信号有没有被处理了。 MediaRecorder的状态 这里直接使用官方的状态图了，如下 事件监听 MediaRecorder提供了两个监听事件的接口，一个是MediaRecorder.OnInfoListener，另一个是MediaRecorder.OnErrorListener。 OnInfoListener 可以用来监听MediaRecorder的一些状态，比如最大录制事件到了等等。12345678910111213141516mediaRecorder.setOnInfoListener&#123; _,what,_-&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED-&gt;&#123; //这个枚举值对应mediaRecorder.setMaxDuration()，当设置的最大录制时间到了后，会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING-&gt;&#123; //这个枚举值对应setMaxFileSize()，当录制文件大小快接近最大值的时候会回调这个，这个是API26新增 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED-&gt;&#123; //当录制文件大小达到最大文件大小的时候会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED-&gt;&#123; //这个方法对应的是setNextOutputFile()，当录制视频超过指定大小后保存到next文件中的时候就会回调这个值，这个是API26新增 &#125; &#125;&#125; OnErrorListener 监听Error信息，12345678mediaRecorder.setOnErrorListener&#123;_, what, _ -&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN-&gt;&#123; &#125; MediaRecorder.MEDIA_ERROR_SERVER_DIED-&gt;&#123; &#125; &#125;&#125; 举个栗子 布局文件就不细说了，只有一个录制按钮和一个停止按钮。我们来看看Activity中核心的的代码。 请求权限123456789101112131415161718192021222324252627282930override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.startRecorderTv -&gt; checkRecordAudioPermission() R.id.stopRecorderTv -&gt; stopRecorder() &#125;&#125;private fun checkRecordAudioPermission() &#123; val hasRecordAudioPermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) when &#123; hasRecordAudioPermission == PackageManager.PERMISSION_GRANTED -&gt; startRecorder() ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.RECORD_AUDIO) -&gt; AlertDialog.Builder(this) .setCancelable(false) .setMessage("请求音频录制权限，否则无法录制音频") .setNegativeButton("取消") &#123; _, _ -&gt; &#125; .setPositiveButton("确定") &#123; _, _ -&gt; requestRecordAudioPermission() &#125; .show() else -&gt; requestRecordAudioPermission() &#125;&#125;private fun requestRecordAudioPermission() &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION)&#125;override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecorder() &#125;&#125; 开始录制123456789101112131415161718private fun startRecorder() &#123; if (!isRecording) &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; setAudioSource(MediaRecorder.AudioSource.MIC) setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) setAudioEncoder(MediaRecorder.AudioEncoder.AAC) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), AUDIO_RECORDER_FILE_NAME) setOutputFile(file.absolutePath) try &#123; prepare() &#125; catch (e: Exception) &#123; &#125; start() isRecording = true &#125; &#125;&#125; 停止录制12345678910private fun stopRecorder() &#123; if (isRecording) &#123; mediaRecorder?.apply&#123; stop() release() &#125; isRecording = false mediaRecorder = null &#125;&#125; 项目地址github地址 官方文档 官网的Guide也是给出了MediaRecorder的详细使用，以及在 API 26 中新增的 MediaMuxer to record multiple channels 。 毒鸡汤 将来的你一定会感谢现在拼命的自己～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择列表请对CheckBox说No]]></title>
    <url>%2F2018%2F01%2F05%2F%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E8%AF%B7%E5%AF%B9CheckBox%E8%AF%B4No%2F</url>
    <content type="text"><![CDATA[由来 我记得刚学习Android的时候，有个需求是这个样子的，做一个单选或者多选的选择列表。然后那个时候懂得不是很多，就用CheckBox去做。做来做去，发现很多的坑，比如控件会被重用，导致选中的状态也被重用了。后来随着自己接触的东西变多，想到用另外一种方式来实现选择列表，但是这并不是我写这篇文章的原因。主要原因是最近在看同事写的代码(我们是两个人在开发)的时候，发现选择列表还是用的CheckBox，我觉得有必要分享下自己的实现方式，当然如果你们有什么好的建议记得及时告诉我。 实现方式 接下来我就说一下我是如何实现选择列表的(欢迎大家来吐槽)。先来一张效果图，比较简单。github项目地址 level-list 官方文档的介绍请戳这里。它可以通过一些值来管理一系列的图片，然后通过level属性修改这些值后就会显示对应的图片。 举个栗子 因为是选择列表，那必然会有两张图片，一张是未选中的，我们记为ic_select_off，一张是选中的，我们记为ic_select_on。然后我们可以在drawable文件夹下新建一个level_list_common_select.xml的资源文件。具体代码如下123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_select_off" android:maxLevel="0"/&gt; &lt;item android:drawable="@mipmap/ic_select_on" android:maxLevel="1"/&gt;&lt;/level-list&gt; 布局文件 接下来，我们说说布局文件，我们不会用到CheckBox，这里我们用ImageView来顶替CheckBox，大致如下所示。123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff" android:orientation="horizontal" android:paddingLeft="12dp" android:paddingRight="12dp"&gt; &lt;ImageView android:id="@+id/selectStatusIv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:src="@drawable/level_list_common_select"/&gt; &lt;TextView android:id="@+id/selectTitleTv" android:layout_width="match_parent" android:layout_height="match_parent" android:ellipsize="end" android:gravity="center_vertical" android:lines="1" android:paddingLeft="12dp" android:singleLine="true" android:textColor="#333333" android:textSize="16sp"/&gt;&lt;/LinearLayout&gt; 这里并没有太多花里胡哨的东西，只是用一个ImageView替换掉了CheckBox。 核心逻辑 你需要找一个能够唯一标记这个选项的字段，比如id，这个字段一般都会有。然后我们的适配器里面会存放一个selectId，在渲染View的方法中校验当前项的id是否和选中的id是一致的，如果一致，则将level设置为1，否则设置为0就可以了。12345678910111213141516171819202122232425262728package com.yanfangxiong.levellistimplementselectlistimport android.content.Contextimport android.view.Viewimport com.guoshujinfu.mobile.gscloud.migration.adapter.CommonListAdapterimport kotlinx.android.synthetic.main.listitem_select.view.*/** * @author fxYan */class SelectListAdapter( context: Context, resId: Int, data: List&lt;SelectBean&gt;) : CommonListAdapter&lt;SelectBean&gt;(context, resId, data) &#123; private var selectId: Long? = null fun setSelected(selectId: Long) &#123; this.selectId = selectId &#125; override fun bindData(view: View, position: Int, data: SelectBean) &#123; view.selectStatusIv.drawable.level = if (data.id == selectId) 1 else 0 view.selectTitleTv.text = data.title &#125;&#125; 这里用的kotlin编写的，CommonListAdapter可以去看之前写的用kotlin封装的适配器。这样这个单选的逻辑就写完了。嗯，就是这么简单，不用关心CheckBox重用导致的状态复用问题。 总结 如果我不去思考该如何简化，那我永远都只是死板的用CheckBox来完成选择列表。所以，要学会思考，只根据产品给的需求完成相应的任务那是一个初级程序猿做的事情。日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装List适配器]]></title>
    <url>%2F2017%2F12%2F25%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85List%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 最近在迁移C端项目到B端，然后有很多功能点对于B端是不一样的，所以打算在迁移的过程中，用kotlin去重新写一遍。最近这几天忙着写项目，所以没有抽出什么时间来写博客，但是写博客这么好的习惯得养成，决定以后每周至少写一篇博客。 没有使用kotlin的适配器 因为ListView的适配器用kotlin封装起来比较简单，所以暂时先写关于ListView的，后续想好怎么去写RecyclerView的适配器的时候再补上。在没有使用kotlin之前，我们项目中的适配器是这样封装的，分成了两个文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public abstract class CommonListAdapter&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected int mResId; protected List&lt;T&gt; mData; public CommonListAdapter(@NonNull Context context, @LayoutRes int resId, @NonNull List&lt;T&gt; data) &#123; this.mContext = context; this.mResId = resId; this.mData = data; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = CommonViewHolder.getHolder(mContext, mResId, position, convertView, parent); bindData(holder, mData.get(position)); return holder.getConvertView(); &#125; /** * 数据绑定 * * @param holder ViewHolder对象 * @param t 要绑定的数据对象 */ public abstract void bindData(@NonNull CommonViewHolder holder, @NonNull T t);&#125;public class CommonViewHolder &#123; private SparseArray&lt;View&gt; mViews; private LayoutInflater mLayoutInflater; private View convertView; private int position; private CommonViewHolder(Context context, int resId, int position, ViewGroup parent) &#123; mViews = new SparseArray&lt;&gt;(); mLayoutInflater = LayoutInflater.from(context); convertView = mLayoutInflater.inflate(resId, parent, false); convertView.setTag(this); this.position = position; &#125; public static CommonViewHolder getHolder(Context context, int resId, int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = null; if (convertView == null) &#123; holder = new CommonViewHolder(context, resId, position, parent); &#125; else &#123; holder = (CommonViewHolder) convertView.getTag(); holder.position = position; &#125; return holder; &#125; public View getConvertView() &#123; return convertView; &#125; public int getPosition() &#123; return position; &#125; public &lt;T extends View&gt; T get(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = convertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125;&#125; 每次只需要重写bindData方法就可以了，但是如果listitem布局中的控件多起来，还是得调用get方法很多次。最近学习了kotlin之后，在迁移中，我发现，诶，居然可以这么玩。请看下面的栗子。 使用kotlin后的适配器 可能是单身限制了我的想象力。它居然可以这么简洁，简洁，简洁。1234567891011121314151617181920abstract class CommonListAdapter&lt;T&gt;( var context: Context, @LayoutRes var resId: Int, var data: List&lt;T&gt;) : BaseAdapter() &#123; override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123; val view = convertView ?: LayoutInflater.from(context).inflate(resId, parent, false) bindData(view, position, getItem(position)) return view &#125; override fun getItem(position: Int): T = data[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T)&#125; 是的，你没有看错，就是这个样子的。然后在你的build.gradle文件中增加上这个插件。1apply plugin: 'kotlin-android-extensions' 然后你就可以任性的玩耍了。比如有这么一个布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="60dp" android:background="#ffffff" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/repayDateTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center_vertical" android:lineSpacingExtra="6dp" android:paddingLeft="12dp" android:paddingRight="10dp" android:textColor="#646464" android:textSize="12sp" tools:text="2017-10-10\n12:00"/&gt; &lt;TextView android:id="@+id/repayAmountTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:textColor="#333333" android:textSize="14sp" tools:text="1000.00"/&gt; &lt;TextView android:id="@+id/statusTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:paddingLeft="10dp" android:paddingRight="12dp" android:textColor="#333333" android:textSize="14sp" tools:text="处理中"/&gt;&lt;/LinearLayout&gt; 适配器就只有这么几行代码就可以解决了。12345678910111213class RepayRecordAdapter( context: Context, resId: Int, data: List&lt;RepayRecordListRespBean&gt;) : CommonListAdapter&lt;RepayRecordListRespBean&gt;(context, resId, data) &#123; override fun bindData(view: View, position: Int, data: RepayRecordListRespBean) &#123; view.repayDateTv.text = data.getSeparateTime() view.repayAmountTv.text = data.moneyOrder view.statusTv.text = data.getStatusText() &#125;&#125; 说真的，我已经逐渐爱上这门语言了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin之集合的惰性操作]]></title>
    <url>%2F2017%2F12%2F16%2Fkotlin%E4%B9%8B%E9%9B%86%E5%90%88%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 最近在学习kotlin的时候，发现了一个 骚操作 ，它叫集合的惰性操作。什么，你问我为什么称它 骚 ？我也不知道，反正脑海中就浮现了这么个词语！可能是贫穷限制了我的想象力！ 举个栗子 比如有这么一个场景，你是一家猎头公司的人员(别问我为什么是猎头，因为我看完猎场了)。然后你需要从一批人员中筛选符合条件的人选。123456data class Person(var name: String, var age: Int = 0, var workYear: Int = 0, var mail: String?)val persons = listOf(Person("Tom", 20, 2, "Tom@mail.com"), Person("Mike", 22, 3, "Mike@mail.com"), Person("Jerry", 21, 3, "Jerry@mail.com"), Person("Atom", 22, 2, "Atom@mail.com")) 你需要筛选出工作年限不小于３年的人的联系方式，然后联系他们准备进行面试。1234567println(persons.filter &#123; println("filter operate!") it.workYear &gt;= 3&#125;.map &#123; println("map operate!") it.mail&#125;) 上面的代码会输出如下的结果，这样你就成功的筛选出了Mike和Jerry。 如果你不了解 filter 和 map 两个扩展函数，可以查看源码中的这两个扩展函数是怎么写的 _Collections.kt。从输出结果上我们也可以看出它的流程是这样的，先对persons集合的每一个元素调用filter，然后会产生一个新的集合，然后对新的集合调用map，这样就得到了所有符合条件人员的联系方式。 Sequence序列 上面已经说明了这段代码的执行流程，倘若你要从你们成百上千万的人才库中筛选这些人员，执行效率是不是就非常低下了，而且如果变换操作过多的时候，你会创建很多个临时的集合。这时候，惰性操作就出来的，解释排后，代码先行！12345678910println("result is:" + persons.asSequence() .filter &#123; println("filter operate!") it.workYear &gt;= 3 &#125; .map &#123; println("map operate!") it.mail &#125; .toList()) 上面这段代码输出结果是这样的。 我们很容易就能够看出，它会对persons中的每一个元素先调用filter，如果满足条件再调用map；它是一个元素操作完之后再对另外一个元素做操作。我们再来看看一个神奇的现象，先把toList()删除掉，它会输出这个结果。 很神奇吧，它没有对persons中的元素做任何操作，只是单纯的返回了一个TransformingSequence的对象。 序列的操作 我们可以将序列的操作分为两类，intermediate operation 和 terminal operation 。看下面这张图你就明白了。 intermediate operation是惰性的。从上面的代码我们可以看出，只有当terminal operation执行的时候，intermediate operation才会执行。 总结 序列是对集合的每一个元素做所有的操作，而没有使用序列的时候是对一个集合做完某个操作后再对新的集合做后续操作； 序列只有在terminal operation调用的时候才会执行所有的操作。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限的处理]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 Android运行时权限机制 是在 API 23(Android M) 中提出来的，今年已经发布了API 26、27(Android O)，已经过去几个版本了，但是为什么我要写这个东西。首先，以前在开发的过程中，为了图方便，只是 简单的将build.gradle 中的 targetSdkVersion 设置为 22，所以基本上没有太多的和运行时权限打交道，但是随着这个人啊越来越老( 帅 )，觉得不应该躲避新的东西，而应该正视它，不然自己的技术永远都不会得到提高。所以最近打算将targetSdkVersion逐渐升上去，玩点新东西。 这是什么 在 API 23 以前，如果用户在安装应用后，默认是同意了应用所需要的权限(但是Android厂商众多，也有很多手机会弹窗提示用户是否授予权限)。而运行时权限的加入，简化了应用的安装过程，因为用户在安装的过程中不需要授予权限，而在应用的运行过程中，可以选择是否授予应用相关的权限。举个简单的例子，用户可以为相机提供相机访问权限，但是不提供位置的访问权限。 权限分类 系统权限分为两类：Normal Permission 和 Dangerous Permission” ，前者 不会直接给用户的隐私带来风险 ，所以如果你的app在Manifest文件中列出了应用需要这些权限，系统会自动赋予该权限。后者 会赋予app访问用户隐私数据的权限，是有可能对用户隐私造成风险的 。所以如果你的app在Manifest文件中列出了这些权限，则这些 权限的授予是由用户决定的 。 如何使用 接下来，我们就要开始来玩运行时权限了。 检测权限 如果你的app需要 Dangerous Permission ，则每次执行需要这一权限操作的时候都应该检测自己是否具有该权限，因为用户始终可以自由的调用此权限。检测的方法有两种，但是源码是一样的，只是穿了个不同的外套而已。12345678int cameraPermissionState = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);cameraPermissionState = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA);//判断权限是否授予if (cameraPermissionState == PermissionChecker.PERMISSION_GRANTED) &#123; //...已经具有该权限，你可以做一些羞羞的事情了&#125; else &#123; //...没有权限，这个时候你需要获取该权限了&#125; 请求权限 Android提供了多种权限请求方式，调用这些方法将会显示一个无法自定义的Android对话框。你可以调用 requestPermission() 方法来请求你所需要的权限。1ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 处理权限请求响应 当用户响应权限弹窗的时候，系统将回调 onRequestPermissionsResult() 方法，告知用户的响应情况。所以我们必须重写这个方法，如下。1234567if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...用户允许相机访问权限，你可以做一些羞羞的事情了 &#125; else &#123; //...用户拒绝了相机访问权限 &#125;&#125; 注意，系统显示的权限弹窗是对于 权限组 而言的，它不会列出app需要的具体权限。比如，app想要READ_CONTACTS权限，系统会告诉用户app想要访问设备的联系人。同时，用户只需要为每个权限组授予一次权限，如果应用请求该权限组中的任何其他权限，系统将自动授予应用这些权限 。具体过程是你在 requestPermissions() 方法之后，系统会自动回调 onRequestPermissionsResult() 方法，并传入 PERMISSION_GRANTED 。 权限组 你可能会询问权限组又是什么东西，是的，我也问过自己。所有的Dangerous Permission都属于权限组。 如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。您可以查看官方文档 。 我就知道你懒，给你截图了。如果你想看官方文档，就看看下面的图。 告诉用户你为什么需要这个权限 当用户选择单次拒绝权限的时候，你再次请求该权限，可以告知用户为什么你的app需要这些权限，以便让用户理解这些权限的作用。系统也提供了对应的方法 ActivityCompat.shouldShowRequestPermissionRationale() 。如果app之前请求过此权限，并且用户拒绝了请求这个方法就会返回true。如果app之前请求过此权限，并且用户勾选了”禁止后不再询问”，这个方法将返回false。 一次完整的权限请求 动态权限的相关其实并没有多少，来看看一段完整的请求CAMERA权限的示例。123456789101112131415161718192021222324252627282930313233343536private void checkPermission()&#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PermissionChecker.PERMISSION_GRANTED) &#123; //...开始做羞羞的事情 &#125; else &#123; requestCameraPermission(); &#125;&#125;private void requestCameraPermission() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; new AlertDialog.Builder(this) .setMessage("需要请求相机访问权限以便进行预览，拍摄") .setPositiveButton("好的", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125; &#125;) .create() .show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CAMERA) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...又可以做羞羞的事情了 &#125; &#125;&#125; 你该知道的 1. 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限 。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统 会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED ，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。 2. 要活用 shouldShowRequestPermissionRationale() 方法。这个方法是在用户拒绝过某个权限的请求(但不是禁止后不再询问)后会返回true，然后你可以在这个方法中做一些对该权限的解释，以便用户更了解为什么需要授予该权限。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致敬2017，关于以后]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%87%B4%E6%95%AC2017%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[由来 今天从人事那里要到了年会拍摄的全部照片，看到自己的照片已经可以弄成一个表情包还是挺意外的。不过更让我意外的是，有些照片我竟然一点记忆片段都没有，为什么，因为喝醉了，喝醉了，喝醉了！！！是的，你没有猜错，写这篇文章只是想告诉自己以后不能胡来，有些事情该做，但是也要有底线。 关于2017 自2016年6月大学毕业以来，这是我工作的第一个完整年头，从16年8月23号从1号店辞职，9月8号来到杭州，到10月17日入职果树以来，已经过去1个多年头，在此经历了很多有意思的事情，遇到了很多有意思的人，也做了人生第一次表白！嗯，是的，第一次，你没听错。虽然讲给朋友听的时候，他们说我很蠢，表白这种事情应该当面说，怎么能够在手机上说呢，哈哈，但是对于我来说，至少是跨出过第一步！嗯，这是一个值得回忆的事情(虽然有时候我确实不太会表达自己内心的想法)。这一个年头，自己的技术虽然没有得到突飞猛进的增长，但是多多少少还是有一定的提高的。 反思 1. 喝酒误事，这句话你已经体验过两次了；一次是在16年的一次公司聚会上，红酒掺杂着啤酒和白酒，导致再次醒来的时候躺在医院的病床上挂着葡萄糖；一次是刚刚过去的的年会，但是这次却没有上次那样的安静，做了很多 不可描述 的事情。虽然在同事看来可能并没有什么，但是我觉得，有些事情能避免发生就应该把它扼杀在萌芽处。俗话说 “事不过三” ，时刻告诫自己，喝酒既伤身，又误事！！！ 2. 熬夜，2017年马上就要过去了，但是这个坏习惯还是一直伴随着自己，每次并不是不想睡觉，而是强行找点事情来做，我也不知道为什么，就是不想那么早的睡着，可能我有点“黑暗恐惧症”(可能吧，哈哈)。在今后的日子里，尽量早点休息，不要熬夜； 3. 充实自己，是的，每次空闲的时间不是拿来玩游戏，就是拿来玩游戏！导致自己不太善于与人交谈；其次导致自己很宅，这也是自己一直是单身的原因之一吧！哈哈哈。所以，2018，努力改变自己，充实自己，多多接触外面的世界，外面的人，找点摆脱单身的生活。 关于博客 时刻记住自己创建这个博客的初衷！生活，不管有意思没意思，只要是值得回味的事情，都可以记录下来；技术，不管简单或是困难，只要是有自己的感悟，就值得分享出来，因为它是你成长的路程。 关于自己 我竟然对自己无话可说，哈哈哈！！！但记住，时刻做好自己，做好自己经手的每一件事情！相信你会成长为一位优秀的人员！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
