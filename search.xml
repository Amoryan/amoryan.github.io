<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kotlin Standard.kt持续更新]]></title>
    <url>%2F2017%2F12%2F16%2Fkotlin-Standard-kt%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[前言 今年Google在IO大会上宣布kotlin正式成为Android开发的官方语言。这门语言在很早以前久就已经存在，也比较成熟了。最近项目正好要重构，打算和侃哥一起使用这门新的语言开始项目的重构之旅。于是就趁着这段空闲的时间学习学习kotlin语言。 说明 它的语法是真的简洁，简洁到对于初学者的我完全看不懂。比如，一个扩展函数是这样定义的。12@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; 太TND强(操)大(蛋)了，这是什么鬼，只留下一脸懵逼的我在这里浮想联翩。在你继续往下面读之前，我先声明一下，这篇文章不是讲kotlin语法，如果你想要学习kotlin，可以移步到这里 kotlin in action 。这篇文章以及后续的一系列文章只是记录它强大的扩展函数库。 run12@kotlin.internal.InlineOnlypublic inline fun &lt;R&gt; run(block: () -&gt; R): R = block() 我们先来解释一下这个函数的定义是怎么回事，以方便你理解后面的这些函数。 public我就不赘述了，inline 关键字我们后面单独说，fun 关键字表示定义的是一个函数； &lt;R&gt; 表示的是泛型，泛型你在Java里面应该很熟悉了； run 是扩展函数名称； block: () -&gt; R，block表示run函数接受一个名叫block的参数，这个参数是 () -&gt; R，它是一个lambda表达式，它不接受任何参数，但是有一个返回值R； : R = block()，: R 表示的是返回值是R，= block() 表示这个返回值是执行block表达式而来的。 12@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block() 这是对任意一个类的扩展函数，比如你有一个Person类和它的实例person，然后你可以直接调用person.run{}，它定义的是T类型的扩展函数。它适用于执行某段代码然后返回某个值 。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>Standard.kt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限的处理]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 Android运行时权限机制 是在 API 23(Android M) 中提出来的，今年已经发布了API 26、27(Android O)，已经过去几个版本了，但是为什么我要写这个东西。首先，以前在开发的过程中，为了图方便，只是 简单的将build.gradle 中的 targetSdkVersion 设置为 22，所以基本上没有太多的和运行时权限打交道，但是随着这个人啊越来越老( 帅 )，觉得不应该躲避新的东西，而应该正视它，不然自己的技术永远都不会得到提高。所以最近打算将targetSdkVersion逐渐升上去，玩点新东西。 这是什么 在 API 23 以前，如果用户在安装应用后，默认是同意了应用所需要的权限(但是Android厂商众多，也有很多手机会弹窗提示用户是否授予权限)。而运行时权限的加入，简化了应用的安装过程，因为用户在安装的过程中不需要授予权限，而在应用的运行过程中，可以选择是否授予应用相关的权限。举个简单的例子，用户可以为相机提供相机访问权限，但是不提供位置的访问权限。 权限分类 系统权限分为两类：Normal Permission 和 Dangerous Permission” ，前者 不会直接给用户的隐私带来风险 ，所以如果你的app在Manifest文件中列出了应用需要这些权限，系统会自动赋予该权限。后者 会赋予app访问用户隐私数据的权限，是有可能对用户隐私造成风险的 。所以如果你的app在Manifest文件中列出了这些权限，则这些 权限的授予是由用户决定的 。 如何使用 接下来，我们就要开始来玩运行时权限了。 检测权限 如果你的app需要 Dangerous Permission ，则每次执行需要这一权限操作的时候都应该检测自己是否具有该权限，因为用户始终可以自由的调用此权限。检测的方法有两种，但是源码是一样的，只是穿了个不同的外套而已。12345678int cameraPermissionState = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);cameraPermissionState = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA);//判断权限是否授予if (cameraPermissionState == PermissionChecker.PERMISSION_GRANTED) &#123; //...已经具有该权限，你可以做一些羞羞的事情了&#125; else &#123; //...没有权限，这个时候你需要获取该权限了&#125; 请求权限 Android提供了多种权限请求方式，调用这些方法将会显示一个无法自定义的Android对话框。你可以调用 requestPermission() 方法来请求你所需要的权限。1ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 处理权限请求响应 当用户响应权限弹窗的时候，系统将回调 onRequestPermissionsResult() 方法，告知用户的响应情况。所以我们必须重写这个方法，如下。1234567if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...用户允许相机访问权限，你可以做一些羞羞的事情了 &#125; else &#123; //...用户拒绝了相机访问权限 &#125;&#125; 注意，系统显示的权限弹窗是对于 权限组 而言的，它不会列出app需要的具体权限。比如，app想要READ_CONTACTS权限，系统会告诉用户app想要访问设备的联系人。同时，用户只需要为每个权限组授予一次权限，如果应用请求该权限组中的任何其他权限，系统将自动授予应用这些权限 。具体过程是你在 requestPermissions() 方法之后，系统会自动回调 onRequestPermissionsResult() 方法，并传入 PERMISSION_GRANTED 。 权限组 你可能会询问权限组又是什么东西，是的，我也问过自己。所有的Dangerous Permission都属于权限组。 如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。您可以查看官方文档 。 我就知道你懒，给你截图了。如果你想看官方文档，就看看下面的图。 告诉用户你为什么需要这个权限 当用户选择单次拒绝权限的时候，你再次请求该权限，可以告知用户为什么你的app需要这些权限，以便让用户理解这些权限的作用。系统也提供了对应的方法 ActivityCompat.shouldShowRequestPermissionRationale() 。如果app之前请求过此权限，并且用户拒绝了请求这个方法就会返回true。如果app之前请求过此权限，并且用户勾选了”禁止后不再询问”，这个方法将返回false。 一次完整的权限请求 动态权限的相关其实并没有多少，来看看一段完整的请求CAMERA权限的示例。123456789101112131415161718192021222324252627282930313233343536private void checkPermission()&#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PermissionChecker.PERMISSION_GRANTED) &#123; //...开始做羞羞的事情 &#125; else &#123; requestCameraPermission(); &#125;&#125;private void requestCameraPermission() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; new AlertDialog.Builder(this) .setMessage("需要请求相机访问权限以便进行预览，拍摄") .setPositiveButton("好的", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125; &#125;) .create() .show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CAMERA) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...又可以做羞羞的事情了 &#125; &#125;&#125; 你该知道的 1. 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限 。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统 会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED ，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。 2. 要活用 shouldShowRequestPermissionRationale() 方法。这个方法是在用户拒绝过某个权限的请求(但不是禁止后不再询问)后会返回true，然后你可以在这个方法中做一些对该权限的解释，以便用户更了解为什么需要授予该权限。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致敬2017，关于以后]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%87%B4%E6%95%AC2017%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[由来 今天从人事那里要到了年会拍摄的全部照片，看到自己的照片已经可以弄成一个表情包还是挺意外的。不过更让我意外的是，有些照片我竟然一点记忆片段都没有，为什么，因为喝醉了，喝醉了，喝醉了！！！是的，你没有猜错，写这篇文章只是想告诉自己以后不能胡来，有些事情该做，但是也要有底线。 关于2017 自2016年6月大学毕业以来，这是我工作的第一个完整年头，从16年8月23号从1号店辞职，9月8号来到杭州，到10月17日入职果树以来，已经过去1个多年头，在此经历了很多有意思的事情，遇到了很多有意思的人，也做了人生第一次表白！嗯，是的，第一次，你没听错。虽然讲给朋友听的时候，他们说我很蠢，表白这种事情应该当面说，怎么能够在手机上说呢，哈哈，但是对于我来说，至少是跨出过第一步！嗯，这是一个值得回忆的事情(虽然有时候我确实不太会表达自己内心的想法)。这一个年头，自己的技术虽然没有得到突飞猛进的增长，但是多多少少还是有一定的提高的。 反思 1. 喝酒误事，这句话你已经体验过两次了；一次是在16年的一次公司聚会上，红酒掺杂着啤酒和白酒，导致再次醒来的时候躺在医院的病床上挂着葡萄糖；一次是刚刚过去的的年会，但是这次却没有上次那样的安静，做了很多 不可描述 的事情。虽然在同事看来可能并没有什么，但是我觉得，有些事情能避免发生就应该把它扼杀在萌芽处。俗话说 “事不过三” ，时刻告诫自己，喝酒既伤身，又误事！！！ 2. 熬夜，2017年马上就要过去了，但是这个坏习惯还是一直伴随着自己，每次并不是不想睡觉，而是强行找点事情来做，我也不知道为什么，就是不想那么早的睡着，可能我有点“黑暗恐惧症”(可能吧，哈哈)。在今后的日子里，尽量早点休息，不要熬夜； 3. 充实自己，是的，每次空闲的时间不是拿来玩游戏，就是拿来玩游戏！导致自己不太善于与人交谈；其次导致自己很宅，这也是自己一直是单身的原因之一吧！哈哈哈。所以，2018，努力改变自己，充实自己，多多接触外面的世界，外面的人，找点摆脱单身的生活。 关于博客 时刻记住自己创建这个博客的初衷！生活，不管有意思没意思，只要是值得回味的事情，都可以记录下来；技术，不管简单或是困难，只要是有自己的感悟，就值得分享出来，因为它是你成长的路程。 关于自己 我竟然对自己无话可说，哈哈哈！！！但记住，时刻做好自己，做好自己经手的每一件事情！相信你会成长为一位优秀的人员！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
