<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git常用命令(持续更新)]]></title>
    <url>%2F2018%2F03%2F14%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%2F</url>
    <content type="text"><![CDATA[起因 一直使用的AndroidStudio进行开发，它将git的操作封装的十分简单，以至于我根本就没有细究git命令的作用，这就导致有时候和同事一起开发遇到问题了不知道怎么去解决。 准备工作 首先，我们得安装git，如果不会的，请自行百度或者google； 然后，我们在一个空白的文件夹下面新建一个git仓库，开始我们的git命令学习之旅 git rebase举个🌰 你刚接到一个需求需要开发A功能，然后你在本地切出一个dev_afunc的分支，然后开发了一部分的时候，你将代码commit了几次；这个时候，产品经理过来说有个B功能比较紧急，然后这个时候你需要开发B功能，这个时候你又创建了dev_bfunc的分支，在上面进行开发，开发完了之后验收通过然后发布了。这个时候你又要回过头来开发A功能。 A功能开发中 我们新拉出一个分支，然后做一些修改并提交到当前分支。123$ git checkout -b dev_afunc$ git add .$ git commit -m "开发A功能中" 这个时候git仓库是这个样子的 半路杀出个B 然后这个时候，B功能比较紧急，于是我们将分支切换到了master，然后再拉出一个dev_bfunc分支进行开发B功能，并做一些修改之后提交到当前分支。1234$ git checkout master$ git checkout -b dev_bfunc$ git add .$ git commit -m "开发B功能中" 这个时候git仓库是这个样子的。 B功能开发完了上线 然后我们将开发完的B功能合并到master分支上，进行发布上线。12$ git checkout master$ git merge dev_bfunc 这个时候git仓库是这个样子的。 继续A功能的开发 之后我们需要继续进行A功能的开发，并且要包含有已开发好的B功能。这个时候我们就可以使用rebase命令了。12$ git checkout dev_afunc$ git rebase master 然后我们发现iTerm中出现如下的问题，因为A功能和B功能修改的是同一个地方。 这个时候我们可以打开文件看看里面的内容如下所示。 然后我们通过git branch命令看看目前不在任何一个分支。 这个时候我们将文件的冲突解决掉之后，再继续进行rebase操作。12$ git add .$ git rebase --continue 然后我们在iTerm中可以看到rebase成功了。 最后我们再看看dev_afunc分支中文件的内容是不是真的是都有了。 git rebase图解 实际上git rebase的原理很简单，就是将当前分支的commit创建新的commit拼接到你要rebase的分支commit后面。 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何clone aosp]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%A6%82%E4%BD%95clone-aosp%2F</url>
    <content type="text"><![CDATA[什么是aosp aosp(android open source project)其实就是Android开源项目。 git地址: https://android.googlesource.com/。 clone项目 如果你想要把整个的aosp项目clone下来，建议你买个移动硬盘。本人比较穷，mac只有256G的存储空间，所以这里就只clone framework库的代码做示范，大概有2G左右。 准备工作git 首先你得在电脑上装git，啊，你问我为什么？你不装怎么clone项目(mdzz，谁问你了)。然后配置用户名和邮箱。12$ git config --global user.name "xxx"$ git config --global user.email "xxx@gmail.com" 找仓库地址 配置好你的git之后你需要在google的代码库里面找到framework的仓库地址，大概是下面这样。 开始clone 准备工作做完之后，我们就可以开始clone项目了。1$ git clone https://android.googlesource.com/platform/frameworks/base 一切似乎都在情理之中，然后过了一会，iTerm里面显示如下问题。 这个问题是因为git没法访问到framework的仓库。因为我的vpn是开启的，于是我觉得应该是git的问题，然后在google上搜索了下，git需要设置代理。123$ git config --global http.proxy "http://xxx.xxx.xxx:port"$ git config --global https.proxy "http://xxx.xxx.xxx:port"$ git config --global http.sslVerify false 我用的是蓝灯，在设置－网络－高级－代理里面可以查看代理地址。如下图所示 然后再次运行git clone命令，等待数分钟之后就能看到已经clone好的代码了。 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>点滴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2018%2F03%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在windows系统中，我们可以发现无论我们如何去开启任务管理器，都只能打开一个窗口，因为每个窗口显示的数据，做的功能都是一样的。我们日常的编码中，经常会遇到这样的情况，某个类希望只存在一个实例，这就需要用到 单例模式了 。 饿汉式 饿汉式单例模式比较简单。1234567891011public class Singleton&#123; private static final Singleton instance = Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 从上面的代码可以看出，在类加载的时候就会创建Singleton的对象。 懒汉式 懒汉式单例模式，就是讲对象的实例化放在使用的时候。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 上面这串代码在单线程里面是能够保证只创建一个对象的。但是放到多线程里面就会出现创建多个对象的情况。所以我们如果要创建一个线程安全的单例，则需要加 synchronized 关键字。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是加上同步之后又出现了另外一个性能问题，如果有很多个线程都在请求这个方法，而且这个方法里面要做很多的初始化操作，就会导致其他线程持续等待等情况，下面不使用方法锁的情况，但是需要加双重校验，因为有可能A线程走完第一层的判断后，CPU执行片给了B线程，然后B线程获取锁创建了对象，如果同步代码块里面不添加一层校验就会导致A线程也会创建对象。123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; holder模式 饿汉式没有办法延时加载，而懒汉式的同步在高并发的情况下又会影响性能。那么有没有另外一种方式能够克服这两者的缺点呢？答案肯定是有的。1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Holder.instance; &#125; private static class Holder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类Holder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 Kotlin下的单例模式饿汉式 kotlin下的饿汉式就有意思了，如下就是一个饿汉式的单例模式。1object Singleton 你没有看错，他就是一个饿汉式，我们通过工具可以看到它对应的java代码如下。1234567891011public final class Singleton &#123; public static final Singleton INSTANCE; private Singleton() &#123; INSTANCE = (Singleton)this; &#125; static &#123; new Singleton(); &#125;&#125; 懒汉式 kotlin里面是没有synchronized关键字的，如果要是用同步方法的形式，则需要使用 @Synchronized 注解。而同步代码块的方式是使用 synchronized() 方法。1234567891011121314151617181920class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null fun getSingleton(): Singleton &#123; if (instance == null) &#123; synchronized(Singleton::class.java) &#123; if (instance == null) &#123; instance = Singleton() &#125; &#125; &#125; return instance!! &#125; &#125;&#125; holder方式 再来看看holder方式如何通过kotlin来实现。123456789101112131415class Singleton private constructor() &#123; companion object &#123; fun getSingleton(): Singleton &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance: Singleton = Singleton() &#125;&#125; 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ViewPager如何一屏多显]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%85%B3%E4%BA%8EViewPager%E5%A6%82%E4%BD%95%E4%B8%80%E5%B1%8F%E5%A4%9A%E6%98%BE%2F</url>
    <content type="text"><![CDATA[前言 最近项目UI图上有个一屏显示多个Pager的控件，想了想直接通过ViewPager来实现。 实现方式 项目地址 getPageWidth 实际上PagerAdapter里面就提供了实现一屏多显的方法12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 这个方法返回的是 每个Pager的宽度 。然而，他的效果并不是我们想要的。来看看下面这段代码的运行效果。123override fun getPageWidth(position: Int): Float &#123; return 0.8f&#125; 它的效果如下所示，可以看到，默认每个pager都是 局左显示 的。 clipChildren 第二种实现方式就是通过控件的 clipChildren 属性，默认这个属性是true，我们需要将其设置为false，表示超出控件的内容范围也要显示出来。12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#bbbbbb" android:clipChildren="false" android:gravity="center" android:orientation="vertical" tools:context="com.yanfangxiong.multipagerdemo.MainActivity"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="180dp" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:clipChildren="false" android:overScrollMode="never"/&gt;&lt;/LinearLayout&gt; 这里将ViewPager和LinearLayout的clipChildren属性都设置为了false。然后在java代码中做如下设置。123456//设置预加载的数量是3，这个值默认是1viewPager.offscreenPageLimit = 3//pageMargin设置页面之间的距离val metrics = DisplayMetrics()windowManager.defaultDisplay.getMetrics(metrics)viewPager.pageMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 8f, metrics).toInt() 效果图如下所示。 扩展 感觉好像有点单调哈。我也是这么觉得的，那么我们来加点有趣的东西吧。ViewPager有个PageTransformer接口。1234567891011public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ void transformPage(View page, float position);&#125; 这里我就不写研究过程了，position的范围可以分为四段(通用的)，是当前page的左上角相对于ViewPager的位置。 position &lt; -1 -1 &lt;= position &lt; 0 0 &lt;= position &lt; 1 position &gt; 1 ScalePageTransformer 于是乎我写了一个切换尺寸变换的类ScalePageTransformer，如下。123456789101112131415class ScalePageTransformer( private var minScale: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val size = when &#123; position &lt; -1 -&gt; minScale position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minScale + (1 - minScale) * (1 + position) position &lt; 1 -&gt; minScale + (1 - minScale) * (1 - position) else -&gt; minScale &#125; page?.scaleY = size &#125;&#125; 效果图如下，这样就比较有趣了，嗯，我是这么认为的。 RotatePageTransformer 旋转跳跃，我闭着眼~1234567891011121314151617181920212223242526272829303132333435class RotatePageTransformer( private var rotateDegree: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; if (page == null) return val tPivotX: Float val degree: Float when &#123; position &lt; -1 -&gt; &#123; tPivotX = page.width.toFloat() degree = -rotateDegree &#125; position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; &#123; tPivotX = page.width.toFloat() degree = rotateDegree * position &#125; position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; &#123; tPivotX = 0f degree = rotateDegree * position &#125; else -&gt; &#123; tPivotX = 0f degree = rotateDegree &#125; &#125; page.apply &#123; pivotX = tPivotX pivotY = if (rotateDegree &lt; 0) 0f else page.height.toFloat() rotation = degree &#125; &#125;&#125; 来看看这个旋转变换的效果图。 AlphaPageTransformer 再来个透明度变化的吧。123456789101112131415class AlphaPageTransformer( private var minAlpha: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val alpha: Float = when &#123; position &lt; -1 -&gt; minAlpha position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minAlpha + (1 - minAlpha) * (1 + position) position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; minAlpha + (1 - minAlpha) * (1 - position) else -&gt; minAlpha &#125; page?.alpha = alpha &#125;&#125; 效果图如下 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-抽象工厂]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 不管是简单工厂还是工厂方法，每个工厂都只生产一种产品，而在现实生活中是会存在一个工厂生产多种商品的情况的。比如电器工厂，会生产电视机，电冰箱，空调等。 工厂方法 接下来我们使用工厂方法来实现上面的案例。 定义产品 现在有两种产品，冰箱和空调，有两个厂商(美的和海尔)都能够生产这两种产品。1234567891011121314151617interface IRefrigerator&#123;&#125;class HaierRefrigerator : IRefrigerator&#123;&#125;class MeidiRefrigerator : IRefrigerator&#123;&#125;interface IAirConditioner&#123;&#125;class HaierAirConditioner : IAirConditioner&#123;&#125;class MeidiAirConditioner : IAirConditioner&#123;&#125; 定义工厂 因为每个工厂只生产对应的产品，所以我们需要定义两个工厂接口。1234567891011121314151617181920212223interface IRefrigeratorFactory&#123; fun generateRefrigeratorImpl() : IRefrigerator&#125;class HaierRefrigeratorFactory : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125;class MeidiRefrigerator : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;interface IAirConditionerFactory&#123; fun generateAirConditionerImpl() : AirConditioner&#125;class HaierAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl() : AirConditioner = HaierAirConditioner()&#125;class MeidiAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl(): AirConditioner = MeidiAirConditioner()&#125; 生产产品 比如现在要生产美的的冰箱和空调。1234fun main(args : Array&lt;String&gt;)&#123; val refrigerator = MeidiRefrigeratorFactory().generateRefrigeratorImpl() val airConditioner = MeidiAirConditionerFactory().generateAirConditionerImpl()&#125; 思考 如果有N个产品需要生产，那么就需要扩展N个工厂。一旦工厂的数量变多，在调用的时候就很容易遗漏某些产品的生产，而且类的数量也会多很多，导致结构越来越复杂。 抽象工厂 像美的冰箱，美的空调是由相同的公司生产的，我们可以将其归为一个产品族，抽象工厂可以理解为一个工厂生产一个产品族的产品。现在我们来简化上面的代码。12345678910111213141516interface IFactory&#123; fun generateAirConditionerImpl() : IAirConditioner fun generateRefrigeratorImpl() : IRefrigerator&#125;class MeidiFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = MeidiAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;class HaierFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = HaierAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125; 生产产品 现在工厂定义好了，我们想要生产美的的产品就可以直接通过一个工厂生产了。12345fun main(args : Array&lt;String&gt;)&#123; val factory : IFactory = MeidiFactory() val airConditioner = factory.generateAirConditionerImpl() val refrigerator = factory.generateRefrigeratorImpl()&#125; 如果某个产品族新增加了某个产品，只需要在抽象工厂中新增加生产该产品的方法就可以了，这样就减少了工厂方法会导致的结构复杂性。 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 在设计模式－简单工厂文章中介绍的简单工厂，我们发现，如果在此基础上新增加一种图表的展示，那么就得修改静态工厂的generateChartImpl()方法。这无疑违反了开放封闭原则。 修改Factory 于是在简单工厂的基础上我定义了一个IChartFactory的接口，如下。12345interface IChartFactory &#123; fun generateChartImpl(): IChart&#125; 拆分Factory 然后将简单工厂的ChartFactory拆分成下面的类，如下。1234567891011121314151617class PieChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = PieChart()&#125;class BarChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = BarChart()&#125;class LinearChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = LinearChart()&#125; 测试 使用起来只需要通过对应的Factory创建对应的IChart对象就可以了。如下1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = PieChartFactory().generateChartImpl() chartImpl.display()&#125; 并且我们还发现，如果需要增加一种图表的显示只需要增加IChart的子类和对应的IChartFactory的子类就可以了，而不需要去修改已有的代码，这样就不会违反开闭原则了，而且具有一定的扩展性。 总结 从上面的代码中我们看出，虽然工厂方法能够有很好的扩展性，但是缺点也显而易见，它会导致类的数量越来越多，这样反而会增加系统的复杂度。 毒鸡汤 日子还长，请别失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于京东open-api-sdk的那些坑]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8E%E4%BA%AC%E4%B8%9Copen-api-sdk%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言 近来有位朋友让我用java测试下京东的open-api-sdk的调用，对此记录下在测试过程中遇到的那些坑。 ClassNotFound 于是乎我将sdk下载下来集成到项目中，然后按照文档上的内容编写了下面的代码。12345678910111213141516171819202122WareWriteUpdateWareRequest request = new WareWriteUpdateWareRequest();Ware ware = new Ware();ware.setWareId(/*wareId*/);ware.setTitle(/*title*/);ware.setTransportId(/*transportId*/);request.setWare(ware);JdClient client = new DefaultJdClient( "serverUrl", "accessToken", "appKey", "appSecret");try &#123; WareWriteUpdateWareResponse execute = client.execute(request); if (execute.getSuccess()) &#123; System.out.println("请求成功:" + execute.getMsg()); &#125; else &#123; System.out.println("请求失败:" + execute.getMsg()); &#125;&#125; catch (JdException e) &#123; e.printStackTrace();&#125; 似乎是没有毛病的，然后我运行了代码，得到了下面的结果！你没有看错，wtf，找不到类，什么鬼哦。 NoSuchMethod 然后朋友给我发了一篇博客，按照里面的配置，我修改了项目配置为maven项目，然后添加了如下的依赖。1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt; 本以为这样就没有问题了。但是事不如己愿，哈哈，又出现了下面的问题。 解决 看到这个异常我的第一反应就是open-api-sdk中调用的jar包的版本一定比我配置的要高，于是我在mavenrepository里面搜索了最新的jackson-core-asl和jackson-mapper-asl的jar最新版本，并且修改了pom.xml中的version信息。如下所示：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 然后，我再次运行了代码，得到以下结果。 吐槽 说实话，第一次见到sdk里面使用了三方的jar，但是又不在文档里面说明的，也是服气~ 毒鸡汤 日子还长，别太失望～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>点滴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂]]></title>
    <url>%2F2018%2F02%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 之前写代码从来都没有注重设计模式这一块，熟知的并且用的最多的就是单例模式，但是并没有什么卵用，现在项目越来越庞大，每次迭代都要改一堆东西，印象中重复的代码也越来越多，有时候迭代一个版本要改N多个地方的相同代码，如果哪个地方忘了就很蛋疼，但是让我去重构又不知道从何处下手，最近打算将设计模式的东西系统的学习一下，然后将自己写的代码好好的梳理一下。 举个栗子 现在产品经理需要一个图表展示的功能，包括折线图，饼图和柱状图等。于是我写了一个IChart的接口，只有一个display()方法。12345interface IChart &#123; fun display() &#125; 然后编写了几个IChart的子类，如下。1234567891011121314151617181920212223class PieChart : IChart &#123; override fun display() &#123; println("显示饼状图") &#125;&#125;class BarChart : IChart &#123; override fun display() &#123; println("显示柱状图") &#125;&#125;class LinearChart : IChart &#123; override fun display() &#123; println("显示折线图") &#125;&#125; 就这样写好了图表的相关类。然后就是如何根据不同的类型产生不同的类的对象。1234567891011class ChartFactory &#123; fun generateChartImpl(type: String): IChart &#123; return when (type) &#123; "bar" -&gt; BarChart() "linear" -&gt; LinearChart() else -&gt; PieChart() &#125; &#125;&#125; 最后我们来测试一下就可以了。1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = ChartFactory.generateChartImpl("linear") chartImpl.display()&#125; 运行结果如下所示，这就是简单的工厂模式。 毒鸡汤 日子还长，请别失望～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac插入U盘的只读问题]]></title>
    <url>%2F2018%2F02%2F21%2Fmac%E6%8F%92%E5%85%A5U%E7%9B%98%E7%9A%84%E5%8F%AA%E8%AF%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 最近帮我舅舅重装系统，因为要将我电脑上的系统镜像复制到U盘中， 然后发现我只能读取U盘里面的文件，而不能进行写入操作。 U盘文件系统格式 想要解决这个问题，首先你得了解U盘的文件系统格式。于是我将U盘插在windows电脑上进行格式化的时候，发现格式化的种类有3种，NTFS ， FAT32 ， exFAT 。那么我们来看看这几种格式的区别。 这里推荐一款免费的软件 Mounty11 。它支持在mac读写NTFS文件系统格式的U盘。 NTFS 它全称New Technology File System(新技术文件系统)。支持LZ77压缩、文件级加密、访问控制。主文件表(MFT)负责存储稳健的属性、位置、访问信息。这种格式在mac如果不使用工具是无法写入文件的，当然它还有一些弊端，比如最大分区，最大文件只支持2TB，（日常够用了）兼容范围不如FAT32，长时间使用会影响U盘寿命。所以这种文件系统格式肯定不是我们要的。 FAT32 它是1997年的Windows 95 OSR2，在第二版系统中首次引入的文件系统格式。 它有很好的兼容性，几乎所有主流系统都能对其格式写入读取 。既然有这么好的兼容性，那我们是不是就直接将U盘格式化为FAT32就可以了。当然不是，这种文件系统虽然有很好的兼容性，却有很多的弊端。 这种文件格式安全无保障，对于单个的文件移动，体积不能超过4G，并且文件名称长度不能超过255个字节 ，所以这不是最好的选择。 exFAT 微软专门为闪存设备设计的文件系统，高容量的SDXC卡默认都是这种格式。文件名最高可达65536个，分区和单个文件支持最大可达到16EB，写读取速度稳定。最主要的是它在mac和windows之间都可以进行读写操作。 解决 最终我并没有选择使用第三方工具在mac进行读写NTFS的U盘，而是将U盘格式化为exFAT的格式，然后再将文件拖放到U盘中，再制作启动盘。 总结 如果只是简单的拖放小文件，你完全可以选择使用FAT32文件系统格式，如果需要拖放大文件则可以考虑使用NTFS或者exFAT，当然不建议使用NTFS，因为它对U盘的使用寿命有影响。 毒鸡汤 日子还长，请别失望~ 祝大家新年快乐]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>点滴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于迅雷下载BT出现的版权方问题]]></title>
    <url>%2F2018%2F02%2F13%2F%E5%85%B3%E4%BA%8E%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BDBT%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%88%E6%9D%83%E6%96%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 2月11号的动车从杭州回家，于是我为了打发在车上的5个多小时时间，2月10号的晚上准备下载一些电影在动车上看。当然是以前看过了的电影，哈哈。于是在google上搜索了速度与激情8和机器之血的BT文件，正当我准备通过迅雷下载这些文件的时候，发现任务的右下角显示 应版权方要求，该资源无法下载 。 WTF！！！ 原因 这个原因是版权方和迅雷交涉后，迅雷通过技术阻止了文件的下载。看到这里忍不住爆了一句粗口，mmp。 解决方案 作为一个程序猿怎么能够被这种问题影响而不看电影，是吧。于是我上google搜索了一些解决方案，找到了一个比较好的方法。 准备工作 首先你得有一个 百度网盘账号 ，因为接下来我们准备通过百度网盘来进行下载这些文件。 获取BT文件的下载地址 获取这个地址的方式比较简单，你只需要在迅雷的下载任务列表选择一个无法下载的文件，然后右键 复制文件下载链接 就可以了。 建立离线下载任务 然后，你就可以登录百度网盘，新建离线下载任务。如下图所示。 然后选择新建链接任务，将在迅雷上复制的链接粘贴上去，建立任务就可以了。 通过百度云盘app进行文件下载 最后你只需要通过百度云盘的app进行文件下载就可以了。 毒鸡汤 日子还长，请别失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>点滴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android support annotation]]></title>
    <url>%2F2018%2F01%2F30%2Fandroid-support-annotation%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Architecture Components]]></title>
    <url>%2F2018%2F01%2F30%2FAndroid-Architecture-Components%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Kotlin遇上Parcelable]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%BD%93Kotlin%E9%81%87%E4%B8%8AParcelable%2F</url>
    <content type="text"><![CDATA[由来 因为现在项目里面都是用 kotlin 在编写项目，在跨界面传递数据的时候经常需要传递对象数据，这就需要使用到 对象的序列化 ，就难免和 Parcelable 打交道。 序列化的方式 在Android中，对象的序列化方式是有两种的，一种是Java中的 Serializable ，一种是Android特有的 Parcelable 。既然Google新增加了一种 Parcelable 的方式，那必然有它的道理，我们先来看看两者有啥不可告人的秘密。 Serializable的序列化方式 这种序列化方式给我们的第一印象就是 简洁 。因为你只需要实现 Serializable 接口就可以了。这是一个标识接口，你不需要实现任何方法，Java就会对其进行序列化操作。但但但是，这种序列化的方式使用了 反射，而且在序列化过程中产生很多的临时对象，造成过多的内存消耗 。1234567891011package com.yanfangxiong.kotlinparcelabledemoimport java.io.Serializable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Serializable Parcelable的序列化方式 这种序列化方式是Android所特有的。而且使用起来 比较复杂 ，我们先来举个栗子。12345678910111213141516171819202122232425262728293031323334353637package com.yanfangxiong.kotlinparcelabledemoimport android.os.Parcelimport android.os.Parcelable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Parcelable &#123; companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(parcel: Parcel, flags: Int) &#123; parcel.writeString(name) parcel.writeString(sex) &#125; override fun describeContents(): Int &#123; return 0 &#125;&#125; 详解Parcelable writeToParcel() 通过这个方法你可以将对象的属性都写入到parcel中； describeContents() 这个方法一般情况下默认就好了。关于这个方法，API中是这么描述的，它表示这个Parcelable对象序列化内容的类别。举个栗子，如果你要序列化对象里面包含文件描述符，那么你需要将这个方法修改为返回 CONTENTS_FILE_DESCRIPTOR ； 编写一个类CREATOR继承自 Parcelable.Cretor ，这个接口包含两个方法，createFromParcel()从Parcel容器中值，newArray()这个方法是 供外部类反序列化本类数组使用的 。 从上面的代码我们就可以看出，如何序列化这个对象已经非常清楚的表现出来，根本不需要通过反射来知道来推断类型，所以能够更加高效的序列化对象。 区别与抉择 Serializable实现方式简单，但是比较消耗内存，一般建议在序列化对象保存到文件中的时候使用； Parcelable实现方式较为复杂，但是效率高，消耗内存小，在代码中建议使用这种方式。 问题所在 我们知道，在kotlin中伴生对象只能存在一个 ，一般一些在java中的静态常量我们可能会定义在伴生对象中，但是我们可以看上面的Person的Parcelable实现，系统默认给我们创建的CREATOR对象就直接指定为了伴生对象，这样虽然是没有问题的，但是你定义的一些常量就是属于CREATOR对象了，实际上这是不必要的，所以我们需要一种方式将伴生对象 “释放” 出来。 这里我们就直接上代码了。只需要使用 ＠JVMField 注解就可以解决这个问题。12345678910111213141516companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = object : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 但但但是，前面说了，使用Parcelable的序列化方式，类里面的方法会增加很多，所以我们打算来优化优化。 首先，kotlin像java 8一样，接口中的方法可以有默认的实现 ，于是我决定写一个KParcelable的接口，如下12345interface KParcelable : Parcelable &#123; override fun describeContents() = 0 override fun writeToParcel(dest: Parcel, flags: Int)&#125; 这样就减少了对象中的 describeContents 方法的实现。然后我们再来优化CREATOR的实现方式。对此我写了下面的函数123456inline fun &lt;reified T&gt; parcelableCreator(crossinline creator: (Parcel) -&gt; T) = object : Parcelable.Creator&lt;T&gt; &#123; override fun createFromParcel(source: Parcel): T = creator(source) override fun newArray(size: Int): Array&lt;T?&gt; = arrayOfNulls(size) &#125; 它接受一个名为 creator 的方法，然后返回一个 Parcelable.Creator 的实现类，这样我的Person类就可以简化为如下的方式。12345678910111213141516171819202122data class Person( var name: String?, var sex: String?) : KParcelable &#123; companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = parcelableCreator(::Person) &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(dest: Parcel, flags: Int) = with(dest) &#123; writeString(name) writeString(sex) &#125;&#125; 这样看着就舒服多了，哈哈哈。 毒鸡汤 生活不如意时是上帝给你放的长假～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装Recycler适配器]]></title>
    <url>%2F2018%2F01%2F23%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85Recycler%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 前段时间就说要用kotlin写RecyclerView的适配器，但一直在忙于项目的迭代，所以就没抽出时间来落地。其实也不算封装，只是简化了开发的过程而已。 直奔主题 这里我就不废话了，直接上代码吧。123456789101112131415161718192021222324252627282930313233343536373839404142import android.content.Contextimport android.support.annotation.LayoutResimport android.support.v7.widget.RecyclerViewimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroup/** * @author fxYan */abstract class CommonRecyclerAdapter&lt;T&gt;( val context: Context, @LayoutRes val resId: Int, val data: List&lt;T&gt;) : RecyclerView.Adapter&lt;CommonRecyclerAdapter.ViewHolder&gt;() &#123; private var onItemClickListener: OnItemClickListener&lt;T&gt;? = null fun setOnItemClickListener(listener: OnItemClickListener&lt;T&gt;) &#123; onItemClickListener = listener &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; onItemClickListener?.apply &#123; holder.itemView.setOnClickListener &#123; onItemClick(position, data[position]) &#125; &#125; bindData(holder.itemView, position, data[position]) &#125; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder = ViewHolder(LayoutInflater.from(context).inflate(resId, parent, false)) override fun getItemCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T) class ViewHolder(view: View) : RecyclerView.ViewHolder(view) interface OnItemClickListener&lt;in T&gt; &#123; fun onItemClick(position: Int, data: T) &#125;&#125; LayoutRes是什么 这个注解是 android support annotation 库中的一个注解，表示这里resId是一个布局文件的id，如果你在调用的时候不是传递的布局文件的id，编译的时候就可以检测出来，很方便，有时间会写一篇关于 android support annotation 的文章。 使用 使用起来也是比较简单，只需要实现bindData()方法就可以了。1234567891011121314151617/** * @author fxYan */class CreditExtensionRecordListAdapter( context: Context, resId: Int, data: List&lt;OrderListRespBean&gt;) : CommonRecyclerAdapter&lt;OrderListRespBean&gt;(context, resId, data) &#123; override fun bindData(view: View, position: Int, data: OrderListRespBean) &#123; view.orderTimeTv.text = data.gmtCreate view.prodPicIv.setImageURI(Uri.parse(data.prodPic ?: ""), null) view.prodNameTv.text = data.prodName &#125;&#125; 毒鸡汤 生活不止眼前的枸杞，还有远方的西洋参。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera的使用]]></title>
    <url>%2F2018%2F01%2F10%2FCamera%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介 Android的framework支持通过android.hardware.camera2API或者是过时的Camera来拍摄图片和视频。这篇文章讲解的是Camera的使用，后续会写一篇关于camera2使用的文章。当然，如果你等不及的话可以去看看google博客关于camera2的文章，camera2文章地址，请翻墙查看。 基础 android.hardware.camera2，这个包是控制设备相机的主要API，它可以被用来拍摄图片或者视频当你想构建一个相机app的时候； Camera，这个类也是用来控制设备相机的，但是在API21之后过时了； SurfaceView，这个类用来给用户呈现相机的预览； MediaRecorder，这个类通过相机来录制视频； Intent，如果你的目的仅仅只是简单的拍摄一张图片或者一段视频，你完全可以调用系统的相机让它来完成这些事情，而不需要直接操控系统相机。你可以使用MediaStore.ACTION_IMAGE_CAPTURE来调用系统相机来拍摄图片，或者通过MediaStore.ACTION_VIDEO_CAPTURE来调用系统相机来拍摄视频。 Manifest声明 当你使用Camera API进行开发的时候，你必须确保你的manifest文件中声明了相关的东西。 Camera Permission，当app需要使用设备相机的时候必须声明这个权限 1&lt;uses-permission android:name="android.permission.CAMERA" /&gt; Camera Features，同时得声明使用相机相关的特性，比如。关于camera features的列表，可以查看Features Reference。添加camera features到manifest文件中会导致Google Play防止你的应用安装在那些没有相机或者是不支持相机特性的设备上。如果你的app并不是一定需要camera，你可以在manifest中通过 android:required 来指定。 1&lt;uses-permission android:name="android.hardware.camera" android:required="false" /&gt; Storage Permission，如果应用程序需要将图片或者视频保存到external storage中，还需要声明这个权限； 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; Audio Recording Permission，视频录制的过程中还需要录制音频，所以得添加音频录制的权限，音频录制在之前的文章中已经讲过，不懂的可以去 Android录制系列之音频录制进行查阅； 1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; Location Permission，如果app需要给图片打上GPS定位信息的tag，你需要申请 ACCESS_FINE_LOCATION 权限，这里需要注意，Android5.0及以上版本需要声明使用设备的GPS； 123&lt;uses-permission android:name ="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;!-- targetSdkVersion &gt;= 21 的需要添加 --&gt;&lt;uses-feature android:name="android.hardware.location.gps" /&gt; 如何使用访问相机 检索并访问相机，如果你的app没有在manifest文件中声明是否只能安装在有相机的设备上，那么在使用之前，请检测设备是否有相机的硬件支持。1fun hasFeatureCamera(context: Context) = context.packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) Android2.3 之后你可以直接通过 Camera.getNumberOfCameras() 方法直接获取到设备上可用的相机数量。如果你非常清楚你app运行在有相机支持的设备上运行时，你可以直接通过 Camera.open() 方法去请求并获取一个Camera的实例，它会 访问设备上的第一个后置摄像头。12345678910fun getCamera(): Camera? &#123; var camera: Camera? = null try &#123; camera = Camera.open() &#125; catch (e: Exception) &#123; //如果不捕获异常，相机在被其他的app使用，或者设备上根本没有相机的时候，就会导致app crash Log.d("Amoryan", "open camera error!") &#125; return camera&#125; Android 2.3 之后你可以通过 Camera.open(int) 访问指定的相机。比如，你可以这么玩。123456789101112131415fun getCameraInfo() &#123; try &#123; for (i in 0 until Camera.getNumberOfCameras()) &#123; val cameraInfo: Camera.CameraInfo = Camera.CameraInfo() Camera.getCameraInfo(i, cameraInfo) if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; Log.d("Amoryan", "$i is back facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; else &#123; Log.d("Amoryan", "$i is front facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125;&#125; 设置预览 设置预览界面，你可以直接使用SurfaceView，或写一个SurfaceView的子类，然后实现SurfaceHolder.Callback的相关回调，这里我为了方便起见，直接在布局文件中使用SurfaceView了12345678&lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; 然后实现相对应的回调接口12345678910111213141516171819class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125; 拍摄图片 通过 takePicture 方法拍摄图片，这里只是简单的将拍摄的图片显示在ImageView上了。1234567891011captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125;private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125;&#125; 释放Camera Camera是设备上的共享资源，当app获取到Camera的实例后就可以使用它，但是在app不需要Camera或者当界面变得不可见的时候应该正确的释放。举个栗子，当界面变得不可见的时候，如果你没有正确的释放掉资源，就会导致接下来想要访问Camera的app获取失败，而没办法正常工作。12345override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null&#125; 完整代码 github项目地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.yanfangxiong.camerademoimport android.Manifestimport android.content.pm.PackageManagerimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.hardware.Cameraimport android.os.Bundleimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.view.SurfaceHolderimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; companion object &#123; val REQUEST_CAMERA_PERMISSION = 1 &#125; private var camera: Camera? = null private var bitmap: Bitmap? = null private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125; &#125; private fun checkCameraPermission() &#123; val cameraPermissionStatus = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) if (cameraPermissionStatus == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; &#125; private fun openCamera() &#123; camera = safeOpenCamera() setupCamera() &#125; private fun setupCamera() &#123; camera?.apply &#123; setDisplayOrientation(90) setPreviewDisplay(surfaceView.holder) safeStartPreview() &#125; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; if (camera == null) &#123; checkCameraPermission() &#125; else &#123; setupCamera() &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; camera?.safeStopPreview() setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null &#125; private fun releaseBitmap() &#123; bitmap?.recycle() bitmap = null &#125;&#125; 毒鸡汤 人生不如意的时候是上帝给的长假。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之视频录制]]></title>
    <url>%2F2018%2F01%2F09%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 视频录制使用的是 Camera 和前面讲过的 MediaRecorder。在视频录制的过程中你需要通过 Camera.unlock() 和 Camera.lock() 方法来允许MediaRecorder来访问硬件相机。和使用 Camera 拍摄图片不一样，拍摄视频有 严格的调用顺序。 如何使用 接下来我们就来看看该怎么玩这个玩意。 获取Camera 首先我们得获取到 Camera 。获取相机的方式这里就不在过多的说明了，如果你还是不知道可以去查看我的另外一个文章 Camera的使用。 设置预览界面 这里使用的是SurfaceView，你也可以去查看Camera的使用这篇文章。1234567891011121314151617181920212223242526override fun onCreate(savedInstanceState: Bundle?) &#123; //... surfaceView.holder.addCallback(this) //...&#125;override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera()&#125;override fun surfaceDestroyed(holder: SurfaceHolder?) &#123;&#125;override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission()&#125; 开始录制 相机的准备工作做好之后就可以开始录制了。 通过 Camera.unlock() 允许MediaRecorder访问Camera； 通过 MediaRecorder.setCamera() 将MediaRecorder和Camera关联； 设置音频源，通过 MediaRecorder.setAudioSource() 设置音频源为 MediaRecorder.AudioSource.CAMCORDER； 设置视频源，通过 MediaRecorder.setVideoSource() 设置视频源为 MediaRecorder.VideoSource.CAMERA； 设置输出格式和编码方式，不过在 Android2.2 之后你就可以通过 MediaRecorder.setProfile() 方法来设置一个录制视频的配置； 通过 MediaRecorder.setOutputFile() 设置录制视频后保存的文件路径； 通过 MediaRecorder.setPreviewDisplay() 设置预览界面是SurfaceView； 经过以上的配置之后MediaRecorder就已经准备完成，之后你就可以调用 MediaRecorder.prepare() 表示你已经准备完成了； 通过 MediaRecorder.start() 开始录制； 停止录制 当你录制完成之后，也需要正确的释放资源。 通过 MediaRecorder.stop() 停止当前的录制； 通过 MediaRecorder.reset() 重置当前的MediaRecorder配置，以便之后其他app的使用； 通过 MediaRecorder.release() 将MediaRecorder释放； 通过 Camera.lock() 将相机资源锁住，方便其他的app进行使用； 通过 Camera.stopPreview() 停止相机的预览； 通过 Camera.release() 释放相机的资源，方便其他的app进行使用。 小技巧 如果你使用Camera来录制视频，你可以通过 setRecordingHint() 在开启预览前设置为true，这个方法能够减少开始录制的时间。 项目地址 github项目地址 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package com.yanfangxiong.mediarecorderdemoimport android.Manifestimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.hardware.Cameraimport android.media.CamcorderProfileimport android.media.MediaRecorderimport android.os.Bundleimport android.os.Environmentimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.util.Logimport android.view.SurfaceHolderimport android.view.Viewimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_video_recorder.*import java.io.File/** * @author fxYan */class VideoRecorderActivity : AppCompatActivity(), View.OnClickListener, SurfaceHolder.Callback &#123; companion object &#123; const val REQUEST_CAMERA_PERMISSION = 1 const val REQUEST_RECORD_AUDIO_PERMISSION = 2 fun jumpToActivity(context: Context) &#123; val intent = Intent(context, VideoRecorderActivity::class.java) val queryIntentActivities = context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY) if (queryIntentActivities != null &amp;&amp; queryIntentActivities.isNotEmpty()) &#123; context.startActivity(intent) &#125; &#125; &#125; private var camera: Camera? = null private var mediaRecorder: MediaRecorder? = null private var isRecording = false override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_video_recorder) surfaceView.holder.addCallback(this) controlIv.setOnClickListener(this) &#125; override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.controlIv -&gt; &#123; if (camera == null) &#123; return &#125; if (isRecording) &#123; //如果在录制中 try &#123; mediaRecorder?.stop() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop media recorder error!") &#125; releaseMediaRecorder() &#125; else &#123; //开启录制 checkRecordAudioPermission() &#125; &#125; &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission() &#125; private fun checkCameraPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -&gt; &#123; openCamera() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; &#125; private fun checkRecordAudioPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -&gt; &#123; startRecord() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION) &#125; &#125; &#125; private fun openCamera() &#123; try &#123; camera = Camera.open() setupCamera() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125; &#125; private fun setupCamera() &#123; try &#123; camera?.apply &#123; parameters.focusMode = Camera.Parameters.FOCUS_MODE_AUTO setPreviewDisplay(surfaceView.holder) setDisplayOrientation(90) startPreview() autoFocus(null) &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "set up camera error!") releaseCamera() &#125; &#125; private fun releaseCamera() &#123; try &#123; camera?.stopPreview() camera?.release() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release camera error!") &#125; camera = null &#125; private fun startRecord() &#123; try &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; reset() camera?.unlock() setCamera(camera) setAudioSource(MediaRecorder.AudioSource.CAMCORDER) setVideoSource(MediaRecorder.VideoSource.CAMERA) setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_1080P)) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "videoRecorder.mp4") setOutputFile(file.absolutePath) setPreviewDisplay(surfaceView.holder.surface) prepare() start() isRecording = true Toast.makeText(this@VideoRecorderActivity, "开启录制...", Toast.LENGTH_SHORT).show() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "mediaRecorder error!") releaseMediaRecorder() &#125; &#125; private fun releaseMediaRecorder() &#123; try &#123; mediaRecorder?.apply &#123; reset() release() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release media recorder error!") &#125; camera?.lock() mediaRecorder = null isRecording = false &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecord() &#125; &#125; override fun onPause() &#123; super.onPause() releaseMediaRecorder() releaseCamera() &#125;&#125; 毒鸡汤 走过一些弯路，也好过原地踏步～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之音频录制]]></title>
    <url>%2F2018%2F01%2F06%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介 Android的多媒体框架包含并支持录制和解码多种多样的音视频格式。如果设备支持，你可以使用MediaRecorder来进行这些操作。( Android模拟器无法录制音频 ) MediaRecorder的使用权限 如果你想进行音频录制，你必须添加RECORDER_AUDIO的权限，这是一个 危险权限 ，如果你不知道如何请求权限，你可以查看之前的一篇文章 Android运行时权限的处理。1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; 配置MediaRecorder 配置一个MediaRecorder你只需要简单的几步就可以了。 首先，我们得创建一个 MediaRecorder 的实例对象； 1val mediaRecorder = MediaRecorder() 通过 setAudioSource() 方法设置音频源，音频源的取值你可以直接查看 MediaRecorder.AudioSource，一般情况下我们会选择 MIC 也就是麦克风作为音频源； 1mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC) 通过 setOutputFormat() 方法设置输出格式，输出格式的取值你可以直接查看 MediaRecorder.OutputFormat； 1mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) 通过 setAudioEncoder() 方法设置音频解码方式，解码方式的取值你可以直接查看 MediaRecorder.AudioEncoder 1mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC) 通过 setOutputFile() 方法设置保存文件的路径， 12val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "audioRecorder.3gp")mediaRecorder.setOutputFile(file.absolutePath) 完成初始化配置后，你就可以调用 prepare()方法 ；然后调用 start() 你就可以开始录制了。 12mediaRecorder.prepare()mediaRecorder.start() 值得注意的 大部分(包括DEFAULT)的音频源 都会对音频信号做处理 ，如果你想录制原始的音频，你可以选择MediaRecorder.AudioSource.UNPROCESSED(当然你也可以选择AudioRecorder这个更接近底层的类，后面会找时间写一篇关于AudioRecorder录制的文章)。 有些设备是不支持录制未处理的音频，你可以通过下面的这种方式来获取设备是否支持录制原始音频。1234567val audioManager: AudioManager? = getSystemService(Context.AUDIO_SERVICE) as? AudioManagervar isSupportedRawAudioInput = "false"audioManager?.apply &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; isSupportedRawAudioInput = getProperty("android.media.property.SUPPORT_AUDIO_SOURCE_UNPROCESSED") &#125;&#125; 嗯~what，我相信你也发现了，这个方法是 API 17 才出现的。目前公司项目的最低支持是16，所以得找一种方式在 API 16 上也能够获取到这个属性。结合之前的一些经验，我最初的想法是先看看API16的AudioManager的源码，希望这个方法是本身存在的，只是被隐藏了，这样我就可以直接通过反射的方式去调用，但是事实不是如此，在API16中，AudioManager确实是没有getProperty()方法 ；于是，本着学习的态度，我翻看了更高版本的AudioManager的源码，发现它的调用链是这个样子的。123if (PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED.equals(key)) &#123; return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportAudioSourceUnprocessed));&#125; 仿佛抓到一颗救命稻草，于是我想我直接在代码里面获取这个属性不就好了，这里给你萌看一张图吧，上面代码是这个样子的，找不到com.android.interal.R。 然后，我去google上搜索了关于如何引用这个资源文件，首先，通过反射是肯定可以获取到的，但是google会有一个警告告诉你 通过反射的方式访问内部APIs可能会在某些设备上不支持 ，所以还是用下面这个安全的方式吧。1resources.getBoolean(Resources.getSystem().getIdentifier("config_supportAudioSourceUnprocessed", "bool", "android")) 嗯哼，高兴的太早了，于是乎我就开启了API16的模拟器运行了起来，当走到这一行代码的时候，就出现了下面的结果，好吧，这个属性的判断似乎只能是API17才能用，所以还是用官方推荐的那种方式吧。 如果不支持的情况下，你可以尝试使用 MediaRecorder.AudioSource.VOICE_RECOGNITION 。它不使用AGC(Auto Gain Control，自动增益控制，当信号源较强的时候，使其增益自动降低；当信号源较弱的时候，使其增益自动增高)，并且不会做降噪处理。当然，即使设备不支持UNPROCESSED，你仍旧可以设置为这个，只是这样你就不知道音频信号有没有被处理了。 MediaRecorder的状态 这里直接使用官方的状态图了，如下 事件监听 MediaRecorder提供了两个监听事件的接口，一个是MediaRecorder.OnInfoListener，另一个是MediaRecorder.OnErrorListener。 OnInfoListener 可以用来监听MediaRecorder的一些状态，比如最大录制事件到了等等。12345678910111213141516mediaRecorder.setOnInfoListener&#123; _,what,_-&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED-&gt;&#123; //这个枚举值对应mediaRecorder.setMaxDuration()，当设置的最大录制时间到了后，会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING-&gt;&#123; //这个枚举值对应setMaxFileSize()，当录制文件大小快接近最大值的时候会回调这个，这个是API26新增 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED-&gt;&#123; //当录制文件大小达到最大文件大小的时候会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED-&gt;&#123; //这个方法对应的是setNextOutputFile()，当录制视频超过指定大小后保存到next文件中的时候就会回调这个值，这个是API26新增 &#125; &#125;&#125; OnErrorListener 监听Error信息，12345678mediaRecorder.setOnErrorListener&#123;_, what, _ -&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN-&gt;&#123; &#125; MediaRecorder.MEDIA_ERROR_SERVER_DIED-&gt;&#123; &#125; &#125;&#125; 举个栗子 布局文件就不细说了，只有一个录制按钮和一个停止按钮。我们来看看Activity中核心的的代码。 请求权限123456789101112131415161718192021222324252627282930override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.startRecorderTv -&gt; checkRecordAudioPermission() R.id.stopRecorderTv -&gt; stopRecorder() &#125;&#125;private fun checkRecordAudioPermission() &#123; val hasRecordAudioPermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) when &#123; hasRecordAudioPermission == PackageManager.PERMISSION_GRANTED -&gt; startRecorder() ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.RECORD_AUDIO) -&gt; AlertDialog.Builder(this) .setCancelable(false) .setMessage("请求音频录制权限，否则无法录制音频") .setNegativeButton("取消") &#123; _, _ -&gt; &#125; .setPositiveButton("确定") &#123; _, _ -&gt; requestRecordAudioPermission() &#125; .show() else -&gt; requestRecordAudioPermission() &#125;&#125;private fun requestRecordAudioPermission() &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION)&#125;override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecorder() &#125;&#125; 开始录制123456789101112131415161718private fun startRecorder() &#123; if (!isRecording) &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; setAudioSource(MediaRecorder.AudioSource.MIC) setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) setAudioEncoder(MediaRecorder.AudioEncoder.AAC) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), AUDIO_RECORDER_FILE_NAME) setOutputFile(file.absolutePath) try &#123; prepare() &#125; catch (e: Exception) &#123; &#125; start() isRecording = true &#125; &#125;&#125; 停止录制12345678910private fun stopRecorder() &#123; if (isRecording) &#123; mediaRecorder?.apply&#123; stop() release() &#125; isRecording = false mediaRecorder = null &#125;&#125; 项目地址github地址 官方文档 官网的Guide也是给出了MediaRecorder的详细使用，以及在 API 26 中新增的 MediaMuxer to record multiple channels 。 毒鸡汤 将来的你一定会感谢现在拼命的自己～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择列表请对CheckBox说No]]></title>
    <url>%2F2018%2F01%2F05%2F%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E8%AF%B7%E5%AF%B9CheckBox%E8%AF%B4No%2F</url>
    <content type="text"><![CDATA[由来 我记得刚学习Android的时候，有个需求是这个样子的，做一个单选或者多选的选择列表。然后那个时候懂得不是很多，就用CheckBox去做。做来做去，发现很多的坑，比如控件会被重用，导致选中的状态也被重用了。后来随着自己接触的东西变多，想到用另外一种方式来实现选择列表，但是这并不是我写这篇文章的原因。主要原因是最近在看同事写的代码(我们是两个人在开发)的时候，发现选择列表还是用的CheckBox，我觉得有必要分享下自己的实现方式，当然如果你们有什么好的建议记得及时告诉我。 实现方式 接下来我就说一下我是如何实现选择列表的(欢迎大家来吐槽)。先来一张效果图，比较简单。github项目地址 level-list 官方文档的介绍请戳这里。它可以通过一些值来管理一系列的图片，然后通过level属性修改这些值后就会显示对应的图片。 举个栗子 因为是选择列表，那必然会有两张图片，一张是未选中的，我们记为ic_select_off，一张是选中的，我们记为ic_select_on。然后我们可以在drawable文件夹下新建一个level_list_common_select.xml的资源文件。具体代码如下123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_select_off" android:maxLevel="0"/&gt; &lt;item android:drawable="@mipmap/ic_select_on" android:maxLevel="1"/&gt;&lt;/level-list&gt; 布局文件 接下来，我们说说布局文件，我们不会用到CheckBox，这里我们用ImageView来顶替CheckBox，大致如下所示。123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff" android:orientation="horizontal" android:paddingLeft="12dp" android:paddingRight="12dp"&gt; &lt;ImageView android:id="@+id/selectStatusIv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:src="@drawable/level_list_common_select"/&gt; &lt;TextView android:id="@+id/selectTitleTv" android:layout_width="match_parent" android:layout_height="match_parent" android:ellipsize="end" android:gravity="center_vertical" android:lines="1" android:paddingLeft="12dp" android:singleLine="true" android:textColor="#333333" android:textSize="16sp"/&gt;&lt;/LinearLayout&gt; 这里并没有太多花里胡哨的东西，只是用一个ImageView替换掉了CheckBox。 核心逻辑 你需要找一个能够唯一标记这个选项的字段，比如id，这个字段一般都会有。然后我们的适配器里面会存放一个selectId，在渲染View的方法中校验当前项的id是否和选中的id是一致的，如果一致，则将level设置为1，否则设置为0就可以了。12345678910111213141516171819202122232425262728package com.yanfangxiong.levellistimplementselectlistimport android.content.Contextimport android.view.Viewimport com.guoshujinfu.mobile.gscloud.migration.adapter.CommonListAdapterimport kotlinx.android.synthetic.main.listitem_select.view.*/** * @author fxYan */class SelectListAdapter( context: Context, resId: Int, data: List&lt;SelectBean&gt;) : CommonListAdapter&lt;SelectBean&gt;(context, resId, data) &#123; private var selectId: Long? = null fun setSelected(selectId: Long) &#123; this.selectId = selectId &#125; override fun bindData(view: View, position: Int, data: SelectBean) &#123; view.selectStatusIv.drawable.level = if (data.id == selectId) 1 else 0 view.selectTitleTv.text = data.title &#125;&#125; 这里用的kotlin编写的，CommonListAdapter可以去看之前写的用kotlin封装的适配器。这样这个单选的逻辑就写完了。嗯，就是这么简单，不用关心CheckBox重用导致的状态复用问题。 总结 如果我不去思考该如何简化，那我永远都只是死板的用CheckBox来完成选择列表。所以，要学会思考，只根据产品给的需求完成相应的任务那是一个初级程序猿做的事情。日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装List适配器]]></title>
    <url>%2F2017%2F12%2F25%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85List%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 最近在迁移C端项目到B端，然后有很多功能点对于B端是不一样的，所以打算在迁移的过程中，用kotlin去重新写一遍。最近这几天忙着写项目，所以没有抽出什么时间来写博客，但是写博客这么好的习惯得养成，决定以后每周至少写一篇博客。 没有使用kotlin的适配器 因为ListView的适配器用kotlin封装起来比较简单，所以暂时先写关于ListView的，后续想好怎么去写RecyclerView的适配器的时候再补上。在没有使用kotlin之前，我们项目中的适配器是这样封装的，分成了两个文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public abstract class CommonListAdapter&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected int mResId; protected List&lt;T&gt; mData; public CommonListAdapter(@NonNull Context context, @LayoutRes int resId, @NonNull List&lt;T&gt; data) &#123; this.mContext = context; this.mResId = resId; this.mData = data; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = CommonViewHolder.getHolder(mContext, mResId, position, convertView, parent); bindData(holder, mData.get(position)); return holder.getConvertView(); &#125; /** * 数据绑定 * * @param holder ViewHolder对象 * @param t 要绑定的数据对象 */ public abstract void bindData(@NonNull CommonViewHolder holder, @NonNull T t);&#125;public class CommonViewHolder &#123; private SparseArray&lt;View&gt; mViews; private LayoutInflater mLayoutInflater; private View convertView; private int position; private CommonViewHolder(Context context, int resId, int position, ViewGroup parent) &#123; mViews = new SparseArray&lt;&gt;(); mLayoutInflater = LayoutInflater.from(context); convertView = mLayoutInflater.inflate(resId, parent, false); convertView.setTag(this); this.position = position; &#125; public static CommonViewHolder getHolder(Context context, int resId, int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = null; if (convertView == null) &#123; holder = new CommonViewHolder(context, resId, position, parent); &#125; else &#123; holder = (CommonViewHolder) convertView.getTag(); holder.position = position; &#125; return holder; &#125; public View getConvertView() &#123; return convertView; &#125; public int getPosition() &#123; return position; &#125; public &lt;T extends View&gt; T get(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = convertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125;&#125; 每次只需要重写bindData方法就可以了，但是如果listitem布局中的控件多起来，还是得调用get方法很多次。最近学习了kotlin之后，在迁移中，我发现，诶，居然可以这么玩。请看下面的栗子。 使用kotlin后的适配器 可能是单身限制了我的想象力。它居然可以这么简洁，简洁，简洁。1234567891011121314151617181920abstract class CommonListAdapter&lt;T&gt;( var context: Context, @LayoutRes var resId: Int, var data: List&lt;T&gt;) : BaseAdapter() &#123; override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123; val view = convertView ?: LayoutInflater.from(context).inflate(resId, parent, false) bindData(view, position, getItem(position)) return view &#125; override fun getItem(position: Int): T = data[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T)&#125; 是的，你没有看错，就是这个样子的。然后在你的build.gradle文件中增加上这个插件。1apply plugin: 'kotlin-android-extensions' 然后你就可以任性的玩耍了。比如有这么一个布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="60dp" android:background="#ffffff" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/repayDateTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center_vertical" android:lineSpacingExtra="6dp" android:paddingLeft="12dp" android:paddingRight="10dp" android:textColor="#646464" android:textSize="12sp" tools:text="2017-10-10\n12:00"/&gt; &lt;TextView android:id="@+id/repayAmountTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:textColor="#333333" android:textSize="14sp" tools:text="1000.00"/&gt; &lt;TextView android:id="@+id/statusTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:paddingLeft="10dp" android:paddingRight="12dp" android:textColor="#333333" android:textSize="14sp" tools:text="处理中"/&gt;&lt;/LinearLayout&gt; 适配器就只有这么几行代码就可以解决了。12345678910111213class RepayRecordAdapter( context: Context, resId: Int, data: List&lt;RepayRecordListRespBean&gt;) : CommonListAdapter&lt;RepayRecordListRespBean&gt;(context, resId, data) &#123; override fun bindData(view: View, position: Int, data: RepayRecordListRespBean) &#123; view.repayDateTv.text = data.getSeparateTime() view.repayAmountTv.text = data.moneyOrder view.statusTv.text = data.getStatusText() &#125;&#125; 说真的，我已经逐渐爱上这门语言了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin之集合的惰性操作]]></title>
    <url>%2F2017%2F12%2F16%2Fkotlin%E4%B9%8B%E9%9B%86%E5%90%88%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 最近在学习kotlin的时候，发现了一个 骚操作 ，它叫集合的惰性操作。什么，你问我为什么称它 骚 ？我也不知道，反正脑海中就浮现了这么个词语！可能是贫穷限制了我的想象力！ 举个栗子 比如有这么一个场景，你是一家猎头公司的人员(别问我为什么是猎头，因为我看完猎场了)。然后你需要从一批人员中筛选符合条件的人选。123456data class Person(var name: String, var age: Int = 0, var workYear: Int = 0, var mail: String?)val persons = listOf(Person("Tom", 20, 2, "Tom@mail.com"), Person("Mike", 22, 3, "Mike@mail.com"), Person("Jerry", 21, 3, "Jerry@mail.com"), Person("Atom", 22, 2, "Atom@mail.com")) 你需要筛选出工作年限不小于３年的人的联系方式，然后联系他们准备进行面试。1234567println(persons.filter &#123; println("filter operate!") it.workYear &gt;= 3&#125;.map &#123; println("map operate!") it.mail&#125;) 上面的代码会输出如下的结果，这样你就成功的筛选出了Mike和Jerry。 如果你不了解 filter 和 map 两个扩展函数，可以查看源码中的这两个扩展函数是怎么写的 _Collections.kt。从输出结果上我们也可以看出它的流程是这样的，先对persons集合的每一个元素调用filter，然后会产生一个新的集合，然后对新的集合调用map，这样就得到了所有符合条件人员的联系方式。 Sequence序列 上面已经说明了这段代码的执行流程，倘若你要从你们成百上千万的人才库中筛选这些人员，执行效率是不是就非常低下了，而且如果变换操作过多的时候，你会创建很多个临时的集合。这时候，惰性操作就出来的，解释排后，代码先行！12345678910println("result is:" + persons.asSequence() .filter &#123; println("filter operate!") it.workYear &gt;= 3 &#125; .map &#123; println("map operate!") it.mail &#125; .toList()) 上面这段代码输出结果是这样的。 我们很容易就能够看出，它会对persons中的每一个元素先调用filter，如果满足条件再调用map；它是一个元素操作完之后再对另外一个元素做操作。我们再来看看一个神奇的现象，先把toList()删除掉，它会输出这个结果。 很神奇吧，它没有对persons中的元素做任何操作，只是单纯的返回了一个TransformingSequence的对象。 序列的操作 我们可以将序列的操作分为两类，intermediate operation 和 terminal operation 。看下面这张图你就明白了。 intermediate operation是惰性的。从上面的代码我们可以看出，只有当terminal operation执行的时候，intermediate operation才会执行。 总结 序列是对集合的每一个元素做所有的操作，而没有使用序列的时候是对一个集合做完某个操作后再对新的集合做后续操作； 序列只有在terminal operation调用的时候才会执行所有的操作。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限的处理]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 Android运行时权限机制 是在 API 23(Android M) 中提出来的，今年已经发布了API 26、27(Android O)，已经过去几个版本了，但是为什么我要写这个东西。首先，以前在开发的过程中，为了图方便，只是 简单的将build.gradle 中的 targetSdkVersion 设置为 22，所以基本上没有太多的和运行时权限打交道，但是随着这个人啊越来越老( 帅 )，觉得不应该躲避新的东西，而应该正视它，不然自己的技术永远都不会得到提高。所以最近打算将targetSdkVersion逐渐升上去，玩点新东西。 这是什么 在 API 23 以前，如果用户在安装应用后，默认是同意了应用所需要的权限(但是Android厂商众多，也有很多手机会弹窗提示用户是否授予权限)。而运行时权限的加入，简化了应用的安装过程，因为用户在安装的过程中不需要授予权限，而在应用的运行过程中，可以选择是否授予应用相关的权限。举个简单的例子，用户可以为相机提供相机访问权限，但是不提供位置的访问权限。 权限分类 系统权限分为两类：Normal Permission 和 Dangerous Permission” ，前者 不会直接给用户的隐私带来风险 ，所以如果你的app在Manifest文件中列出了应用需要这些权限，系统会自动赋予该权限。后者 会赋予app访问用户隐私数据的权限，是有可能对用户隐私造成风险的 。所以如果你的app在Manifest文件中列出了这些权限，则这些 权限的授予是由用户决定的 。 如何使用 接下来，我们就要开始来玩运行时权限了。 检测权限 如果你的app需要 Dangerous Permission ，则每次执行需要这一权限操作的时候都应该检测自己是否具有该权限，因为用户始终可以自由的调用此权限。检测的方法有两种，但是源码是一样的，只是穿了个不同的外套而已。12345678int cameraPermissionState = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);cameraPermissionState = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA);//判断权限是否授予if (cameraPermissionState == PermissionChecker.PERMISSION_GRANTED) &#123; //...已经具有该权限，你可以做一些羞羞的事情了&#125; else &#123; //...没有权限，这个时候你需要获取该权限了&#125; 请求权限 Android提供了多种权限请求方式，调用这些方法将会显示一个无法自定义的Android对话框。你可以调用 requestPermission() 方法来请求你所需要的权限。1ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 处理权限请求响应 当用户响应权限弹窗的时候，系统将回调 onRequestPermissionsResult() 方法，告知用户的响应情况。所以我们必须重写这个方法，如下。1234567if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...用户允许相机访问权限，你可以做一些羞羞的事情了 &#125; else &#123; //...用户拒绝了相机访问权限 &#125;&#125; 注意，系统显示的权限弹窗是对于 权限组 而言的，它不会列出app需要的具体权限。比如，app想要READ_CONTACTS权限，系统会告诉用户app想要访问设备的联系人。同时，用户只需要为每个权限组授予一次权限，如果应用请求该权限组中的任何其他权限，系统将自动授予应用这些权限 。具体过程是你在 requestPermissions() 方法之后，系统会自动回调 onRequestPermissionsResult() 方法，并传入 PERMISSION_GRANTED 。 权限组 你可能会询问权限组又是什么东西，是的，我也问过自己。所有的Dangerous Permission都属于权限组。 如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。您可以查看官方文档 。 我就知道你懒，给你截图了。如果你想看官方文档，就看看下面的图。 告诉用户你为什么需要这个权限 当用户选择单次拒绝权限的时候，你再次请求该权限，可以告知用户为什么你的app需要这些权限，以便让用户理解这些权限的作用。系统也提供了对应的方法 ActivityCompat.shouldShowRequestPermissionRationale() 。如果app之前请求过此权限，并且用户拒绝了请求这个方法就会返回true。如果app之前请求过此权限，并且用户勾选了”禁止后不再询问”，这个方法将返回false。 一次完整的权限请求 动态权限的相关其实并没有多少，来看看一段完整的请求CAMERA权限的示例。123456789101112131415161718192021222324252627282930313233343536private void checkPermission()&#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PermissionChecker.PERMISSION_GRANTED) &#123; //...开始做羞羞的事情 &#125; else &#123; requestCameraPermission(); &#125;&#125;private void requestCameraPermission() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; new AlertDialog.Builder(this) .setMessage("需要请求相机访问权限以便进行预览，拍摄") .setPositiveButton("好的", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125; &#125;) .create() .show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CAMERA) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...又可以做羞羞的事情了 &#125; &#125;&#125; 你该知道的 1. 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限 。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统 会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED ，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。 2. 要活用 shouldShowRequestPermissionRationale() 方法。这个方法是在用户拒绝过某个权限的请求(但不是禁止后不再询问)后会返回true，然后你可以在这个方法中做一些对该权限的解释，以便用户更了解为什么需要授予该权限。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致敬2017，关于以后]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%87%B4%E6%95%AC2017%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[由来 今天从人事那里要到了年会拍摄的全部照片，看到自己的照片已经可以弄成一个表情包还是挺意外的。不过更让我意外的是，有些照片我竟然一点记忆片段都没有，为什么，因为喝醉了，喝醉了，喝醉了！！！是的，你没有猜错，写这篇文章只是想告诉自己以后不能胡来，有些事情该做，但是也要有底线。 关于2017 自2016年6月大学毕业以来，这是我工作的第一个完整年头，从16年8月23号从1号店辞职，9月8号来到杭州，到10月17日入职果树以来，已经过去1个多年头，在此经历了很多有意思的事情，遇到了很多有意思的人，也做了人生第一次表白！嗯，是的，第一次，你没听错。虽然讲给朋友听的时候，他们说我很蠢，表白这种事情应该当面说，怎么能够在手机上说呢，哈哈，但是对于我来说，至少是跨出过第一步！嗯，这是一个值得回忆的事情(虽然有时候我确实不太会表达自己内心的想法)。这一个年头，自己的技术虽然没有得到突飞猛进的增长，但是多多少少还是有一定的提高的。 反思 1. 喝酒误事，这句话你已经体验过两次了；一次是在16年的一次公司聚会上，红酒掺杂着啤酒和白酒，导致再次醒来的时候躺在医院的病床上挂着葡萄糖；一次是刚刚过去的的年会，但是这次却没有上次那样的安静，做了很多 不可描述 的事情。虽然在同事看来可能并没有什么，但是我觉得，有些事情能避免发生就应该把它扼杀在萌芽处。俗话说 “事不过三” ，时刻告诫自己，喝酒既伤身，又误事！！！ 2. 熬夜，2017年马上就要过去了，但是这个坏习惯还是一直伴随着自己，每次并不是不想睡觉，而是强行找点事情来做，我也不知道为什么，就是不想那么早的睡着，可能我有点“黑暗恐惧症”(可能吧，哈哈)。在今后的日子里，尽量早点休息，不要熬夜； 3. 充实自己，是的，每次空闲的时间不是拿来玩游戏，就是拿来玩游戏！导致自己不太善于与人交谈；其次导致自己很宅，这也是自己一直是单身的原因之一吧！哈哈哈。所以，2018，努力改变自己，充实自己，多多接触外面的世界，外面的人，找点摆脱单身的生活。 关于博客 时刻记住自己创建这个博客的初衷！生活，不管有意思没意思，只要是值得回味的事情，都可以记录下来；技术，不管简单或是困难，只要是有自己的感悟，就值得分享出来，因为它是你成长的路程。 关于自己 我竟然对自己无话可说，哈哈哈！！！但记住，时刻做好自己，做好自己经手的每一件事情！相信你会成长为一位优秀的人员！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
