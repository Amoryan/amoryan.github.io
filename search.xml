<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJava2之concat和merge]]></title>
    <url>%2F2017%2F12%2F12%2FRxJava2%E4%B9%8Bconcat%E5%92%8Cmerge%2F</url>
    <content type="text"><![CDATA[前言 前段时间由于在准备年会相关的东西，所以没有怎么更新博客。话说，年会的时候喝醉了，然后 亲了不少人 ，好在(遗)是(憾)没有亲到妹子，不然我就没有脸再来公司了，哈哈哈哈，总之，这次年会还是挺有意思的。 最近在学习RxJava2，因为项目中本来就是用到了RxJava2和Retrofit，但是只是用了RxJava2的皮毛，它有很多功能强大的操作符都不是特别的了解。 concat操作符 concat是拼接的意思，既然是拼接，那就肯定是有先后顺序的。concat可以将多个被观察者发送的事件 按照顺序 拼接成一个事件流然后发送给订阅者。是的，注意它是严格顺序的。12345678Observable&lt;String&gt; ob1 = Observable.just("Hello");Observable&lt;String&gt; ob2 = Observable.just("RxJava2");Observable.concat(ob1, ob2) .subscribe(new Consumer&lt;String&gt;()&#123; public void accept(String s) throws Exception&#123; System.out.println(s); &#125; &#125;) 上面这段代码会输出如下结果 concatWith 实际上就是concat操作符对应的 实例方法 ，它是将 一个相同类型 的被观察者发送的事件流拼接在调用concatWith的被观察者的事件流后面。代码其实是差不多的，如下所示。123456ob1.concatWith(ob2) .subscribe(new Consumer&lt;String&gt;()&#123; public void accept(String s) throws Exception&#123; System.out.println(s); &#125; &#125;) 上面这段代码的输出结果和之前的是一样的，我这里就不再贴图了。 merge操作符 merge操作符，字面意思就能理解是合并的意思。是的，它的功能就是合并多个可被观察者发射的事件。12345678Observable&lt;String&gt; ob1 = Observable.just("Hello");Observable&lt;String&gt; ob2 = Observable.just("RxJava2");Observable.merge(ob1, ob2) .subscribe(new Consumer&lt;String&gt;() &#123; public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 上面这段代码会输出下面的结果，不管运行几次 mergeWith 这个和concatWith是一个性质的，它是merge操作符对应的 实例方法 ，是将 一个相同类型 的被观察者发送的事件流和调用mergeWith方法的被观察者的事件流合并。代码也是和merge操作符差不多，如下所示。123456ob1.mergeWith(ob2) .subscribe(new Consumer&lt;String&gt;() &#123; public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 上面这段代码的运行结果和merge操作符的结果也是一样的。 产生疑问了 是的，我相信你看到这里也会产生和我一样的疑问。两个不同的操作符却得到的是相同的结果，那为什么要弄两个不同的操作符呢。既然有两个操作符存在，那么肯定会有它存在的道理。所以我决定探究一下。 突破口 concat是拼接，它是必然有顺序的，merge是合并，那么说明它一定存在某种情况导致事件流发射是随机的。于是我打算让两个被观察者在不同的线程中发射数据，然后再看看concat和merge两个操作符是不是有不同的地方。123456789101112131415161718192021Observable&lt;String&gt; ob1 = Observable.just("Hello");Observable&lt;String&gt; ob2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; new Thread()&#123; public void run()&#123; try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; e.onNext("RxJava"); &#125; &#125;.start(); &#125; &#125;);ob2.mergeWith(ob1) .subscribe(new Consumer&lt;String&gt;() &#123; public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 果然不出所料，这里ob1的事件流是先发射出来的。 但是我们再来看看concatWith的结果。 是的，你没有看错，只有一个RxJava2的事件被发射了，因为concat是顺序发射拼接的事件流，关键就在于第二个被观察者的事件流什么时候发射？那当然是在第一个被观察者的事件流发射完成的时候，所以在onNext()之后要调用onComplete()，不然第二个被观察者的事件流是没办法发射出来的。123456789101112131415ObservableOnSubscribe&lt;String&gt;() &#123; public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; new Thread()&#123; public void run()&#123; try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; e.onNext("RxJava"); e.onComplete(); &#125; &#125;.start(); &#125; &#125;); 然后就得到了如下的结果。 delayError 不管是concat，还是merge，如果在发射事件流的过程中，发射了onError通知，那么后续的事件序列就结束了。所以delayError就出现了，它的意思就是说，我会保证事件流发射完成之后再发射onError通知。1234567891011121314151617181920Observable&lt;String&gt; ob1 = Observable.error(new NullPointerException());Observable&lt;String&gt; ob2 = Observable.just("Hello");Observable.mergeDelayError(ob1, ob2) .subscribe(new Observer&lt;String&gt;() &#123; public void onSubscribe(Disposable d) &#123; &#125; public void onNext(String o) &#123; System.out.println(o); &#125; public void onError(Throwable e) &#123; System.out.println("onError"); &#125; public void onComplete() &#123; System.out.println("onComplete"); &#125; &#125;); 它会保证Hello这个事件发射完成后再发射后在发射onError通知。如下图所示。 总结 concat拼接事件序列需要前一个事件序列发射了onComplete通知，后续的事件序列才能发射； merge在多线程的事件流序列中不一定是按照顺序发射的，而concat一定是顺序的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
