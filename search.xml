<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Window的管理服务WindowManagerService]]></title>
    <url>%2F2018%2F04%2F23%2FWindow%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1WindowManagerService%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用注解封装动态权限]]></title>
    <url>%2F2018%2F04%2F20%2F%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%B0%81%E8%A3%85%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-代理模式]]></title>
    <url>%2F2018%2F04%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 前段时间我们分析了kotlin的委托，委托实际上有点类似于静态代理模式，趁着委托的记忆还没有消失(我的记忆力比鱼稍微好一丢丢(理直气壮))，我们来分析下代理模式。 静态代理 静态代理模式中，有3个重要的角色 协议，它抽离了代理类和真实类的共性； 代理类，直接与客户进行交互，在内部访问真实类，但同时又可以对真实类的访问附加额外的操作； 真实类，代理类中真正操作的。 协议 首先我们定义一个抽象接口，它有一个request方法。123interface IBase&#123; fun request() &#125; 真实类 然后，我们定义一个真实类，它实现了协议。12345class BaseImpl:IBase&#123; override fun request()&#123; //...request &#125;&#125; 代理类 最后，我们定义一个代理类，它同样也实现了协议，同时它包含了一个真实类的实例对象。12345678910class BaseImplProxy:IBase&#123; private val baseImpl:BaseImpl by lazy&#123; BaseImpl() &#125; override fun request()&#123; //这里实际调用真实角色的request() baseImpl.request() &#125;&#125; 写到这里，我们发现上面和kotlin的委托是一模一样的原理。但是静态代理中，我们可以在request()中做一些额外的操作。12345678910111213override fun request()&#123; preRequest() baseImpl.request() postRequest()&#125;private fun preRequest()&#123; //...请求前做的事情&#125;private fun postRequest()&#123; //...请求后做的事情&#125; kotlin的委托就不能做这些事情。 动态代理 Java中的动态代理，我们得认识两个玩意，一个是InvocationHandler，一个是Proxy，它们位于reflect包下面。 协议 动态代理中，我们同样需要定义协议。123interface IBase&#123; fun request()&#125; 真实类 然后我们定义一个真实类。1234class BaseImpl : IBase&#123; override fun request()&#123; &#125;&#125; 实现InvocationHandler 然后我们需要实现InvocationHandler接口，里面包含有一个BaseImpl的实例对象。1234567891011class InvocationHandlerImpl : InvocationHandler &#123; private val baseImpl:BaseImpl by lazy&#123; BaseImpl() &#125; override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any? &#123; return method?.invoke(baseImpl, args) &#125;&#125; 创建代理类 一般我们会通过Proxy.newProxyInstance()创建代理类，它接受ClassLoader, Class&lt;?&gt;[]和一个InvocationHandler。12val clazz = IBaseImpl::class.javaval iBase:IBase = Proxy.newProxyInstance(clazz.classLoader, clazz.interfaces, object: InvocationHandlerImpl()&#123;&#125;) as IBase 这样我们通过iBase对象调用request()的时候实际上会被回调到InvocationHandler的invoke()，而我们在invoke()中调用了BaseImpl的request()。 Retrofit的动态代理 我们知道Retrofit里面使用了动态代理模式的。我们可以翻看它的源码，在Retrofit.java文件的create()中我们可以看到有动态代理的调用。12345678910111213141516171819202122public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 比如我们定义如下一个接口请求。12345678interface AdsService &#123; @POST("v4/client/ad/config") fun fetchAdsInfo( @Body reqBean: AdsReqBean ): Single&lt;Response&lt;BaseRespBean&lt;AdsRespBean&gt;&gt;&gt;&#125; 然后通过Retrofit的create()方法，我们就可以得到一个AdsService的代理对象了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window与WindowManager]]></title>
    <url>%2F2018%2F04%2F16%2FWindow%E4%B8%8EWindowManager%2F</url>
    <content type="text"><![CDATA[前言 日常开发过程中，接触更多的是View，对于Window却没有太多的接触，但实际上View都是通过Window来呈现的，而Window又是被WindowManager所管理的。这篇文章只是简单的介绍Window，WindowManager，关于Window的添加，更新和删除过程在后面的文章会说到。 Window Window是一个抽象类，它的唯一实现是PhoneWindow。应用程序的启动流程中会调用ActivityThread的performLaunchActivity()，而在这个方法中会调用Activity的attach()，我们再来看看attach()。123456789101112131415161718192021222324252627282930313233final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; //1.创建PhoneWindow，并设置PhoneWindow的一些属性 mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //2.给PhoneWindow设置WindowManager mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mWindow.setColorMode(info.colorMode);&#125; Activity的attach()中主要做了两件事情 创建PhoneWindow； 给PhoneWindow设置WindowManager DecorView PhoneWindow中有一个成员变量。1private DecorView mDecor; 它是DecorView，它是一个FrameLayout，作为Window的顶层View。那么它是如何被创建的呢，这就要说到Activity的setContentView()了。追随源码。12345678public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125;public Window getWindow() &#123; return mWindow;&#125; getWindow()只是简单的返回了mWindow这个成员，还记得前面的attach()吗，这个方法里面将mWindow初始化为PhoneWindow。也就是说setContentView()实际上调用了PhoneWindow的setContentView()方法。12345678910111213141516171819public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; //1.创建decorView installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //2.将传入的布局文件加载到mContentParent中 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; //...&#125; 接下来我们来看看installDecor()里面做了什么事情。1234567891011121314151617private void installDecor() &#123; if (mDecor == null) &#123; //创建DecorView mDecor = generateDecor(-1); //... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); &#125; else &#123; //... &#125; //...&#125; installDecor()主要干了两件事情。 调用generator()方法创建DecorView； 调用generateLayout()加载布局。 generateDecor()就是创建DecorView。1234protected DecorView generateDecor(int featureId) &#123; //... return new DecorView(context, featureId, this, getAttributes());&#125; 我们再来看看generateLayout()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273protected ViewGroup generateLayout(DecorView decor) &#123; /** * 这里有一大段代码都是在设置属性信息，我就只粘贴关键代码 */ //...省略若干行代码 /** * 这里是根据feature找到加载进DecorView的布局文件 */ int layoutResource; int features = getLocalFeatures(); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; layoutResource = R.layout.screen_simple; &#125; mDecor.startChanging(); //将找到的layoutResource添加到DecorView中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //找到id是android.R.id.content ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; //... return contentParent;&#125; 可以看到这个方法的逻辑非常清晰。 设置属性信息； 根据feature找到layoutResource，用来加载进DecorView； 找到id为android.R.id.content的控件返回，这里就是赋给mContentParent的。 mDecor.onResourcesLoaded()里面就是将layoutResource加载进mDecorView中。1234567891011121314151617181920void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; //... final View root = inflater.inflate(layoutResource, null); //将root添加到DecorView中 if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root; initializeElevation();&#125; PhoneWindow的setContentView()主要做了两件事情 调用installDecor()创建DecorView； 通过LayoutInflater将我们setContentView()传入的布局加载到mContentParent中，也就是android.R.id.content中。 一般结构 这里我看了layoutResource的布局文件，发现大部分的布局都如下图所示。而我们的布局就是被放到这个android.R.id.content布局中的。到这里就差不多了，DecorView就这样加载完毕了。 Callback Window中定义了一个Callback接口，Activity实现了Window.Callback接口，所以Window可以将某些事情交给Activity处理，回调接口里面的方法目前用到的不是很多，以后有用到的时候再来更新下面的方法。12345678910111213141516171819202122232425262728293031//键盘事件分发public boolean dispatchKeyEvent(KeyEvent event);public boolean dispatchKeyShortcutEvent(KeyEvent event);//触摸事件分发public boolean dispatchTouchEvent(MotionEvent event);public boolean dispatchTrackballEvent(MotionEvent event);public boolean dispatchGenericMotionEvent(MotionEvent event);public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);public View onCreatePanelView(int featureId);public boolean onCreatePanelMenu(int featureId, Menu menu);public boolean onPreparePanel(int featureId, View view, Menu menu);//menu打开的时候public boolean onMenuOpened(int featureId, Menu menu);//menuitem 选中的时候public boolean onMenuItemSelected(int featureId, MenuItem item);public void onWindowAttributesChanged(WindowManager.LayoutParams attrs);public void onContentChanged();//Window焦点改变的时候public void onWindowFocusChanged(boolean hasFocus);public void onAttachedToWindow();public void onDetachedFromWindow();public void onPanelClosed(int featureId, Menu menu);public boolean onSearchRequested();public boolean onSearchRequested(SearchEvent searchEvent);public ActionMode onWindowStartingActionMode(ActionMode.Callback callback);public ActionMode onWindowStartingActionMode(ActionMode.Callback callback, int type);public void onActionModeStarted(ActionMode mode);public void onActionModeFinished(ActionMode mode);default public void onProvideKeyboardShortcuts( List&lt;KeyboardShortcutGroup&gt; data, @Nullable Menu menu, int deviceId) &#123; &#125;;default public void onPointerCaptureChanged(boolean hasCapture) &#123; &#125;; WindowManager WindowManager是一个接口，它继承自ViewManager，它的实现类是WindowManagerImpl。 ViewManager十分简单，只有添加，更新和删除三个方法。123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 它的具体实现是在WindowManagerImpl中。12345678910111213141516@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 可以看到WindowManagerImpl中的方法调用都是委托给了mGlobal成员变量，它是WindowManagerGlobal的单例对象。1private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); WINDOW_SERVICE 在前面讲过的attach()中，我们还有一点没有分析，就是调用mWindow的setWindowManager()。这个方法的实现是在Window中。1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125; 我们来看看mContext.getSystemService()是如何获取到WindowManager的。Context的实现类是ContextImpl。1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; SystemServiceRegistry是一个专门管理系统服务的类。1234public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; SYSTEM_SERVICE_FETCHERS是一个HashMap，通过Context.WINDOW_SERVICE可以获取到注册的WindowManagerImpl对象。在SystemServiceRegistry的静态代码块中我们可以找到注册WindowManager的代码。123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() &#123; @Override public WindowManager createService(ContextImpl ctx) &#123; return new WindowManagerImpl(ctx); &#125;&#125;); 通过CachedServiceFetcher的get()我们可以获取到WindowManagerImpl对象。123456789101112131415public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; Object service = cache[mCacheIndex]; if (service == null) &#123; try &#123; service = createService(ctx); cache[mCacheIndex] = service; &#125; catch (ServiceNotFoundException e) &#123; onServiceNotFound(e); &#125; &#125; return (T)service; &#125;&#125; 然后我们再回过头看看Window的setWindowManager()里面的createLocalWindowManager()。123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; 这里创建一个新的WindowManagerImpl，并将PhoneWindow与之关联。 LayoutParams WindowManager中有个重要的内部类，它里面定义了Window的一些重要属性，比如Z-order，window样式等。 type 我们知道Window有很多种，比如Toast，PopupWindow，Dialog，Activity等，在使用手机的过程中经常会看到有很多的Window层叠显示，但是它们必然会存在覆盖关系，也就是说Window在Z轴上是有排列顺序的。而type这个字段实际上表示的是Window在z轴上的排列顺序，也就是我们说的Z-Order，type值越大，Window的显示越靠前。 在LayoutParams中定义了很多的常量，我们可以将Window的分为3类。 Application Window，type值在1-99之间，一般对应着一个Activity； Sub Window，type值在1000-1999之间，一般不能独立存在，需要依附在父Window上，比如Dialog； System Window，type值在2000-2999之间，一般需要声明权限才能够创建。 Application Window的常量定义如下。123456public static final int FIRST_APPLICATION_WINDOW = 1;public static final int TYPE_BASE_APPLICATION = 1;public static final int TYPE_APPLICATION = 2;public static final int TYPE_APPLICATION_STARTING = 3;public static final int TYPE_DRAWN_APPLICATION = 4;public static final int LAST_APPLICATION_WINDOW = 99; Sub Window的常量定义如下。12345678public static final int FIRST_SUB_WINDOW = 1000;public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4;public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;public static final int LAST_SUB_WINDOW = 1999; System Window的常量定义比较多，这里只列举几个，具体的可以在LayoutParam中找到。123456789public static final int FIRST_SYSTEM_WINDOW = 2000;public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;public static final int TYPE_SECURE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+15;public static final int LAST_SYSTEM_WINDOW = 2999; softInputMode 这个东西我们在开发过程中经常用到，比如在manifest.xml文件中的activity中设置windowSoftInputMode属性，这就是在设置softInputMode值。softInputMode会影响两点内容 软键盘的显示状态，state； Window与软键盘之间的交互方式，adjust option。 软键盘的显示状态 softInputMode控制软键盘的显示状态的常量值有如下几种，在LayoutParams中都可以找到。12345678public static final int SOFT_INPUT_MASK_STATE = 0x0f;public static final int SOFT_INPUT_STATE_UNSPECIFIED = 0;public static final int SOFT_INPUT_STATE_UNCHANGED = 1;public static final int SOFT_INPUT_STATE_HIDDEN = 2;public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;public static final int SOFT_INPUT_STATE_VISIBLE = 4;public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5; 下面我们来看看这些常量值会怎样影响软键盘的显示状态。 SOFT_INPUT_STATE_UNSPECIFIED，不设置任何显示状态； SOFT_INPUT_STATE_UNCHANGED，不改变软件盘的显示状态，举个栗子，现在有两个界面A和B，如果A界面的softInputMode设置为stateUnchanged，当你从A界面跳转到B界面再返回A界面的时候，软键盘的显示状态不会发生改变，也就是说，在B界面软件盘如果是显示，那么返回A的时候就是显示的；反之，如果B界面软键盘显示状态是隐藏的，那么返回A的时候就是隐藏的； SOFT_INPUT_STATE_HIDDEN，在合适的时候隐藏软键盘，比如用户导航到界面的时候； SOFT_INPUT_STATE_ALWAYS_HIDDEN，当Window获得焦点的时候总是隐藏软件盘，这个和stateHidden还是有区别的。举个栗子，同样有两个界面A和B，如果A的softInputMode设置的是stateHidden，当第一次导航到A界面的时候软键盘是隐藏的，当从A跳转到B界面，B界面将软键盘显示出来后再返回A界面，这个时候A界面软键盘保持显示状态；但是，如果A界面的softInputMode设置的是stateAlwaysHidden，同样的操作从B返回A界面的时候，软键盘会被隐藏掉； SOFT_INPUT_STATE_VISIBLE，在合适的时候显示软键盘，比如用户导航到界面的时候； SOFT_INPUT_STATE_ALWAYS_VISIBLE，当Window获得焦点的时候总是显示软键盘，这个和stateVisible的区别我就不举栗子了，与stateHidden，stateAlwaysHidden的区别一样。 Window和软键盘的交互方式 softInputMode控制Window和软键盘之间的交互方式的常量值有如下几种，同样定义在LayoutParams中。123456public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;public static final int SOFT_INPUT_ADJUST_PAN = 0x20;public static final int SOFT_INPUT_ADJUST_NOTHING = 0x30; 同样我们再来看看这些常量值会如何影响Window和软键盘之间的交互方式。 SOFT_INPUT_ADJUST_UNSPECIFIED，不指定任何的交互方式； SOFT_INPUT_ADJUST_RESIZE，允许Window改变大小当软键盘显示的时候，这样能够保证Window不被软键盘所遮挡。前方高能，注意，如果Window的flag包含FLAG_FULLSCREEN，那这个值将被忽略，当软键盘显示的时候，Window依旧保持full screen； SOFT_INPUT_ADJUST_PAN，当软键盘显示的时候，设置一个窗口平移。这个值不需要处理Window的大小改变，而只需要通过framework层做一个平移保证当前的输入焦点相对于用户是可见的就可以了； SOFT_INPUT_ADJUST_NOTHING，当软键盘显示的时候不做任何调整。 flag 这个值主要设置的是Window的一些属性。这里列举一些比较有用的flags。123456789101112//隐藏所有的装饰窗口，比如statusbar等public static final int FLAG_FULLSCREEN = 0x00000400;//当前Window在前台会保持屏幕常亮public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;//当前Window允许在锁屏之上显示，大概和那些锁屏软件有关系public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;//当前Window在前台允许进行锁屏操作public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;//模糊所有在Window之下的东西public static final int FLAG_DIM_BEHIND = 0x00000002;//硬件加速public static final int FLAG_HARDWARE_ACCELERATED = 0x01000000; Window的 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活的像最初的模样。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Window</tag>
        <tag>WindowManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托那点事]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%A7%94%E6%89%98%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[前言 本来这篇文章只是想写写kotlin中的lateinit和by lazy之间的区别，但是发现内容太少了，于是乎就想着顺便将我自己对于委托的理解写出来。 属性 kotlin中的属性，天生就带有setter()/getter()方法，比如我们在某个类中定义一个属性1var name:String = "fxyan" 实际上它和下面的代码是等价的。12345var name:String = "fxyan" get() = field set(value)&#123; field = value &#125; 起初我看到这个的时候很纳闷，这个field是什么，其实field就是代表了这个域本身。我们可以通过AndroidStudio的kotlin bytecode工具将字节码反编译成Java文件来揭露它神秘的面纱。1234567891011121314public final class TestClass &#123; @NotNull private String name = ""; @NotNull public final String getName() &#123; return this.name; &#125; public final void setName(@NotNull String value) &#123; Intrinsics.checkParameterIsNotNull(value, "value"); this.name = value; &#125;&#125; lateinit 我们知道，如果一个类里面的某个属性定义成lateinit之后，在使用的时候如果这个属性没有被初始化，就会抛异常，通过上面对属性的讲解，我们不难推出lateinit关键字做了什么事情。1lateinit var name 我们可以看到一个有趣的现象，lateinit关键字修饰的属性不能够自定义getter()/setter()方法。 其实lateinit关键字无非就是重写了name属性的getter()/setter()方法，在里面做了空值的判断，如果为空则抛出异常。这点我们同样可以通过kotlin bytecode工具来查看。12345678910111213141516171819public final class TestClass &#123; @NotNull public String name; @NotNull public final String getName() &#123; String var10000 = this.name; if (this.name == null) &#123; Intrinsics.throwUninitializedPropertyAccessException("name"); &#125; return var10000; &#125; public final void setName(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.name = var1; &#125;&#125; 所以我们可以很明显的知道一点，lateinit关键字不能修饰在可空的属性上，因为setter()方法中会校验，如果为空，则会抛出异常。 委托 下面我们来看看kotlin中的委托 类委托 类委托就是类中定义的方法实际上调用另外一个类的对象的方法。12345678910111213interface IBase &#123; fun print()&#125;class IBaseImpl( var name: String) : IBase &#123; override fun print() &#123; print(name) &#125;&#125;class Delegate(iBase: IBase) : IBase by iBase 我们执行下面的代码。1234fun main(args:Array&lt;String&gt;)&#123; val base:IBase = IBaseImpl("fxyan") Delegate(base).print()&#125; 得到了如下的运行结果。 通过运行结果我们大致上也能猜到它是怎么实现的。下面的代码不是通过反编译出来的，但是反编译出来的和下面的差不多。123456789101112131415161718192021222324252627282930313233343536373839public class DelegateTest &#123; public static void main(String[] args) &#123; IBase iBase = new IBaseImpl("fxyan"); new Delegate(iBase).print(); &#125;&#125;interface IBase &#123; void print();&#125;class IBaseImpl implements IBase &#123; private String name; public IBaseImpl(String name) &#123; this.name = name; &#125; @Override public void print() &#123; System.out.print(this.name); &#125;&#125;class Delegate implements IBase &#123; private IBase iBase; public Delegate(IBase iBase) &#123; this.iBase = iBase; &#125; @Override public void print() &#123; iBase.print(); &#125;&#125; 属性委托 定义一个委托属性很简单，只需要通过by关键字，by关键字后面就是属性委托。1var/val &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; 首先我们先定义一个委托类Delegate123class Delegate&#123;&#125; 然后定义一个类拥有一个委托属性。123class DelegateProperty&#123; var property:String by Deletage()&#125; 编译器报错了，我们需要给Delegate类增加getValue()，setValue()方法。12345678910class Delegate &#123; fun getValue(d: DelegateProperty, p: KProperty&lt;*&gt;): String &#123; return "" &#125; fun setValue(d: DelegateProperty, p: KProperty&lt;*&gt;, newValue: String) &#123; &#125;&#125; 这个时候编译器仍然在报错Delegate类的getValue()，setValue()方法需要添加operator关键字。1234567891011class Delegate &#123; operator fun getValue(d: DelegateProperty, p: KProperty&lt;*&gt;): String &#123; return "$d 对象的$&#123;p.name&#125;属性的getter()被委托给Delegate对象的getValue()" &#125; operator fun setValue(d: DelegateProperty, p: KProperty&lt;*&gt;, newValue: String) &#123; println("$d 对象的$&#123;p.name&#125;属性的setter()被委托给Delegate对象的setValue()") &#125;&#125; 这样一个完整的委托类就编写完了，下面我们来进行一下测试。1234567fun main(args: Array&lt;String&gt;) &#123; val d = DelegateProperty() println(d.property) d.property = "fxyan" print(d.property)&#125; 可以得到如下的运行结果。通过上面一系列的介绍，我们大致上可以推断出，属性委托实际上就是将属性的getter()/setter()方法委托给委托类的getValue()/setValue()。这点我们通过kotlin bytecode工具得到了证实。12345678910111213141516public final class DelegateProperty &#123; @NotNull private final Delegate property$delegate = new Delegate(); static final KProperty[] $$delegatedProperties = new KProperty[]&#123;(KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Reflection.getOrCreateKotlinClass(DelegateProperty.class), "property", "getProperty()Ljava/lang/String;"))&#125;; @NotNull public final String getProperty() &#123; return this.property$delegate.getValue(this, $$delegatedProperties[0]); &#125; public final void setProperty(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.property$delegate.setValue(this, $$delegatedProperties[0], var1); &#125;&#125; lazy属性 lazy实际上是一个扩展函数，接受一个lambda表达式作为参数1public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer) 同时我们看看SynchronizedLazyImpl()这个类。12345678910111213141516171819202122232425262728293031323334private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123; private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE private val lock = lock ?: this override val value: T get() &#123; val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T &#125; return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!() _value = typedValue initializer = null typedValue &#125; &#125; &#125; override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet." private fun writeReplace(): Any = InitializedLazyImpl(value)&#125; 我猜想，lazy实际上是在使用的时候调用这个类的get()方法，问了证实我的猜想，我在get()方法中断点了，同时我编写了如下几个类。1234567891011fun main(args: Array&lt;String&gt;) &#123; val d = Delegate() println(d.name) println(d.name)&#125;class Delegate &#123; val name: String by lazy &#123; "" &#125;&#125; 当执行val d = Delegate()这句话的时候并没有调用get()方法，当走到第二句话访问name属性的时候，走到了SynchronizedLazyImpl()类的get()方法，从SynchronizedLazyImpl类中，我们知道，第一次访问name属性的时候，value是一个单例类的对象private object UNINITIALIZED_VALUE。在get()方法中会走下面的分支，并使用lazy传入的lambda表达式赋值给value。123456789101112return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!() _value = typedValue initializer = null typedValue &#125;&#125; 而且我们发现它使用了同步，在多线程中使用lazy也不会发生问题，这一点是值得称赞的。当第二次访问的时候value已经被lambda表达式赋值，所以会走前面的分支。12345val _v1 = _valueif (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T&#125; 至此我们总结下lazy的使用 1. lazy只能修饰val的变量； 2. lazy是线程安全的； 3. 创建对象时，lazy修饰的域不会被初始化，只有第一次访问域的时候会使用lazy后面的lambda表达式进行初始化，之后再访问则直接返回初始化后的值。 Observable属性 这玩意实际上就一观察者，有点类似于Android新出的arch库中的LiveData，但是又没有其功能强大(斜眼笑)。通过Delegate.observable()我们可以创建一个可被观察的属性。123456class ObservableDelegate &#123; var name: String by Delegates.observable("") &#123; _, oldValue, newValue -&gt; println("oldValue is $oldValue, newValue is $newValue") &#125;&#125; 很好理解，每当name属性的值发生变化的时候，都会执行lambda表达式。我们来看看这个方法做了什么事情。1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 它接受一个初始值，和一个lambda表达式。然后我们看看ObservableProperty1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 每当给name属性赋值的时候都会调到这个类的setValue()，在里面检测是否发生了变化，如果变化了就会调用afterChange()，而这个方法在Delegate.observable()里面的实现就是直接调用我们传入的lambda表达式。 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活的像最初的模样~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图的载体View]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%A7%86%E5%9B%BE%E7%9A%84%E8%BD%BD%E4%BD%93View%2F</url>
    <content type="text"><![CDATA[什么是View View是屏幕上的一块矩形区域，负责绘制和触摸反馈。 View的生命周期 View中有很多回调方法，它们在View的不同生命周期阶段调用，比较常用的方法有下面这些。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * View在xml文件中加载完成的时候调用 */fun onFinishInflate()/** * View关联的Window可视性发生变化的时候调用 */fun onWindowVisibilityChanged(visibility: Int)/** * View的可视性发生变化的时候调用 */fun onVisibilityChanged(visibility: Int)/** * View关联的Window获取焦点或者失去焦点的时候调用 */fun onWindowFocusChanged(hasWindowFocus: Boolean)/** * View获取焦点或者失去焦点的时候调用 */fun onFocusChanged(gainFocus: Boolean, direction: Int, previouslyFocusedRect: Rect?)/** * 测量View及子View的时候调用 */fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)/** * 当View的大小发生变化的时候调用 */fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int)/** * 布局View及其子View的时候调用 */fun onLayout(changed: Boolean, w: Int, h: Int, oldw: Int, oldh: Int)/** * 绘制View及其子View的时候调用 */fun onDraw(canvas: Canvas)/** * View被关联到Window的时候调用 */fun onAttachedToWindow()/** * View从Window上分离的时候调用 */fun onDetachedFromWindow()/** * 触摸事件发生的时候调用 */fun onTouchEvent(event: MotionEvent?)/** * 物理按键事件发生的时候调用 */fun onKeyDown(keyCode: Int, event: KeyEvent)/** * 物理按键事件发生的时候调用 */fun onKeyUp(keyCode: Int, event: KeyEvent) 和Activity生命周期的关系 为了研究View生命周期和Activity生命周期之间的关系，我编写了一个CustomView类，下面我们就来看看究竟发生了什么有趣的事情。 onCreate 当Activity创建的时候。 onPause 当Activity退到后台的时候。 onRestart 当Activity从后台进入前台的时候。 onDestroy 当Activity销毁的时候。 有什么作用呢 那我们了解View的这些生命周期方法有什么作用呢？下面我就列举下我们经常遇见的问题。 在Activity中获取View的宽高 你是否也曾经在Activity的onCreate，onResume等方法中获取过View的宽高，是否也同样得到了0的结果。从View的生命周期方法调用我们可以看出，在Activity的onResume方法调用的时候，View还没有完成测量，当然获取到的是0了。我们可以在Activity的onWindowFocusChanged()方法中获取View的宽高。1234567override fun onWindowFocusChanged(hasFocus: Boolean) &#123; super.onWindowFocusChanged(hasFocus) if (hasFocus) &#123; Log.d("Amoryan", "$&#123;customView.width&#125;") Log.d("Amoryan", "$&#123;customView.height&#125;") &#125;&#125; 保存和恢复数据 在Activity的生命周期发生变化的时候，View有可能需要作出相应的相应，比如VideoView需要保存和回复当前进度。12345678override fun onWindowVisibilityChanged(visibility: Int)&#123; super.onWindowVisibilityChanged(visibility) if (visibility == View.VISIBLE)&#123; // Activity Resumed &#125; else &#123; //Activity Paused &#125;&#125; 释放资源 有时候我们需要在View从Window上分离的时候释放一些占用内存的资源，比如Bitmap的回收，线程的释放等。1234override fun onDetachedFromWindow()&#123; super.onDetachedFromWindow() //释放资源&#125; 测量流程 View在做测量的时候，measure()方法会被父控件调用，在measure()方法中调用自身的onMeasure()方法进行实际的测量。 View和ViewGroup的测量是有区别的，View的测量会计算自身的尺寸；但是ViewGroup会先遍历子View的，调用子View的measure()方法，最后再计算自身的尺寸。 ViewGroup的测量 我们打开ViewGroup.java的源码文件，找到measureChildren()。123456789101112protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; //遍历子控件 for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; //如果子控件的Visibility属性不是View.GONE，则进行测量 if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 这个方法做的事情很明确，会遍历子控件，如果子控件的visibility属性不是View.GONE，则调用measureChild()方法。下面我们再来看看measureChild()方法做了什么事情。12345678910111213protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; //获取子控件的LayoutParams final LayoutParams lp = child.getLayoutParams(); //生成子控件width的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); //生成子控件height的MeasureSpec final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); //调用子控件的measure方法进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 从源码可以看出，这个方法做了如下几件事情 1. 会先获取子控件的LayoutParams； 2. 然后根据自身的MeasureSpec，和子控件的LayoutParams计算子控件的MeasureSpec； 3. 最后再调用子控件的measure()方法进行子控件的测量流程。 那么子控件的MeasureSpec是如何生成的呢，下面我们就来看看getChildMeasaureSpec()方法是如何计算的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; //获取ViewGroup的specMode和specSize int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //计算当前能够给予的最大值(父控件给予的值减去ViewGroup的内边距) int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; //根据ViewGroup的MeasureSpec和View的LayoutParams得到View的MeasureSpec case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; //子控件的LayoutParams是具体值 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //子控件的LayoutParams是MATCH_PARENT resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //子控件的LayoutParams是WRAP_CONTENT resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //调用MeasureSpec的makeMeasureSpec方法生成子控件的MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 这个方法的逻辑也十分明了 1. 得到ViewGroup的specMode和specSize； 2. 获取ViewGroup能够给予子View的最大size； 3. 根据ViewGroup的specMode以及子View的LayoutParams得到子View的specMode和specSize； 4. 通过MeasureSpec的makeMeasureSpec()方法生成子View的MeasureSpec。 最后再来看看makeMeasureSpec()方法。1234567public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125; 虽然if-else分支计算的值是一样的，但是我还是好奇的看了看sUseBrokenMakeMeasureSpec这个成员变量。发现在View构造的时候会根据版本修改这个值。1sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1 只是在API17之前使用旧的MeasureSpec计算方式。 View的测量 看完ViewGroup的测量之后，我们再来看看View的onMeasure()方法。1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 来看看getSuggestedMinimumWidth()和getSuggestedMinimumHeight()方法。1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 这个方法只是获取最小的宽度和高度。然后我们来看看getDefaultSize()方法。123456789101112131415161718public static int getDefaultSize(int size, int measureSpec) &#123; //先赋值为最小值 int result = size; //获取specMode和specSize int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); //根据specMode得到最终size，如果MeasureSpec不是UNSPECIFIED，那么最终的size就是ViewGroup能给予的最大size switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 可以看到这个方法会根据specMode得到View最终的size，但但是，AT_MOST表示LayoutParams是WRAP_CONTENT，从源码可以看出，如果设置为WRAP_CONTENT，最终计算的值实际上并不是包裹内容的，而是父控件能够给予的最大值，所所以，这就说明了为什么我们在自定义View的时候需要重写onMeasure方法给出specMode是AT_MOST的时候的实际size的计算方式了。 布局流程 View的布局流程主要是layout()和onLayout()方法，从ViewRootImpl的performLayout()中会调用根View的layout()方法，然后再逐层的遍历，在layout()中传入View的left, top, right, bottom值，并且调用onLayout()进行实际的布局。对于View，因为没有子控件，所以onLayout()什么也不做。12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; layout ViewGroup在onLayout()方法中会调用子View的layout()，告诉子View改如何进行布局。我们先来看看layout()方法做了一些什么事情。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; //先保存之前的left, top, right, bottom int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame()确定View的位置，changed表示View的矩阵是否发生了变化 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //调用onLayout() onLayout(changed, l, t, r, b); //是否需要绘制滚动条 if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; //调用onLayoutChangeListener的方法 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123; mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT; notifyEnterOrExitForAutoFillIfNeeded(true); &#125;&#125; 我们可以看到layout()方法主要做了两件事情 1. 调用setFrame()确定View的四个顶点的位置； 2. 对于ViewGroup，调用onLayout()确定子View的位置。 setFrame12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; //View的矩阵是否发生了变化 if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; int drawn = mPrivateFlags &amp; PFLAG_DRAWN; //View之前的宽高 int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; //父控件传入的宽高 int newWidth = right - left; int newHeight = bottom - top; //尺寸是否发生了变化 boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); invalidate(sizeChanged); //设置View的4个顶点 mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom); mPrivateFlags |= PFLAG_HAS_BOUNDS; //如果View的尺寸发生了变化，则调用sizeChange() if (sizeChanged) &#123; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123; mPrivateFlags |= PFLAG_DRAWN; invalidate(sizeChanged); invalidateParentCaches(); &#125; mPrivateFlags |= drawn; mBackgroundSizeChanged = true; mDefaultFocusHighlightSizeChanged = true; if (mForegroundInfo != null) &#123; mForegroundInfo.mBoundsChanged = true; &#125; notifySubtreeAccessibilityStateChangedIfNeeded(); &#125; return changed;&#125; FrameLayout的onLayout ViewGroup的onLayout()是一个抽象方法，因为不同的ViewGroup有不同的逻辑，这里我们来看看FrameLayout的onLayout()。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); //获取内边距 final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); //遍历子控件 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); //如果子View的visibility属性不是View.GONE if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; //没有设置gravity，则默认为Gravity.LEFT|Gravity.TOP int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; //根据水平Gravity确定子View的left位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL://如果是水平居中 childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT://如果是靠右 if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; //根据垂直Gravity确定View的top位置 switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL://垂直居中 childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; //调用子控件的layout() child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 这个方法实际上做的事情非常简单 1. 它将gravity分为了水平方向和垂直方向； 2. 通过水平方向的gravity计算出子View的left值； 3. 通过垂直方向的gravity计算出View的top值； 4. 最后再调用子View的layout()方法。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令(持续更新)]]></title>
    <url>%2F2018%2F03%2F14%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%2F</url>
    <content type="text"><![CDATA[起因 一直使用的AndroidStudio进行开发，它将git的操作封装的十分简单，以至于我根本就没有细究git命令的作用，这就导致有时候和同事一起开发遇到问题了不知道怎么去解决。 准备工作 首先，我们得安装git，如果不会的，请自行百度或者google； 然后，我们在一个空白的文件夹下面新建一个git仓库，开始我们的git命令学习之旅 git rebase举个栗子 你刚接到一个需求需要开发A功能，然后你在本地切出一个dev_afunc的分支，然后开发了一部分的时候，你将代码commit了几次；这个时候，产品经理过来说有个B功能比较紧急，然后这个时候你需要开发B功能，这个时候你又创建了dev_bfunc的分支，在上面进行开发，开发完了之后验收通过然后发布了。这个时候你又要回过头来开发A功能。 A功能开发中 我们新拉出一个分支，然后做一些修改并提交到当前分支。123$ git checkout -b dev_afunc$ git add .$ git commit -m "开发A功能中" 这个时候git仓库是这个样子的 半路杀出个B 然后这个时候，B功能比较紧急，于是我们将分支切换到了master，然后再拉出一个dev_bfunc分支进行开发B功能，并做一些修改之后提交到当前分支。1234$ git checkout master$ git checkout -b dev_bfunc$ git add .$ git commit -m "开发B功能中" 这个时候git仓库是这个样子的。 B功能开发完了上线 然后我们将开发完的B功能合并到master分支上，进行发布上线。12$ git checkout master$ git merge dev_bfunc 这个时候git仓库是这个样子的。 继续A功能的开发 之后我们需要继续进行A功能的开发，并且要包含有已开发好的B功能。这个时候我们就可以使用rebase命令了。12$ git checkout dev_afunc$ git rebase master 然后我们发现iTerm中出现如下的问题，因为A功能和B功能修改的是同一个地方。 这个时候我们可以打开文件看看里面的内容如下所示。 然后我们通过git branch命令看看目前不在任何一个分支。 这个时候我们将文件的冲突解决掉之后，再继续进行rebase操作。12$ git add .$ git rebase --continue 然后我们在iTerm中可以看到rebase成功了。 最后我们再看看dev_afunc分支中文件的内容是不是真的是都有了。 git rebase图解 实际上git rebase的原理很简单，就是将当前分支的commit创建新的commit拼接到你要rebase的分支commit后面。 git tag 在你阅读电子书的时候，是不是经常性的会在某个地方添加书签，到时候回过头方便查找。其实在git中，tag就像是一个书签，帮你快速的会退到你想要的那个版本。 场景 在我们平常开发过程中，经常会遇到这样的情况，某个版本上线后，运行了一段时间出现了兼容性问题，需要紧急修复这个bug，于是我们需要找到上线的那个版本，然后修改代码，再将修改后的代码和现在开发的代码进行合并，下面我们就来看看tag如何方便和快速的解决这种问题。 准备工作 首先建立一个git仓库和一个远程仓库，并将本地仓库关联到远程仓库。1234$ mkdir gitpractice$ cd gitpractice$ git init$ git remote add origin 远程仓库地址 增加a文件 然后我们增加一个commit，添加一个a文件，并将其提交到远程仓库。1234$ vi a.txt$ git add .$ git commit -m "增加a.txt文件"$ git push origin master 增加tag 比如现在你的功能开发完毕并且测试已经测试完毕了，具备了上线的资格。在我们上线之前，现在最后一次commit上打上tag，方便之后迭代了需要回到这个版本处理bug。 在git中，tag分为两种，一种是轻量级，一种是含附注。 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般情况下我们会使用韩附注的tag。1$ git tag -a v1.0 -m "版本1.0上线" 这样你就创建了一个名为v1.0的tag，附注信息是“版本1.0上线”。那我们怎么查看自己创建的tag呢。12$ git tag$ git tag --list 上面两个命令都可以查看当前的tag。创建完tag之后，远程仓库是没有的，我们需要将其push到远程仓库中。1$ git push origin v1.0 这个时候git仓库是这个样子的。 继续下个版本的开发 版本1.0上线之后，我们开始了版本1.1的开发迭代。我们来模拟提交一些commit。12345678910$ vi b.txt$ git add .$ git commit -m "增加b.txt文件"$ vi c.txt$ git add .$ git commit -m "增加c.txt文件"$ vi a.txt$ git add .$ git commit -m "修改a.txt文件"$ git push origin master 这样我们的1.1版本就正在开发中了，这个时候git仓库是这个样子的。 线上出现紧急bug 在开发1.1的过程中，线上出现了一个紧急bug需要fix重新发包，这个时候我们就需要将之前的代码找出来，然后fix bug之后打包。还记得我们之前的tag v1.0吗，这个时候它就发挥作用了。12$ git checkout -b bugfix v1.0$ git branch 上面的命令是将tag v1.0的代码找出来并新建一个名为bugfix的分支，这样bugfix分支上的代码就是之前打tag的代码了。我们可以看看当前bugfix分支下，文件夹中有什么。 修复bug 我们修改a.txt文件，假装fixbug了。123$ vi a.txt$ git add .$ git commit -m "bugfix" 然后bugfix之后，我们在当前分支上打包发布了。这个时候我们在迭代开发的v1.1版本分支上并没有修改当前的bug，这个时候我们就需要将修改后的代码merge到主分支上。这个时候git仓库是这个样子的。 合并分支 先切回到master分支，然后合并bugfix分支的内容，这样master分支就有了bugfix的内容。因为bugfix修改了a.txt文件的内容，merge的时候肯定会存在冲突。12$ git checkout master$ git merge bugfix 处理冲突 这个时候我们需要处理掉冲突，然后重新commit。1234$ vi a.txt$ git add .$ git commit -m "处理冲突"$ git push origin master 这个时候冲突就被解决了，我们再来来看看master分支上是否已经进行了bugfix，然后我们再将代码push到远程仓库。这个时候git仓库是这个样子的，merge会产生一个新的commit放在master分支后。 重新打入tag 当然我们别忘了在bugfix之后重新打上tag。12345$ git branch$ git checkout bugfix$ git tag -a v1.0bugfix -m "v1.0bugfix"$ git tag --list$ git push origin v1.0bugfix git revert git resetgit cherry-pick 这个命令的作用你可以理解为部分merge，它可以把某个分支上的特定commit合并到当前分支，而不是将某个分支上的所有commit合并过来。 举个栗子 某次新版本发布之后，你们又开始新的迭代，开发了几天发现线上出现了bug，这个时候修复bug准备发包，但是产品说刚做的那个功能非常如果做好了也跟着一起发上去，这个功能比较紧急。这个时候你新版本迭代了很多的commit，不能全部merge到bugfix分支上，这个时候你就得用到cherry-pick了。 开发第一个版本 准备工作啥的就不用多说了。我们先来开发第一个版本的功能。123456$ vim a.txt$ git add .$ git commit -m "增加a.txt文件"$ vim a.txt$ git add .$ git commit -m "修改a.txt文件" 这个时候第一个版本开发完成了，准备发布了。123$ git push origin master$ git tag -a v1.0 -m "v1.0版本发布"$ git push origin v1.0 开发第二个版本 这个时候进入到了紧张的第二个版本开发，产品给了很多的需求，有些是非常急的，所以就先做了。123456$ vim b.txt$ git add .$ git commit -m "增加b.txt文件"$ vim c.txt$ git add .$ git commit -m "增加c.txt文件" 线上出现bug 这个时候线上出现了bug，需要修复，但同时产品说既然要发布，就把某个功能也跟着发上去，这个东西比较急。这个时候我们不能直接将master分支上的commit全部merge到bugfix分支，而只能将增加b文件的commit合并到bugfix分支。12345678910111213//1$ git checkout v1.0 -b bugfix$ vim a.txt$ git add .$ git commit -m "版本1.0bug修复"//2$ git checkout master$ git merge bugfix//3$ git checkout bugfix$ git cherry-pick df1c9a3//4$ git tag -a v1.1 -m "修复1.0bug并增加b功能" 这里做了四步操作 首先将发布版本从tag上checkout出来，然后进行bugfix； bugfix完成之后，将bugfix的东西merge到master上，保证master上的代码也是bugfix的； 切回到bugfix，将b功能的commit cherry-pick，这样bugfix后就多了b功能； 最后发布完功能之后别忘了再打上tag。 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何clone aosp]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%A6%82%E4%BD%95clone-aosp%2F</url>
    <content type="text"><![CDATA[什么是aosp aosp(android open source project)其实就是Android开源项目。 git地址: https://android.googlesource.com/。 clone项目 如果你想要把整个的aosp项目clone下来，建议你买个移动硬盘。本人比较穷，mac只有256G的存储空间，所以这里就只clone framework库的代码做示范，大概有2G左右。 准备工作git 首先你得在电脑上装git，啊，你问我为什么？你不装怎么clone项目(mdzz，谁问你了)。然后配置用户名和邮箱。12$ git config --global user.name "xxx"$ git config --global user.email "xxx@gmail.com" 找仓库地址 配置好你的git之后你需要在google的代码库里面找到framework的仓库地址，大概是下面这样。 开始clone 准备工作做完之后，我们就可以开始clone项目了。1$ git clone https://android.googlesource.com/platform/frameworks/base 一切似乎都在情理之中，然后过了一会，iTerm里面显示如下问题。 这个问题是因为git没法访问到framework的仓库。因为我的vpn是开启的，于是我觉得应该是git的问题，然后在google上搜索了下，git需要设置代理。123$ git config --global http.proxy "http://xxx.xxx.xxx:port"$ git config --global https.proxy "http://xxx.xxx.xxx:port"$ git config --global http.sslVerify false 我用的是蓝灯，在设置－网络－高级－代理里面可以查看代理地址。如下图所示 然后再次运行git clone命令，等待数分钟之后就能看到已经clone好的代码了。 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2018%2F03%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在windows系统中，我们可以发现无论我们如何去开启任务管理器，都只能打开一个窗口，因为每个窗口显示的数据，做的功能都是一样的。我们日常的编码中，经常会遇到这样的情况，某个类希望只存在一个实例，这就需要用到 单例模式了 。 饿汉式 饿汉式单例模式比较简单。1234567891011public class Singleton&#123; private static final Singleton instance = Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 从上面的代码可以看出，在类加载的时候就会创建Singleton的对象。 懒汉式 懒汉式单例模式，就是讲对象的实例化放在使用的时候。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 上面这串代码在单线程里面是能够保证只创建一个对象的。但是放到多线程里面就会出现创建多个对象的情况。所以我们如果要创建一个线程安全的单例，则需要加 synchronized 关键字。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是加上同步之后又出现了另外一个性能问题，如果有很多个线程都在请求这个方法，而且这个方法里面要做很多的初始化操作，就会导致其他线程持续等待等情况，下面不使用方法锁的情况，但是需要加双重校验，因为有可能A线程走完第一层的判断后，CPU执行片给了B线程，然后B线程获取锁创建了对象，如果同步代码块里面不添加一层校验就会导致A线程也会创建对象。123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; holder模式 饿汉式没有办法延时加载，而懒汉式的同步在高并发的情况下又会影响性能。那么有没有另外一种方式能够克服这两者的缺点呢？答案肯定是有的。1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Holder.instance; &#125; private static class Holder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类Holder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 Kotlin下的单例模式饿汉式 kotlin下的饿汉式就有意思了，如下就是一个饿汉式的单例模式。1object Singleton 你没有看错，他就是一个饿汉式，我们通过工具可以看到它对应的java代码如下。1234567891011public final class Singleton &#123; public static final Singleton INSTANCE; private Singleton() &#123; INSTANCE = (Singleton)this; &#125; static &#123; new Singleton(); &#125;&#125; 懒汉式 kotlin里面是没有synchronized关键字的，如果要是用同步方法的形式，则需要使用 @Synchronized 注解。而同步代码块的方式是使用 synchronized() 方法。1234567891011121314151617181920class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null fun getSingleton(): Singleton &#123; if (instance == null) &#123; synchronized(Singleton::class.java) &#123; if (instance == null) &#123; instance = Singleton() &#125; &#125; &#125; return instance!! &#125; &#125;&#125; holder方式 再来看看holder方式如何通过kotlin来实现。123456789101112131415class Singleton private constructor() &#123; companion object &#123; fun getSingleton(): Singleton &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance: Singleton = Singleton() &#125;&#125; 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ViewPager如何一屏多显]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%85%B3%E4%BA%8EViewPager%E5%A6%82%E4%BD%95%E4%B8%80%E5%B1%8F%E5%A4%9A%E6%98%BE%2F</url>
    <content type="text"><![CDATA[前言 最近项目UI图上有个一屏显示多个Pager的控件，想了想直接通过ViewPager来实现。 实现方式 项目地址 getPageWidth 实际上PagerAdapter里面就提供了实现一屏多显的方法12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 这个方法返回的是 每个Pager的宽度 。然而，他的效果并不是我们想要的。来看看下面这段代码的运行效果。123override fun getPageWidth(position: Int): Float &#123; return 0.8f&#125; 它的效果如下所示，可以看到，默认每个pager都是 局左显示 的。 clipChildren 第二种实现方式就是通过控件的 clipChildren 属性，默认这个属性是true，我们需要将其设置为false，表示超出控件的内容范围也要显示出来。12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#bbbbbb" android:clipChildren="false" android:gravity="center" android:orientation="vertical" tools:context="com.yanfangxiong.multipagerdemo.MainActivity"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="180dp" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:clipChildren="false" android:overScrollMode="never"/&gt;&lt;/LinearLayout&gt; 这里将ViewPager和LinearLayout的clipChildren属性都设置为了false。然后在java代码中做如下设置。123456//设置预加载的数量是3，这个值默认是1viewPager.offscreenPageLimit = 3//pageMargin设置页面之间的距离val metrics = DisplayMetrics()windowManager.defaultDisplay.getMetrics(metrics)viewPager.pageMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 8f, metrics).toInt() 效果图如下所示。 扩展 感觉好像有点单调哈。我也是这么觉得的，那么我们来加点有趣的东西吧。ViewPager有个PageTransformer接口。1234567891011public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ void transformPage(View page, float position);&#125; 这里我就不写研究过程了，position的范围可以分为四段(通用的)，是当前page的左上角相对于ViewPager的位置。 position &lt; -1 -1 &lt;= position &lt; 0 0 &lt;= position &lt; 1 position &gt; 1 ScalePageTransformer 于是乎我写了一个切换尺寸变换的类ScalePageTransformer，如下。123456789101112131415class ScalePageTransformer( private var minScale: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val size = when &#123; position &lt; -1 -&gt; minScale position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minScale + (1 - minScale) * (1 + position) position &lt; 1 -&gt; minScale + (1 - minScale) * (1 - position) else -&gt; minScale &#125; page?.scaleY = size &#125;&#125; 效果图如下，这样就比较有趣了，嗯，我是这么认为的。 RotatePageTransformer 旋转跳跃，我闭着眼~1234567891011121314151617181920212223242526272829303132333435class RotatePageTransformer( private var rotateDegree: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; if (page == null) return val tPivotX: Float val degree: Float when &#123; position &lt; -1 -&gt; &#123; tPivotX = page.width.toFloat() degree = -rotateDegree &#125; position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; &#123; tPivotX = page.width.toFloat() degree = rotateDegree * position &#125; position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; &#123; tPivotX = 0f degree = rotateDegree * position &#125; else -&gt; &#123; tPivotX = 0f degree = rotateDegree &#125; &#125; page.apply &#123; pivotX = tPivotX pivotY = if (rotateDegree &lt; 0) 0f else page.height.toFloat() rotation = degree &#125; &#125;&#125; 来看看这个旋转变换的效果图。 AlphaPageTransformer 再来个透明度变化的吧。123456789101112131415class AlphaPageTransformer( private var minAlpha: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val alpha: Float = when &#123; position &lt; -1 -&gt; minAlpha position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minAlpha + (1 - minAlpha) * (1 + position) position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; minAlpha + (1 - minAlpha) * (1 - position) else -&gt; minAlpha &#125; page?.alpha = alpha &#125;&#125; 效果图如下 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-抽象工厂]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 不管是简单工厂还是工厂方法，每个工厂都只生产一种产品，而在现实生活中是会存在一个工厂生产多种商品的情况的。比如电器工厂，会生产电视机，电冰箱，空调等。 工厂方法 接下来我们使用工厂方法来实现上面的案例。 定义产品 现在有两种产品，冰箱和空调，有两个厂商(美的和海尔)都能够生产这两种产品。1234567891011121314151617interface IRefrigerator&#123;&#125;class HaierRefrigerator : IRefrigerator&#123;&#125;class MeidiRefrigerator : IRefrigerator&#123;&#125;interface IAirConditioner&#123;&#125;class HaierAirConditioner : IAirConditioner&#123;&#125;class MeidiAirConditioner : IAirConditioner&#123;&#125; 定义工厂 因为每个工厂只生产对应的产品，所以我们需要定义两个工厂接口。1234567891011121314151617181920212223interface IRefrigeratorFactory&#123; fun generateRefrigeratorImpl() : IRefrigerator&#125;class HaierRefrigeratorFactory : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125;class MeidiRefrigerator : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;interface IAirConditionerFactory&#123; fun generateAirConditionerImpl() : AirConditioner&#125;class HaierAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl() : AirConditioner = HaierAirConditioner()&#125;class MeidiAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl(): AirConditioner = MeidiAirConditioner()&#125; 生产产品 比如现在要生产美的的冰箱和空调。1234fun main(args : Array&lt;String&gt;)&#123; val refrigerator = MeidiRefrigeratorFactory().generateRefrigeratorImpl() val airConditioner = MeidiAirConditionerFactory().generateAirConditionerImpl()&#125; 思考 如果有N个产品需要生产，那么就需要扩展N个工厂。一旦工厂的数量变多，在调用的时候就很容易遗漏某些产品的生产，而且类的数量也会多很多，导致结构越来越复杂。 抽象工厂 像美的冰箱，美的空调是由相同的公司生产的，我们可以将其归为一个产品族，抽象工厂可以理解为一个工厂生产一个产品族的产品。现在我们来简化上面的代码。12345678910111213141516interface IFactory&#123; fun generateAirConditionerImpl() : IAirConditioner fun generateRefrigeratorImpl() : IRefrigerator&#125;class MeidiFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = MeidiAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;class HaierFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = HaierAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125; 生产产品 现在工厂定义好了，我们想要生产美的的产品就可以直接通过一个工厂生产了。12345fun main(args : Array&lt;String&gt;)&#123; val factory : IFactory = MeidiFactory() val airConditioner = factory.generateAirConditionerImpl() val refrigerator = factory.generateRefrigeratorImpl()&#125; 如果某个产品族新增加了某个产品，只需要在抽象工厂中新增加生产该产品的方法就可以了，这样就减少了工厂方法会导致的结构复杂性。 毒鸡汤 日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 在设计模式－简单工厂文章中介绍的简单工厂，我们发现，如果在此基础上新增加一种图表的展示，那么就得修改静态工厂的generateChartImpl()方法。这无疑违反了开放封闭原则。 修改Factory 于是在简单工厂的基础上我定义了一个IChartFactory的接口，如下。12345interface IChartFactory &#123; fun generateChartImpl(): IChart&#125; 拆分Factory 然后将简单工厂的ChartFactory拆分成下面的类，如下。1234567891011121314151617class PieChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = PieChart()&#125;class BarChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = BarChart()&#125;class LinearChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = LinearChart()&#125; 测试 使用起来只需要通过对应的Factory创建对应的IChart对象就可以了。如下1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = PieChartFactory().generateChartImpl() chartImpl.display()&#125; 并且我们还发现，如果需要增加一种图表的显示只需要增加IChart的子类和对应的IChartFactory的子类就可以了，而不需要去修改已有的代码，这样就不会违反开闭原则了，而且具有一定的扩展性。 总结 从上面的代码中我们看出，虽然工厂方法能够有很好的扩展性，但是缺点也显而易见，它会导致类的数量越来越多，这样反而会增加系统的复杂度。 毒鸡汤 日子还长，请别失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于京东open-api-sdk的那些坑]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8E%E4%BA%AC%E4%B8%9Copen-api-sdk%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言 近来有位朋友让我用java测试下京东的open-api-sdk的调用，对此记录下在测试过程中遇到的那些坑。 ClassNotFound 于是乎我将sdk下载下来集成到项目中，然后按照文档上的内容编写了下面的代码。12345678910111213141516171819202122WareWriteUpdateWareRequest request = new WareWriteUpdateWareRequest();Ware ware = new Ware();ware.setWareId(/*wareId*/);ware.setTitle(/*title*/);ware.setTransportId(/*transportId*/);request.setWare(ware);JdClient client = new DefaultJdClient( "serverUrl", "accessToken", "appKey", "appSecret");try &#123; WareWriteUpdateWareResponse execute = client.execute(request); if (execute.getSuccess()) &#123; System.out.println("请求成功:" + execute.getMsg()); &#125; else &#123; System.out.println("请求失败:" + execute.getMsg()); &#125;&#125; catch (JdException e) &#123; e.printStackTrace();&#125; 似乎是没有毛病的，然后我运行了代码，得到了下面的结果！你没有看错，wtf，找不到类，什么鬼哦。 NoSuchMethod 然后朋友给我发了一篇博客，按照里面的配置，我修改了项目配置为maven项目，然后添加了如下的依赖。1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt; 本以为这样就没有问题了。但是事不如己愿，哈哈，又出现了下面的问题。 解决 看到这个异常我的第一反应就是open-api-sdk中调用的jar包的版本一定比我配置的要高，于是我在mavenrepository里面搜索了最新的jackson-core-asl和jackson-mapper-asl的jar最新版本，并且修改了pom.xml中的version信息。如下所示：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 然后，我再次运行了代码，得到以下结果。 吐槽 说实话，第一次见到sdk里面使用了三方的jar，但是又不在文档里面说明的，也是服气~ 毒鸡汤 日子还长，别太失望～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>sdk对接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂]]></title>
    <url>%2F2018%2F02%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 之前写代码从来都没有注重设计模式这一块，熟知的并且用的最多的就是单例模式，但是并没有什么卵用，现在项目越来越庞大，每次迭代都要改一堆东西，印象中重复的代码也越来越多，有时候迭代一个版本要改N多个地方的相同代码，如果哪个地方忘了就很蛋疼，但是让我去重构又不知道从何处下手，最近打算将设计模式的东西系统的学习一下，然后将自己写的代码好好的梳理一下。 举个栗子 现在产品经理需要一个图表展示的功能，包括折线图，饼图和柱状图等。于是我写了一个IChart的接口，只有一个display()方法。12345interface IChart &#123; fun display() &#125; 然后编写了几个IChart的子类，如下。1234567891011121314151617181920212223class PieChart : IChart &#123; override fun display() &#123; println("显示饼状图") &#125;&#125;class BarChart : IChart &#123; override fun display() &#123; println("显示柱状图") &#125;&#125;class LinearChart : IChart &#123; override fun display() &#123; println("显示折线图") &#125;&#125; 就这样写好了图表的相关类。然后就是如何根据不同的类型产生不同的类的对象。1234567891011class ChartFactory &#123; fun generateChartImpl(type: String): IChart &#123; return when (type) &#123; "bar" -&gt; BarChart() "linear" -&gt; LinearChart() else -&gt; PieChart() &#125; &#125;&#125; 最后我们来测试一下就可以了。1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = ChartFactory.generateChartImpl("linear") chartImpl.display()&#125; 运行结果如下所示，这就是简单的工厂模式。 毒鸡汤 日子还长，请别失望～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac插入U盘的只读问题]]></title>
    <url>%2F2018%2F02%2F21%2Fmac%E6%8F%92%E5%85%A5U%E7%9B%98%E7%9A%84%E5%8F%AA%E8%AF%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 最近帮我舅舅重装系统，因为要将我电脑上的系统镜像复制到U盘中， 然后发现我只能读取U盘里面的文件，而不能进行写入操作。 U盘文件系统格式 想要解决这个问题，首先你得了解U盘的文件系统格式。于是我将U盘插在windows电脑上进行格式化的时候，发现格式化的种类有3种，NTFS ， FAT32 ， exFAT 。那么我们来看看这几种格式的区别。 这里推荐一款免费的软件 Mounty11 。它支持在mac读写NTFS文件系统格式的U盘。 NTFS 它全称New Technology File System(新技术文件系统)。支持LZ77压缩、文件级加密、访问控制。主文件表(MFT)负责存储稳健的属性、位置、访问信息。这种格式在mac如果不使用工具是无法写入文件的，当然它还有一些弊端，比如最大分区，最大文件只支持2TB，（日常够用了）兼容范围不如FAT32，长时间使用会影响U盘寿命。所以这种文件系统格式肯定不是我们要的。 FAT32 它是1997年的Windows 95 OSR2，在第二版系统中首次引入的文件系统格式。 它有很好的兼容性，几乎所有主流系统都能对其格式写入读取 。既然有这么好的兼容性，那我们是不是就直接将U盘格式化为FAT32就可以了。当然不是，这种文件系统虽然有很好的兼容性，却有很多的弊端。 这种文件格式安全无保障，对于单个的文件移动，体积不能超过4G，并且文件名称长度不能超过255个字节 ，所以这不是最好的选择。 exFAT 微软专门为闪存设备设计的文件系统，高容量的SDXC卡默认都是这种格式。文件名最高可达65536个，分区和单个文件支持最大可达到16EB，写读取速度稳定。最主要的是它在mac和windows之间都可以进行读写操作。 解决 最终我并没有选择使用第三方工具在mac进行读写NTFS的U盘，而是将U盘格式化为exFAT的格式，然后再将文件拖放到U盘中，再制作启动盘。 总结 如果只是简单的拖放小文件，你完全可以选择使用FAT32文件系统格式，如果需要拖放大文件则可以考虑使用NTFS或者exFAT，当然不建议使用NTFS，因为它对U盘的使用寿命有影响。 毒鸡汤 日子还长，请别失望~ 祝大家新年快乐]]></content>
      <categories>
        <category>奇葩</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于迅雷下载BT出现的版权方问题]]></title>
    <url>%2F2018%2F02%2F13%2F%E5%85%B3%E4%BA%8E%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BDBT%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%88%E6%9D%83%E6%96%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 2月11号的动车从杭州回家，于是我为了打发在车上的5个多小时时间，2月10号的晚上准备下载一些电影在动车上看。当然是以前看过了的电影，哈哈。于是在google上搜索了速度与激情8和机器之血的BT文件，正当我准备通过迅雷下载这些文件的时候，发现任务的右下角显示 应版权方要求，该资源无法下载 。 WTF！！！ 原因 这个原因是版权方和迅雷交涉后，迅雷通过技术阻止了文件的下载。看到这里忍不住爆了一句粗口，mmp。 解决方案 作为一个程序猿怎么能够被这种问题影响而不看电影，是吧。于是我上google搜索了一些解决方案，找到了一个比较好的方法。 准备工作 首先你得有一个 百度网盘账号 ，因为接下来我们准备通过百度网盘来进行下载这些文件。 获取BT文件的下载地址 获取这个地址的方式比较简单，你只需要在迅雷的下载任务列表选择一个无法下载的文件，然后右键 复制文件下载链接 就可以了。 建立离线下载任务 然后，你就可以登录百度网盘，新建离线下载任务。如下图所示。 然后选择新建链接任务，将在迅雷上复制的链接粘贴上去，建立任务就可以了。 通过百度云盘app进行文件下载 最后你只需要通过百度云盘的app进行文件下载就可以了。 毒鸡汤 日子还长，请别失望~]]></content>
      <categories>
        <category>奇葩</category>
      </categories>
      <tags>
        <tag>BT下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android support annotation]]></title>
    <url>%2F2018%2F01%2F30%2Fandroid-support-annotation%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Architecture Components]]></title>
    <url>%2F2018%2F01%2F30%2FAndroid-Architecture-Components%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Kotlin遇上Parcelable]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%BD%93Kotlin%E9%81%87%E4%B8%8AParcelable%2F</url>
    <content type="text"><![CDATA[由来 因为现在项目里面都是用 kotlin 在编写项目，在跨界面传递数据的时候经常需要传递对象数据，这就需要使用到 对象的序列化 ，就难免和 Parcelable 打交道。 序列化的方式 在Android中，对象的序列化方式是有两种的，一种是Java中的 Serializable ，一种是Android特有的 Parcelable 。既然Google新增加了一种 Parcelable 的方式，那必然有它的道理，我们先来看看两者有啥不可告人的秘密。 Serializable的序列化方式 这种序列化方式给我们的第一印象就是 简洁 。因为你只需要实现 Serializable 接口就可以了。这是一个标识接口，你不需要实现任何方法，Java就会对其进行序列化操作。但但但是，这种序列化的方式使用了 反射，而且在序列化过程中产生很多的临时对象，造成过多的内存消耗 。1234567891011package com.yanfangxiong.kotlinparcelabledemoimport java.io.Serializable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Serializable Parcelable的序列化方式 这种序列化方式是Android所特有的。而且使用起来 比较复杂 ，我们先来举个栗子。12345678910111213141516171819202122232425262728293031323334353637package com.yanfangxiong.kotlinparcelabledemoimport android.os.Parcelimport android.os.Parcelable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Parcelable &#123; companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(parcel: Parcel, flags: Int) &#123; parcel.writeString(name) parcel.writeString(sex) &#125; override fun describeContents(): Int &#123; return 0 &#125;&#125; 详解Parcelable writeToParcel() 通过这个方法你可以将对象的属性都写入到parcel中； describeContents() 这个方法一般情况下默认就好了。关于这个方法，API中是这么描述的，它表示这个Parcelable对象序列化内容的类别。举个栗子，如果你要序列化对象里面包含文件描述符，那么你需要将这个方法修改为返回 CONTENTS_FILE_DESCRIPTOR ； 编写一个类CREATOR继承自 Parcelable.Cretor ，这个接口包含两个方法，createFromParcel()从Parcel容器中值，newArray()这个方法是 供外部类反序列化本类数组使用的 。 从上面的代码我们就可以看出，如何序列化这个对象已经非常清楚的表现出来，根本不需要通过反射来知道来推断类型，所以能够更加高效的序列化对象。 区别与抉择 Serializable实现方式简单，但是比较消耗内存，一般建议在序列化对象保存到文件中的时候使用； Parcelable实现方式较为复杂，但是效率高，消耗内存小，在代码中建议使用这种方式。 问题所在 我们知道，在kotlin中伴生对象只能存在一个 ，一般一些在java中的静态常量我们可能会定义在伴生对象中，但是我们可以看上面的Person的Parcelable实现，系统默认给我们创建的CREATOR对象就直接指定为了伴生对象，这样虽然是没有问题的，但是你定义的一些常量就是属于CREATOR对象了，实际上这是不必要的，所以我们需要一种方式将伴生对象 “释放” 出来。 这里我们就直接上代码了。只需要使用 ＠JVMField 注解就可以解决这个问题。12345678910111213141516companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = object : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 但但但是，前面说了，使用Parcelable的序列化方式，类里面的方法会增加很多，所以我们打算来优化优化。 首先，kotlin像java 8一样，接口中的方法可以有默认的实现 ，于是我决定写一个KParcelable的接口，如下12345interface KParcelable : Parcelable &#123; override fun describeContents() = 0 override fun writeToParcel(dest: Parcel, flags: Int)&#125; 这样就减少了对象中的 describeContents 方法的实现。然后我们再来优化CREATOR的实现方式。对此我写了下面的函数123456inline fun &lt;reified T&gt; parcelableCreator(crossinline creator: (Parcel) -&gt; T) = object : Parcelable.Creator&lt;T&gt; &#123; override fun createFromParcel(source: Parcel): T = creator(source) override fun newArray(size: Int): Array&lt;T?&gt; = arrayOfNulls(size) &#125; 它接受一个名为 creator 的方法，然后返回一个 Parcelable.Creator 的实现类，这样我的Person类就可以简化为如下的方式。12345678910111213141516171819202122data class Person( var name: String?, var sex: String?) : KParcelable &#123; companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = parcelableCreator(::Person) &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(dest: Parcel, flags: Int) = with(dest) &#123; writeString(name) writeString(sex) &#125;&#125; 这样看着就舒服多了，哈哈哈。 毒鸡汤 生活不如意时是上帝给你放的长假～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>Parcelable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装Recycler适配器]]></title>
    <url>%2F2018%2F01%2F23%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85Recycler%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 前段时间就说要用kotlin写RecyclerView的适配器，但一直在忙于项目的迭代，所以就没抽出时间来落地。其实也不算封装，只是简化了开发的过程而已。 直奔主题 这里我就不废话了，直接上代码吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author fxYan */abstract class CommonRecyclerAdapter&lt;T&gt;( val context: Context, @LayoutRes val resId: Int, val data: List&lt;T&gt;) : RecyclerView.Adapter&lt;CommonRecyclerAdapter.ViewHolder&gt;() &#123; private var onItemClickListener: OnItemClickListener&lt;T&gt;? = null fun setOnItemClickListener(listener: OnItemClickListener&lt;T&gt;) &#123; onItemClickListener = listener &#125; fun setOnItemClickListener(action: (Int, T) -&gt; Unit) &#123; onItemClickListener = object : CommonRecyclerAdapter.OnItemClickListener&lt;T&gt; &#123; override fun onItemClick(position: Int, data: T) &#123; action(position, data) &#125; &#125; &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; onItemClickListener?.apply &#123; holder.itemView.setOnClickListener &#123; onItemClick(position, data[position]) &#125; &#125; bindData(holder.itemView, position, data[position]) &#125; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder = ViewHolder(LayoutInflater.from(context).inflate(resId, parent, false)) override fun getItemCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T) class ViewHolder(view: View) : RecyclerView.ViewHolder(view) interface OnItemClickListener&lt;in T&gt; &#123; fun onItemClick(position: Int, data: T) &#125;&#125; LayoutRes是什么 这个注解是 android support annotation 库中的一个注解，表示这里resId是一个布局文件的id，如果你在调用的时候不是传递的布局文件的id，编译的时候就可以检测出来，很方便，有时间会写一篇关于 android support annotation 的文章。 使用 使用起来也是比较简单，只需要实现bindData()方法就可以了。1234567891011121314151617/** * @author fxYan */class CreditExtensionRecordListAdapter( context: Context, resId: Int, data: List&lt;OrderListRespBean&gt;) : CommonRecyclerAdapter&lt;OrderListRespBean&gt;(context, resId, data) &#123; override fun bindData(view: View, position: Int, data: OrderListRespBean) &#123; view.orderTimeTv.text = data.gmtCreate view.prodPicIv.setImageURI(Uri.parse(data.prodPic ?: ""), null) view.prodNameTv.text = data.prodName &#125;&#125; 毒鸡汤 生活不止眼前的枸杞，还有远方的西洋参。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera的使用]]></title>
    <url>%2F2018%2F01%2F10%2FCamera%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介 Android的framework支持通过android.hardware.camera2API或者是过时的Camera来拍摄图片和视频。这篇文章讲解的是Camera的使用，后续会写一篇关于camera2使用的文章。当然，如果你等不及的话可以去看看google博客关于camera2的文章，camera2文章地址，请翻墙查看。 基础 android.hardware.camera2，这个包是控制设备相机的主要API，它可以被用来拍摄图片或者视频当你想构建一个相机app的时候； Camera，这个类也是用来控制设备相机的，但是在API21之后过时了； SurfaceView，这个类用来给用户呈现相机的预览； MediaRecorder，这个类通过相机来录制视频； Intent，如果你的目的仅仅只是简单的拍摄一张图片或者一段视频，你完全可以调用系统的相机让它来完成这些事情，而不需要直接操控系统相机。你可以使用MediaStore.ACTION_IMAGE_CAPTURE来调用系统相机来拍摄图片，或者通过MediaStore.ACTION_VIDEO_CAPTURE来调用系统相机来拍摄视频。 Manifest声明 当你使用Camera API进行开发的时候，你必须确保你的manifest文件中声明了相关的东西。 Camera Permission，当app需要使用设备相机的时候必须声明这个权限 1&lt;uses-permission android:name="android.permission.CAMERA" /&gt; Camera Features，同时得声明使用相机相关的特性，比如。关于camera features的列表，可以查看Features Reference。添加camera features到manifest文件中会导致Google Play防止你的应用安装在那些没有相机或者是不支持相机特性的设备上。如果你的app并不是一定需要camera，你可以在manifest中通过 android:required 来指定。 1&lt;uses-permission android:name="android.hardware.camera" android:required="false" /&gt; Storage Permission，如果应用程序需要将图片或者视频保存到external storage中，还需要声明这个权限； 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; Audio Recording Permission，视频录制的过程中还需要录制音频，所以得添加音频录制的权限，音频录制在之前的文章中已经讲过，不懂的可以去 Android录制系列之音频录制进行查阅； 1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; Location Permission，如果app需要给图片打上GPS定位信息的tag，你需要申请 ACCESS_FINE_LOCATION 权限，这里需要注意，Android5.0及以上版本需要声明使用设备的GPS； 123&lt;uses-permission android:name ="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;!-- targetSdkVersion &gt;= 21 的需要添加 --&gt;&lt;uses-feature android:name="android.hardware.location.gps" /&gt; 如何使用访问相机 检索并访问相机，如果你的app没有在manifest文件中声明是否只能安装在有相机的设备上，那么在使用之前，请检测设备是否有相机的硬件支持。1fun hasFeatureCamera(context: Context) = context.packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) Android2.3 之后你可以直接通过 Camera.getNumberOfCameras() 方法直接获取到设备上可用的相机数量。如果你非常清楚你app运行在有相机支持的设备上运行时，你可以直接通过 Camera.open() 方法去请求并获取一个Camera的实例，它会 访问设备上的第一个后置摄像头。12345678910fun getCamera(): Camera? &#123; var camera: Camera? = null try &#123; camera = Camera.open() &#125; catch (e: Exception) &#123; //如果不捕获异常，相机在被其他的app使用，或者设备上根本没有相机的时候，就会导致app crash Log.d("Amoryan", "open camera error!") &#125; return camera&#125; Android 2.3 之后你可以通过 Camera.open(int) 访问指定的相机。比如，你可以这么玩。123456789101112131415fun getCameraInfo() &#123; try &#123; for (i in 0 until Camera.getNumberOfCameras()) &#123; val cameraInfo: Camera.CameraInfo = Camera.CameraInfo() Camera.getCameraInfo(i, cameraInfo) if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; Log.d("Amoryan", "$i is back facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; else &#123; Log.d("Amoryan", "$i is front facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125;&#125; 设置预览 设置预览界面，你可以直接使用SurfaceView，或写一个SurfaceView的子类，然后实现SurfaceHolder.Callback的相关回调，这里我为了方便起见，直接在布局文件中使用SurfaceView了12345678&lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; 然后实现相对应的回调接口12345678910111213141516171819class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125; 拍摄图片 通过 takePicture 方法拍摄图片，这里只是简单的将拍摄的图片显示在ImageView上了。1234567891011captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125;private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125;&#125; 释放Camera Camera是设备上的共享资源，当app获取到Camera的实例后就可以使用它，但是在app不需要Camera或者当界面变得不可见的时候应该正确的释放。举个栗子，当界面变得不可见的时候，如果你没有正确的释放掉资源，就会导致接下来想要访问Camera的app获取失败，而没办法正常工作。12345override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null&#125; 完整代码 github项目地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.yanfangxiong.camerademoimport android.Manifestimport android.content.pm.PackageManagerimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.hardware.Cameraimport android.os.Bundleimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.view.SurfaceHolderimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; companion object &#123; val REQUEST_CAMERA_PERMISSION = 1 &#125; private var camera: Camera? = null private var bitmap: Bitmap? = null private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125; &#125; private fun checkCameraPermission() &#123; val cameraPermissionStatus = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) if (cameraPermissionStatus == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; &#125; private fun openCamera() &#123; camera = safeOpenCamera() setupCamera() &#125; private fun setupCamera() &#123; camera?.apply &#123; setDisplayOrientation(90) setPreviewDisplay(surfaceView.holder) safeStartPreview() &#125; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; if (camera == null) &#123; checkCameraPermission() &#125; else &#123; setupCamera() &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; camera?.safeStopPreview() setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null &#125; private fun releaseBitmap() &#123; bitmap?.recycle() bitmap = null &#125;&#125; 毒鸡汤 人生不如意的时候是上帝给的长假。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之视频录制]]></title>
    <url>%2F2018%2F01%2F09%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 视频录制使用的是 Camera 和前面讲过的 MediaRecorder。在视频录制的过程中你需要通过 Camera.unlock() 和 Camera.lock() 方法来允许MediaRecorder来访问硬件相机。和使用 Camera 拍摄图片不一样，拍摄视频有 严格的调用顺序。 如何使用 接下来我们就来看看该怎么玩这个玩意。 获取Camera 首先我们得获取到 Camera 。获取相机的方式这里就不在过多的说明了，如果你还是不知道可以去查看我的另外一个文章 Camera的使用。 设置预览界面 这里使用的是SurfaceView，你也可以去查看Camera的使用这篇文章。1234567891011121314151617181920212223242526override fun onCreate(savedInstanceState: Bundle?) &#123; //... surfaceView.holder.addCallback(this) //...&#125;override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera()&#125;override fun surfaceDestroyed(holder: SurfaceHolder?) &#123;&#125;override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission()&#125; 开始录制 相机的准备工作做好之后就可以开始录制了。 通过 Camera.unlock() 允许MediaRecorder访问Camera； 通过 MediaRecorder.setCamera() 将MediaRecorder和Camera关联； 设置音频源，通过 MediaRecorder.setAudioSource() 设置音频源为 MediaRecorder.AudioSource.CAMCORDER； 设置视频源，通过 MediaRecorder.setVideoSource() 设置视频源为 MediaRecorder.VideoSource.CAMERA； 设置输出格式和编码方式，不过在 Android2.2 之后你就可以通过 MediaRecorder.setProfile() 方法来设置一个录制视频的配置； 通过 MediaRecorder.setOutputFile() 设置录制视频后保存的文件路径； 通过 MediaRecorder.setPreviewDisplay() 设置预览界面是SurfaceView； 经过以上的配置之后MediaRecorder就已经准备完成，之后你就可以调用 MediaRecorder.prepare() 表示你已经准备完成了； 通过 MediaRecorder.start() 开始录制； 停止录制 当你录制完成之后，也需要正确的释放资源。 通过 MediaRecorder.stop() 停止当前的录制； 通过 MediaRecorder.reset() 重置当前的MediaRecorder配置，以便之后其他app的使用； 通过 MediaRecorder.release() 将MediaRecorder释放； 通过 Camera.lock() 将相机资源锁住，方便其他的app进行使用； 通过 Camera.stopPreview() 停止相机的预览； 通过 Camera.release() 释放相机的资源，方便其他的app进行使用。 小技巧 如果你使用Camera来录制视频，你可以通过 setRecordingHint() 在开启预览前设置为true，这个方法能够减少开始录制的时间。 项目地址 github项目地址 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package com.yanfangxiong.mediarecorderdemoimport android.Manifestimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.hardware.Cameraimport android.media.CamcorderProfileimport android.media.MediaRecorderimport android.os.Bundleimport android.os.Environmentimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.util.Logimport android.view.SurfaceHolderimport android.view.Viewimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_video_recorder.*import java.io.File/** * @author fxYan */class VideoRecorderActivity : AppCompatActivity(), View.OnClickListener, SurfaceHolder.Callback &#123; companion object &#123; const val REQUEST_CAMERA_PERMISSION = 1 const val REQUEST_RECORD_AUDIO_PERMISSION = 2 fun jumpToActivity(context: Context) &#123; val intent = Intent(context, VideoRecorderActivity::class.java) val queryIntentActivities = context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY) if (queryIntentActivities != null &amp;&amp; queryIntentActivities.isNotEmpty()) &#123; context.startActivity(intent) &#125; &#125; &#125; private var camera: Camera? = null private var mediaRecorder: MediaRecorder? = null private var isRecording = false override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_video_recorder) surfaceView.holder.addCallback(this) controlIv.setOnClickListener(this) &#125; override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.controlIv -&gt; &#123; if (camera == null) &#123; return &#125; if (isRecording) &#123; //如果在录制中 try &#123; mediaRecorder?.stop() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop media recorder error!") &#125; releaseMediaRecorder() &#125; else &#123; //开启录制 checkRecordAudioPermission() &#125; &#125; &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission() &#125; private fun checkCameraPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -&gt; &#123; openCamera() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; &#125; private fun checkRecordAudioPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -&gt; &#123; startRecord() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION) &#125; &#125; &#125; private fun openCamera() &#123; try &#123; camera = Camera.open() setupCamera() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125; &#125; private fun setupCamera() &#123; try &#123; camera?.apply &#123; parameters.focusMode = Camera.Parameters.FOCUS_MODE_AUTO setPreviewDisplay(surfaceView.holder) setDisplayOrientation(90) startPreview() autoFocus(null) &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "set up camera error!") releaseCamera() &#125; &#125; private fun releaseCamera() &#123; try &#123; camera?.stopPreview() camera?.release() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release camera error!") &#125; camera = null &#125; private fun startRecord() &#123; try &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; reset() camera?.unlock() setCamera(camera) setAudioSource(MediaRecorder.AudioSource.CAMCORDER) setVideoSource(MediaRecorder.VideoSource.CAMERA) setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_1080P)) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "videoRecorder.mp4") setOutputFile(file.absolutePath) setPreviewDisplay(surfaceView.holder.surface) prepare() start() isRecording = true Toast.makeText(this@VideoRecorderActivity, "开启录制...", Toast.LENGTH_SHORT).show() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "mediaRecorder error!") releaseMediaRecorder() &#125; &#125; private fun releaseMediaRecorder() &#123; try &#123; mediaRecorder?.apply &#123; reset() release() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release media recorder error!") &#125; camera?.lock() mediaRecorder = null isRecording = false &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecord() &#125; &#125; override fun onPause() &#123; super.onPause() releaseMediaRecorder() releaseCamera() &#125;&#125; 毒鸡汤 走过一些弯路，也好过原地踏步～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之音频录制]]></title>
    <url>%2F2018%2F01%2F06%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介 Android的多媒体框架包含并支持录制和解码多种多样的音视频格式。如果设备支持，你可以使用MediaRecorder来进行这些操作。( Android模拟器无法录制音频 ) MediaRecorder的使用权限 如果你想进行音频录制，你必须添加RECORDER_AUDIO的权限，这是一个 危险权限 ，如果你不知道如何请求权限，你可以查看之前的一篇文章 Android运行时权限的处理。1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; 配置MediaRecorder 配置一个MediaRecorder你只需要简单的几步就可以了。 首先，我们得创建一个 MediaRecorder 的实例对象； 1val mediaRecorder = MediaRecorder() 通过 setAudioSource() 方法设置音频源，音频源的取值你可以直接查看 MediaRecorder.AudioSource，一般情况下我们会选择 MIC 也就是麦克风作为音频源； 1mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC) 通过 setOutputFormat() 方法设置输出格式，输出格式的取值你可以直接查看 MediaRecorder.OutputFormat； 1mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) 通过 setAudioEncoder() 方法设置音频解码方式，解码方式的取值你可以直接查看 MediaRecorder.AudioEncoder 1mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC) 通过 setOutputFile() 方法设置保存文件的路径， 12val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "audioRecorder.3gp")mediaRecorder.setOutputFile(file.absolutePath) 完成初始化配置后，你就可以调用 prepare()方法 ；然后调用 start() 你就可以开始录制了。 12mediaRecorder.prepare()mediaRecorder.start() 值得注意的 大部分(包括DEFAULT)的音频源 都会对音频信号做处理 ，如果你想录制原始的音频，你可以选择MediaRecorder.AudioSource.UNPROCESSED(当然你也可以选择AudioRecorder这个更接近底层的类，后面会找时间写一篇关于AudioRecorder录制的文章)。 有些设备是不支持录制未处理的音频，你可以通过下面的这种方式来获取设备是否支持录制原始音频。1234567val audioManager: AudioManager? = getSystemService(Context.AUDIO_SERVICE) as? AudioManagervar isSupportedRawAudioInput = "false"audioManager?.apply &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; isSupportedRawAudioInput = getProperty("android.media.property.SUPPORT_AUDIO_SOURCE_UNPROCESSED") &#125;&#125; 嗯~what，我相信你也发现了，这个方法是 API 17 才出现的。目前公司项目的最低支持是16，所以得找一种方式在 API 16 上也能够获取到这个属性。结合之前的一些经验，我最初的想法是先看看API16的AudioManager的源码，希望这个方法是本身存在的，只是被隐藏了，这样我就可以直接通过反射的方式去调用，但是事实不是如此，在API16中，AudioManager确实是没有getProperty()方法 ；于是，本着学习的态度，我翻看了更高版本的AudioManager的源码，发现它的调用链是这个样子的。123if (PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED.equals(key)) &#123; return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportAudioSourceUnprocessed));&#125; 仿佛抓到一颗救命稻草，于是我想我直接在代码里面获取这个属性不就好了，这里给你萌看一张图吧，上面代码是这个样子的，找不到com.android.interal.R。 然后，我去google上搜索了关于如何引用这个资源文件，首先，通过反射是肯定可以获取到的，但是google会有一个警告告诉你 通过反射的方式访问内部APIs可能会在某些设备上不支持 ，所以还是用下面这个安全的方式吧。1resources.getBoolean(Resources.getSystem().getIdentifier("config_supportAudioSourceUnprocessed", "bool", "android")) 嗯哼，高兴的太早了，于是乎我就开启了API16的模拟器运行了起来，当走到这一行代码的时候，就出现了下面的结果，好吧，这个属性的判断似乎只能是API17才能用，所以还是用官方推荐的那种方式吧。 如果不支持的情况下，你可以尝试使用 MediaRecorder.AudioSource.VOICE_RECOGNITION 。它不使用AGC(Auto Gain Control，自动增益控制，当信号源较强的时候，使其增益自动降低；当信号源较弱的时候，使其增益自动增高)，并且不会做降噪处理。当然，即使设备不支持UNPROCESSED，你仍旧可以设置为这个，只是这样你就不知道音频信号有没有被处理了。 MediaRecorder的状态 这里直接使用官方的状态图了，如下 事件监听 MediaRecorder提供了两个监听事件的接口，一个是MediaRecorder.OnInfoListener，另一个是MediaRecorder.OnErrorListener。 OnInfoListener 可以用来监听MediaRecorder的一些状态，比如最大录制事件到了等等。12345678910111213141516mediaRecorder.setOnInfoListener&#123; _,what,_-&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED-&gt;&#123; //这个枚举值对应mediaRecorder.setMaxDuration()，当设置的最大录制时间到了后，会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING-&gt;&#123; //这个枚举值对应setMaxFileSize()，当录制文件大小快接近最大值的时候会回调这个，这个是API26新增 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED-&gt;&#123; //当录制文件大小达到最大文件大小的时候会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED-&gt;&#123; //这个方法对应的是setNextOutputFile()，当录制视频超过指定大小后保存到next文件中的时候就会回调这个值，这个是API26新增 &#125; &#125;&#125; OnErrorListener 监听Error信息，12345678mediaRecorder.setOnErrorListener&#123;_, what, _ -&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN-&gt;&#123; &#125; MediaRecorder.MEDIA_ERROR_SERVER_DIED-&gt;&#123; &#125; &#125;&#125; 举个栗子 布局文件就不细说了，只有一个录制按钮和一个停止按钮。我们来看看Activity中核心的的代码。 请求权限123456789101112131415161718192021222324252627282930override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.startRecorderTv -&gt; checkRecordAudioPermission() R.id.stopRecorderTv -&gt; stopRecorder() &#125;&#125;private fun checkRecordAudioPermission() &#123; val hasRecordAudioPermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) when &#123; hasRecordAudioPermission == PackageManager.PERMISSION_GRANTED -&gt; startRecorder() ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.RECORD_AUDIO) -&gt; AlertDialog.Builder(this) .setCancelable(false) .setMessage("请求音频录制权限，否则无法录制音频") .setNegativeButton("取消") &#123; _, _ -&gt; &#125; .setPositiveButton("确定") &#123; _, _ -&gt; requestRecordAudioPermission() &#125; .show() else -&gt; requestRecordAudioPermission() &#125;&#125;private fun requestRecordAudioPermission() &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION)&#125;override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecorder() &#125;&#125; 开始录制123456789101112131415161718private fun startRecorder() &#123; if (!isRecording) &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; setAudioSource(MediaRecorder.AudioSource.MIC) setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) setAudioEncoder(MediaRecorder.AudioEncoder.AAC) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), AUDIO_RECORDER_FILE_NAME) setOutputFile(file.absolutePath) try &#123; prepare() &#125; catch (e: Exception) &#123; &#125; start() isRecording = true &#125; &#125;&#125; 停止录制12345678910private fun stopRecorder() &#123; if (isRecording) &#123; mediaRecorder?.apply&#123; stop() release() &#125; isRecording = false mediaRecorder = null &#125;&#125; 项目地址github地址 官方文档 官网的Guide也是给出了MediaRecorder的详细使用，以及在 API 26 中新增的 MediaMuxer to record multiple channels 。 毒鸡汤 将来的你一定会感谢现在拼命的自己～]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择列表请对CheckBox说No]]></title>
    <url>%2F2018%2F01%2F05%2F%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E8%AF%B7%E5%AF%B9CheckBox%E8%AF%B4No%2F</url>
    <content type="text"><![CDATA[由来 我记得刚学习Android的时候，有个需求是这个样子的，做一个单选或者多选的选择列表。然后那个时候懂得不是很多，就用CheckBox去做。做来做去，发现很多的坑，比如控件会被重用，导致选中的状态也被重用了。后来随着自己接触的东西变多，想到用另外一种方式来实现选择列表，但是这并不是我写这篇文章的原因。主要原因是最近在看同事写的代码(我们是两个人在开发)的时候，发现选择列表还是用的CheckBox，我觉得有必要分享下自己的实现方式，当然如果你们有什么好的建议记得及时告诉我。 实现方式 接下来我就说一下我是如何实现选择列表的(欢迎大家来吐槽)。先来一张效果图，比较简单。github项目地址 level-list 官方文档的介绍请戳这里。它可以通过一些值来管理一系列的图片，然后通过level属性修改这些值后就会显示对应的图片。 举个栗子 因为是选择列表，那必然会有两张图片，一张是未选中的，我们记为ic_select_off，一张是选中的，我们记为ic_select_on。然后我们可以在drawable文件夹下新建一个level_list_common_select.xml的资源文件。具体代码如下123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_select_off" android:maxLevel="0"/&gt; &lt;item android:drawable="@mipmap/ic_select_on" android:maxLevel="1"/&gt;&lt;/level-list&gt; 布局文件 接下来，我们说说布局文件，我们不会用到CheckBox，这里我们用ImageView来顶替CheckBox，大致如下所示。123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff" android:orientation="horizontal" android:paddingLeft="12dp" android:paddingRight="12dp"&gt; &lt;ImageView android:id="@+id/selectStatusIv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:src="@drawable/level_list_common_select"/&gt; &lt;TextView android:id="@+id/selectTitleTv" android:layout_width="match_parent" android:layout_height="match_parent" android:ellipsize="end" android:gravity="center_vertical" android:lines="1" android:paddingLeft="12dp" android:singleLine="true" android:textColor="#333333" android:textSize="16sp"/&gt;&lt;/LinearLayout&gt; 这里并没有太多花里胡哨的东西，只是用一个ImageView替换掉了CheckBox。 核心逻辑 你需要找一个能够唯一标记这个选项的字段，比如id，这个字段一般都会有。然后我们的适配器里面会存放一个selectId，在渲染View的方法中校验当前项的id是否和选中的id是一致的，如果一致，则将level设置为1，否则设置为0就可以了。12345678910111213141516171819202122232425262728package com.yanfangxiong.levellistimplementselectlistimport android.content.Contextimport android.view.Viewimport com.guoshujinfu.mobile.gscloud.migration.adapter.CommonListAdapterimport kotlinx.android.synthetic.main.listitem_select.view.*/** * @author fxYan */class SelectListAdapter( context: Context, resId: Int, data: List&lt;SelectBean&gt;) : CommonListAdapter&lt;SelectBean&gt;(context, resId, data) &#123; private var selectId: Long? = null fun setSelected(selectId: Long) &#123; this.selectId = selectId &#125; override fun bindData(view: View, position: Int, data: SelectBean) &#123; view.selectStatusIv.drawable.level = if (data.id == selectId) 1 else 0 view.selectTitleTv.text = data.title &#125;&#125; 这里用的kotlin编写的，CommonListAdapter可以去看之前写的用kotlin封装的适配器。这样这个单选的逻辑就写完了。嗯，就是这么简单，不用关心CheckBox重用导致的状态复用问题。 总结 如果我不去思考该如何简化，那我永远都只是死板的用CheckBox来完成选择列表。所以，要学会思考，只根据产品给的需求完成相应的任务那是一个初级程序猿做的事情。日子还长，别太失望~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>level-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的kotlin封装List适配器]]></title>
    <url>%2F2017%2F12%2F25%2F%E6%9C%89%E8%B6%A3%E7%9A%84kotlin%E5%B0%81%E8%A3%85List%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 最近在迁移C端项目到B端，然后有很多功能点对于B端是不一样的，所以打算在迁移的过程中，用kotlin去重新写一遍。最近这几天忙着写项目，所以没有抽出什么时间来写博客，但是写博客这么好的习惯得养成，决定以后每周至少写一篇博客。 没有使用kotlin的适配器 因为ListView的适配器用kotlin封装起来比较简单，所以暂时先写关于ListView的，后续想好怎么去写RecyclerView的适配器的时候再补上。在没有使用kotlin之前，我们项目中的适配器是这样封装的，分成了两个文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public abstract class CommonListAdapter&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected int mResId; protected List&lt;T&gt; mData; public CommonListAdapter(@NonNull Context context, @LayoutRes int resId, @NonNull List&lt;T&gt; data) &#123; this.mContext = context; this.mResId = resId; this.mData = data; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = CommonViewHolder.getHolder(mContext, mResId, position, convertView, parent); bindData(holder, mData.get(position)); return holder.getConvertView(); &#125; /** * 数据绑定 * * @param holder ViewHolder对象 * @param t 要绑定的数据对象 */ public abstract void bindData(@NonNull CommonViewHolder holder, @NonNull T t);&#125;public class CommonViewHolder &#123; private SparseArray&lt;View&gt; mViews; private LayoutInflater mLayoutInflater; private View convertView; private int position; private CommonViewHolder(Context context, int resId, int position, ViewGroup parent) &#123; mViews = new SparseArray&lt;&gt;(); mLayoutInflater = LayoutInflater.from(context); convertView = mLayoutInflater.inflate(resId, parent, false); convertView.setTag(this); this.position = position; &#125; public static CommonViewHolder getHolder(Context context, int resId, int position, View convertView, ViewGroup parent) &#123; CommonViewHolder holder = null; if (convertView == null) &#123; holder = new CommonViewHolder(context, resId, position, parent); &#125; else &#123; holder = (CommonViewHolder) convertView.getTag(); holder.position = position; &#125; return holder; &#125; public View getConvertView() &#123; return convertView; &#125; public int getPosition() &#123; return position; &#125; public &lt;T extends View&gt; T get(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = convertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125;&#125; 每次只需要重写bindData方法就可以了，但是如果listitem布局中的控件多起来，还是得调用get方法很多次。最近学习了kotlin之后，在迁移中，我发现，诶，居然可以这么玩。请看下面的栗子。 使用kotlin后的适配器 可能是单身限制了我的想象力。它居然可以这么简洁，简洁，简洁。1234567891011121314151617181920abstract class CommonListAdapter&lt;T&gt;( var context: Context, @LayoutRes var resId: Int, var data: List&lt;T&gt;) : BaseAdapter() &#123; override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123; val view = convertView ?: LayoutInflater.from(context).inflate(resId, parent, false) bindData(view, position, getItem(position)) return view &#125; override fun getItem(position: Int): T = data[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = data.size abstract fun bindData(view: View, position: Int, data: T)&#125; 是的，你没有看错，就是这个样子的。然后在你的build.gradle文件中增加上这个插件。1apply plugin: 'kotlin-android-extensions' 然后你就可以任性的玩耍了。比如有这么一个布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="60dp" android:background="#ffffff" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/repayDateTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center_vertical" android:lineSpacingExtra="6dp" android:paddingLeft="12dp" android:paddingRight="10dp" android:textColor="#646464" android:textSize="12sp" tools:text="2017-10-10\n12:00"/&gt; &lt;TextView android:id="@+id/repayAmountTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:textColor="#333333" android:textSize="14sp" tools:text="1000.00"/&gt; &lt;TextView android:id="@+id/statusTv" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:paddingLeft="10dp" android:paddingRight="12dp" android:textColor="#333333" android:textSize="14sp" tools:text="处理中"/&gt;&lt;/LinearLayout&gt; 适配器就只有这么几行代码就可以解决了。12345678910111213class RepayRecordAdapter( context: Context, resId: Int, data: List&lt;RepayRecordListRespBean&gt;) : CommonListAdapter&lt;RepayRecordListRespBean&gt;(context, resId, data) &#123; override fun bindData(view: View, position: Int, data: RepayRecordListRespBean) &#123; view.repayDateTv.text = data.getSeparateTime() view.repayAmountTv.text = data.moneyOrder view.statusTv.text = data.getStatusText() &#125;&#125; 说真的，我已经逐渐爱上这门语言了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin之集合的惰性操作]]></title>
    <url>%2F2017%2F12%2F16%2Fkotlin%E4%B9%8B%E9%9B%86%E5%90%88%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 最近在学习kotlin的时候，发现了一个 骚操作 ，它叫集合的惰性操作。什么，你问我为什么称它 骚 ？我也不知道，反正脑海中就浮现了这么个词语！可能是贫穷限制了我的想象力！ 举个栗子 比如有这么一个场景，你是一家猎头公司的人员(别问我为什么是猎头，因为我看完猎场了)。然后你需要从一批人员中筛选符合条件的人选。123456data class Person(var name: String, var age: Int = 0, var workYear: Int = 0, var mail: String?)val persons = listOf(Person("Tom", 20, 2, "Tom@mail.com"), Person("Mike", 22, 3, "Mike@mail.com"), Person("Jerry", 21, 3, "Jerry@mail.com"), Person("Atom", 22, 2, "Atom@mail.com")) 你需要筛选出工作年限不小于３年的人的联系方式，然后联系他们准备进行面试。1234567println(persons.filter &#123; println("filter operate!") it.workYear &gt;= 3&#125;.map &#123; println("map operate!") it.mail&#125;) 上面的代码会输出如下的结果，这样你就成功的筛选出了Mike和Jerry。 如果你不了解 filter 和 map 两个扩展函数，可以查看源码中的这两个扩展函数是怎么写的 _Collections.kt。从输出结果上我们也可以看出它的流程是这样的，先对persons集合的每一个元素调用filter，然后会产生一个新的集合，然后对新的集合调用map，这样就得到了所有符合条件人员的联系方式。 Sequence序列 上面已经说明了这段代码的执行流程，倘若你要从你们成百上千万的人才库中筛选这些人员，执行效率是不是就非常低下了，而且如果变换操作过多的时候，你会创建很多个临时的集合。这时候，惰性操作就出来的，解释排后，代码先行！12345678910println("result is:" + persons.asSequence() .filter &#123; println("filter operate!") it.workYear &gt;= 3 &#125; .map &#123; println("map operate!") it.mail &#125; .toList()) 上面这段代码输出结果是这样的。 我们很容易就能够看出，它会对persons中的每一个元素先调用filter，如果满足条件再调用map；它是一个元素操作完之后再对另外一个元素做操作。我们再来看看一个神奇的现象，先把toList()删除掉，它会输出这个结果。 很神奇吧，它没有对persons中的元素做任何操作，只是单纯的返回了一个TransformingSequence的对象。 序列的操作 我们可以将序列的操作分为两类，intermediate operation 和 terminal operation 。看下面这张图你就明白了。 intermediate operation是惰性的。从上面的代码我们可以看出，只有当terminal operation执行的时候，intermediate operation才会执行。 总结 序列是对集合的每一个元素做所有的操作，而没有使用序列的时候是对一个集合做完某个操作后再对新的集合做后续操作； 序列只有在terminal operation调用的时候才会执行所有的操作。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限的处理]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 Android运行时权限机制 是在 API 23(Android M) 中提出来的，今年已经发布了API 26、27(Android O)，已经过去几个版本了，但是为什么我要写这个东西。首先，以前在开发的过程中，为了图方便，只是 简单的将build.gradle 中的 targetSdkVersion 设置为 22，所以基本上没有太多的和运行时权限打交道，但是随着这个人啊越来越老( 帅 )，觉得不应该躲避新的东西，而应该正视它，不然自己的技术永远都不会得到提高。所以最近打算将targetSdkVersion逐渐升上去，玩点新东西。 这是什么 在 API 23 以前，如果用户在安装应用后，默认是同意了应用所需要的权限(但是Android厂商众多，也有很多手机会弹窗提示用户是否授予权限)。而运行时权限的加入，简化了应用的安装过程，因为用户在安装的过程中不需要授予权限，而在应用的运行过程中，可以选择是否授予应用相关的权限。举个简单的例子，用户可以为相机提供相机访问权限，但是不提供位置的访问权限。 权限分类 系统权限分为两类：Normal Permission 和 Dangerous Permission” ，前者 不会直接给用户的隐私带来风险 ，所以如果你的app在Manifest文件中列出了应用需要这些权限，系统会自动赋予该权限。后者 会赋予app访问用户隐私数据的权限，是有可能对用户隐私造成风险的 。所以如果你的app在Manifest文件中列出了这些权限，则这些 权限的授予是由用户决定的 。 如何使用 接下来，我们就要开始来玩运行时权限了。 检测权限 如果你的app需要 Dangerous Permission ，则每次执行需要这一权限操作的时候都应该检测自己是否具有该权限，因为用户始终可以自由的调用此权限。检测的方法有两种，但是源码是一样的，只是穿了个不同的外套而已。12345678int cameraPermissionState = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);cameraPermissionState = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA);//判断权限是否授予if (cameraPermissionState == PermissionChecker.PERMISSION_GRANTED) &#123; //...已经具有该权限，你可以做一些羞羞的事情了&#125; else &#123; //...没有权限，这个时候你需要获取该权限了&#125; 请求权限 Android提供了多种权限请求方式，调用这些方法将会显示一个无法自定义的Android对话框。你可以调用 requestPermission() 方法来请求你所需要的权限。1ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 处理权限请求响应 当用户响应权限弹窗的时候，系统将回调 onRequestPermissionsResult() 方法，告知用户的响应情况。所以我们必须重写这个方法，如下。1234567if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...用户允许相机访问权限，你可以做一些羞羞的事情了 &#125; else &#123; //...用户拒绝了相机访问权限 &#125;&#125; 注意，系统显示的权限弹窗是对于 权限组 而言的，它不会列出app需要的具体权限。比如，app想要READ_CONTACTS权限，系统会告诉用户app想要访问设备的联系人。同时，用户只需要为每个权限组授予一次权限，如果应用请求该权限组中的任何其他权限，系统将自动授予应用这些权限 。具体过程是你在 requestPermissions() 方法之后，系统会自动回调 onRequestPermissionsResult() 方法，并传入 PERMISSION_GRANTED 。 权限组 你可能会询问权限组又是什么东西，是的，我也问过自己。所有的Dangerous Permission都属于权限组。 如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。您可以查看官方文档 。 我就知道你懒，给你截图了。如果你想看官方文档，就看看下面的图。 告诉用户你为什么需要这个权限 当用户选择单次拒绝权限的时候，你再次请求该权限，可以告知用户为什么你的app需要这些权限，以便让用户理解这些权限的作用。系统也提供了对应的方法 ActivityCompat.shouldShowRequestPermissionRationale() 。如果app之前请求过此权限，并且用户拒绝了请求这个方法就会返回true。如果app之前请求过此权限，并且用户勾选了”禁止后不再询问”，这个方法将返回false。 一次完整的权限请求 动态权限的相关其实并没有多少，来看看一段完整的请求CAMERA权限的示例。123456789101112131415161718192021222324252627282930313233343536private void checkPermission()&#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PermissionChecker.PERMISSION_GRANTED) &#123; //...开始做羞羞的事情 &#125; else &#123; requestCameraPermission(); &#125;&#125;private void requestCameraPermission() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; new AlertDialog.Builder(this) .setMessage("需要请求相机访问权限以便进行预览，拍摄") .setPositiveButton("好的", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125; &#125;) .create() .show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CAMERA) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...又可以做羞羞的事情了 &#125; &#125;&#125; 你该知道的 1. 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限 。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统 会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED ，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。 2. 要活用 shouldShowRequestPermissionRationale() 方法。这个方法是在用户拒绝过某个权限的请求(但不是禁止后不再询问)后会返回true，然后你可以在这个方法中做一些对该权限的解释，以便用户更了解为什么需要授予该权限。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>运行时权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致敬2017，关于以后]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%87%B4%E6%95%AC2017%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[由来 今天从人事那里要到了年会拍摄的全部照片，看到自己的照片已经可以弄成一个表情包还是挺意外的。不过更让我意外的是，有些照片我竟然一点记忆片段都没有，为什么，因为喝醉了，喝醉了，喝醉了！！！是的，你没有猜错，写这篇文章只是想告诉自己以后不能胡来，有些事情该做，但是也要有底线。 关于2017 自2016年6月大学毕业以来，这是我工作的第一个完整年头，从16年8月23号从1号店辞职，9月8号来到杭州，到10月17日入职果树以来，已经过去1个多年头，在此经历了很多有意思的事情，遇到了很多有意思的人，也做了人生第一次表白！嗯，是的，第一次，你没听错。虽然讲给朋友听的时候，他们说我很蠢，表白这种事情应该当面说，怎么能够在手机上说呢，哈哈，但是对于我来说，至少是跨出过第一步！嗯，这是一个值得回忆的事情(虽然有时候我确实不太会表达自己内心的想法)。这一个年头，自己的技术虽然没有得到突飞猛进的增长，但是多多少少还是有一定的提高的。 反思 1. 喝酒误事，这句话你已经体验过两次了；一次是在16年的一次公司聚会上，红酒掺杂着啤酒和白酒，导致再次醒来的时候躺在医院的病床上挂着葡萄糖；一次是刚刚过去的的年会，但是这次却没有上次那样的安静，做了很多 不可描述 的事情。虽然在同事看来可能并没有什么，但是我觉得，有些事情能避免发生就应该把它扼杀在萌芽处。俗话说 “事不过三” ，时刻告诫自己，喝酒既伤身，又误事！！！ 2. 熬夜，2017年马上就要过去了，但是这个坏习惯还是一直伴随着自己，每次并不是不想睡觉，而是强行找点事情来做，我也不知道为什么，就是不想那么早的睡着，可能我有点“黑暗恐惧症”(可能吧，哈哈)。在今后的日子里，尽量早点休息，不要熬夜； 3. 充实自己，是的，每次空闲的时间不是拿来玩游戏，就是拿来玩游戏！导致自己不太善于与人交谈；其次导致自己很宅，这也是自己一直是单身的原因之一吧！哈哈哈。所以，2018，努力改变自己，充实自己，多多接触外面的世界，外面的人，找点摆脱单身的生活。 关于博客 时刻记住自己创建这个博客的初衷！生活，不管有意思没意思，只要是值得回味的事情，都可以记录下来；技术，不管简单或是困难，只要是有自己的感悟，就值得分享出来，因为它是你成长的路程。 关于自己 我竟然对自己无话可说，哈哈哈！！！但记住，时刻做好自己，做好自己经手的每一件事情！相信你会成长为一位优秀的人员！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
