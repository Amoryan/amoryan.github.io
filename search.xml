<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全屏模式和adjustResize的冲突]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F%E5%92%8CadjustResize%E7%9A%84%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[问题 之前在写Window那一节的SoftInputMode的时候有提到过关于全屏模式和adjustResize的问题。平常我们开发过程中，经常会做状态栏的沉浸式，笔者一般使用沉浸式的方式是让布局全屏展示，然后单独写一个title的布局，在代码中让其设置一个状态栏高度的padding值，这样就简单的达到了状态栏沉浸式的效果。想法很美好，显示很骨感，这样做导致了一个问题，如果页面上有需要输入的东西，即使你设置softInputMode为adjustResize，也不会生效。应该是Android系统的一个bug，这里附上链接。 方案 这里先附上一个没有进行校准的效果。 我们在Activity中设置了如下代码，但是看效果图发现并没有什么卵用。1getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); 既然如此，笔者想能否通过监听软键盘的弹起和落下来动态的改变LayoutParam的height值，朝着这个方向，就有了接下来的方法。 首先，我们给根布局设置一个监听事件12345678ViewGroup vp = findViewById(android.R.id.content);vp.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener()&#123; @Override public void onGlobalLayout() &#123; &#125;&#125;); 然后，我们要想办法监听到软键盘的弹起和落下，这里笔者通过布局可视高度的变化来进行判断。1234567891011121314151617181920Rect rect = new Rect();int visibleHeight = 0;@Overridepublic void onGlobalLayout() &#123; vp.getWindowVisibleDisplayFrame(rect); if (visibleHeight == 0) &#123; visibleHeight = rect.bottom; &#125; else if (visibleHeight - rect.bottom &gt; 200) &#123; // 这里键盘弹起来 visibleHeight = rect.bottom; lp.height = visibleHeight; vp.requestLayout(); &#125; else if (rect.bottom - visibleHeight &gt; 200) &#123; // 这里键盘落下去 visibleHeight = rect.bottom; lp.height = visibleHeight; vp.requestLayout(); &#125;&#125; 最后运行下来看看效果图。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于sw限定符适配]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%85%B3%E4%BA%8Esw%E9%99%90%E5%AE%9A%E7%AC%A6%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Could not find lint-gradle-api]]></title>
    <url>%2F2018%2F10%2F31%2FCould-not-find-lint-gradle-api%2F</url>
    <content type="text"><![CDATA[问题所在 这几天刚把Flutter的开发环境搭建好，准备学习Flutter。搭建开发环境，可以参考Flutter文档上面的内容，写的还是非常详细的。 于是我新建了一个flutter的项目，然后运行该项目，结果给了我如下的错误。 从日志上来看，是flutter在构建项目的时候找不到lint-gradle-api.jar，那么就得想办法让flutter在构建的时候能够访问到这个jar包才行。通过google我这里提供两种方案。 方案一 首先找到你的flutter的安装目录，如果不知道在哪里的，可以通过terminal的命令找到安装目录。1$ which flutter 找到安装目录之后，我们进入到flutter的目录下，然后进入到flutter/packages/flutter_tools/gradle/这个目录下，你会发现这个目录下面有一个flutter.gralde文件。然后我们找到下面代码所在的位置。1234567891011buildscript &#123; repositories &#123; jcenter() maven &#123; url 'https://dl.google.com/dl/android/maven2' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.2' &#125;&#125; 第一种方案非常简单只需要在jcenter()之前加上google()就可以了，然后去运行你的flutter项目。123456789101112buildscript &#123; repositories &#123; google() jcenter() maven &#123; url 'https://dl.google.com/dl/android/maven2' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.2' &#125;&#125; 方案二 如果还是无法找到lint-gradle-api.jar，那么这里再给你一个国内阿里的仓库地址。12345678910111213buildscript &#123; repositories &#123; maven&#123; url 'https://maven.aliyun.com/repository/jcenter' &#125; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.2' &#125;&#125; 配置成上面的maven仓库地址也是可以解决这个问题的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用gradle统一项目配置]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%BD%BF%E7%94%A8gradle%E7%BB%9F%E4%B8%80%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[问题所在&ensp;&ensp;在项目开发过程中，经常会有很多的module，而每个module下面都会依赖一些library，当项目越来越大的时候，这种分散在每个module下面单独的gradle配置依赖库的方式就很难以进行管理。 解决方式&ensp;&ensp;我们可以通过gradle的ext变量来建立一个公用的配置，这样其他的module中的gralde配置从这个公用配置中获取需要的信息来完成自身module的配置。这样既能够保证每个module下的依赖库版本是一致的，而且管理起来也十分的方便。 build.gradle&ensp;&ensp;首先我们来看看一个module下面的build.gradle文件的依赖库配置(这里只是举个栗子，比较简单，请以实际开发为准)。12345678//supportimplementation "com.android.support:appcompat-v7:27.1.1"implementation "com.android.support:design:27.1.1"implementation "com.android.support:cardview-v7:27.1.1"//retrofitimplementation "com.squareup.retrofit2:retrofit:2.3.0"implementation "com.squareup.retrofit2:converter-gson:2.3.0"implementation "com.squareup.retrofit2:adapter-rxjava2:2.3.0" config.gradle&ensp;&ensp;然后我们在主工程的外层新建一个config.gradle(名字自取)文件，使用ext变量，它里面用map存放一些键值对的信息。下面是我写的一些配置。123456789101112131415161718192021222324252627282930ext &#123; versions = [ "android_support_version": "27.1.1", "retrofit_version" : "2.3.0" ] groups = [ "android_support": "com.android.support", "retrofit2" : "com.squareup.retrofit2" ] names = [ // support "appcompat_v7" : "appcompat-v7", "design" : "design", "cardview_v7" : "cardview-v7", // retrofit "retrofit" : "retrofit", "converter_gson" : "converter-gson", "adapter_rxjava2": "adapter-rxjava2" ] android_support = [ "appcompat_v7": "$&#123;groups.android_support&#125;:$&#123;names.appcompat_v7&#125;:$&#123;versions.android_support_version&#125;", "design" : "$&#123;groups.android_support&#125;:$&#123;names.design&#125;:$&#123;versions.android_support_version&#125;", "cardview_v7" : "$&#123;groups.android_support&#125;:$&#123;names.cardview_v7&#125;:$&#123;versions.android_support_version&#125;" ] retrofit2 = [ "retrofit" : "$&#123;groups.retrofit2&#125;:$&#123;names.retrofit&#125;:$&#123;versions.retrofit_version&#125;", "converter_gson" : "$&#123;groups.retrofit2&#125;:$&#123;names.converter_gson&#125;:$&#123;versions.retrofit_version&#125;", "adapter_rxjava2": "$&#123;groups.retrofit2&#125;:$&#123;names.adapter_rxjava2&#125;:$&#123;versions.retrofit_version&#125;", ]&#125; 引入config.gradle&ensp;&ensp;配置文件写完了，那么如何将其引入到工程中呢，这个时候我们需要在主工程的build.gradle文件开头添加如下一句话。1apply from : "config.gradle" 这样重新构建一下，就能够将config.gradle文件引入到主工程中了。 修改module的build.gradle&ensp;&ensp;接下来我们来修改刚才module中的build.gradle文件，如下所示。123456789101112def support = rootProject.ext.android_supportdef retrofit = rootProject.ext.retrofit2dependencies &#123; implementation support.appcompat_v7 implementation support.design implementation support.cardview_v7 implementation retrofit.retrofit implementation retrofit.converter_gson implementation retrofit.adapter_rxjava2&#125; &ensp;&ensp;修改完成后重新构建项目，ok，你会发现完全没有问题，这样我们就可以将其他module下的依赖库也通过相同的方式来引入，而当要修改依赖库版本相关信息的时候，只需要修改配置文件中的版本信息就可以了，这样是不是很方便呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[从源码角度看okhttp]]></title>
    <url>%2F2018%2F09%2F12%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8Bokhttp%2F</url>
    <content type="text"><![CDATA[举个栗子 okhttp是square公司开源的http请求框架，支持同步请求和异步请求，一般用法如下。123456789101112131415161718192021222324252627282930val client = OkHttpClient.Builder() .connectTimeout(60, TimeUnit.SECONDS) .readTimeout(60, TimeUnit.SECONDS) .writeTimeout(60, TimeUnit.SECONDS) .addInterceptor &#123; chain -&gt; val oldRequest: Request = chain.request() val newRequest: Request = oldRequest.newBuilder() .addHeader("accessToken", "xxx") .build() chain.proceed(newRequest) &#125; .build()val request = Request.Builder() .url("xxx") .get() .build()val call = client.newCall(request)//同步请求//call.execute()//异步请求call.enqueue(object : Callback &#123; override fun onFailure(call: Call?, e: IOException?) &#123; //失败 &#125; override fun onResponse(call: Call?, response: Response?) &#123; //成功 &#125;&#125;) 可以看到，使用okhttp的一般步骤如下： 构建OkHttpClient对象，并配置相关的参数； 构建Request请求； 构建Call对象； 执行execute()同步请求或者执行enqueue()异步请求 OkHttpClient 典型的Builder模式，我们可以通过构建OkHttpClient.Builder来配置一些参数信息。12345678910111213141516171819202122public Builder() &#123; dispatcher = new Dispatcher();//网络请求的分发器 protocols = DEFAULT_PROTOCOLS;//支持http1.1，http2.0 connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true;//失败重连 connectTimeout = 10_000;//默认连接超时10s readTimeout = 10_000;//默认读取超时10s writeTimeout = 10_000;//默认写入超时10s pingInterval = 0;&#125; Request Request表示一个请求，请求一般包括url，method，header等，我们可以看看Request的成员定义。1234final HttpUrl url;//请求的urlfinal String method;//请求方式 get/post/put/delete 等final Headers headers;//请求头final @Nullable RequestBody body;//请求体 Call它是一个接口。12345678910111213141516171819202122232425public interface Call extends Cloneable &#123; Request request(); //同步请求 Response execute() throws IOException; //异步请求 void enqueue(Callback responseCallback); //取消请求 void cancel(); //如果Call已经调用了execute()或者enqueue()，则返回true boolean isExecuted(); //是否已经取消了 boolean isCanceled(); //使用当前Call创建一个新的Call Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 我们可以看看OkHttpClient的newCall(Request)方法。123@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; 可以看到这里实际上是调用了RealCall的newRealCall()。 RealCall RealCall是Call的实现类，一般我们操作的实际上也是RealCall。这里我只粘贴比较有用的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687final class RealCall implements Call &#123; final OkHttpClient client; final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor; //事件监听器 private EventListener eventListener; //用来构建Call的Request final Request originalRequest; //当前Call是否已经执行，每个Call只能够被执行一次 private boolean executed; private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); &#125; static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; //调用构造方法 RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; &#125; //同步执行 @Override public Response execute() throws IOException &#123; //这里使用同步代码块保证每个Call只能够执行一次 synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; //还记得OkHttpClient中构造的时候的Dispatcher吗，这里实际上是把RealCall给了Dispatcher去调用它的executed()方法，当然只是将其加入到正在执行同步请求的队列中 client.dispatcher().executed(this); //实际上进行同步请求的是这个方法 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; //异步执行 @Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); //这里构造成Runnable然后移交给Dispatcher的异步请求方法 client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; //这里是做同步请求的核心代码 Response getResponseWithInterceptorChain() throws IOException &#123; //这里是我们添加的拦截器 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //网络请求重试拦截器 interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123;//是否是websocket interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); //构造InterceptorChain Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); //调用proceed开始进行请求 return chain.proceed(originalRequest); &#125;&#125; 可以看到不管是executed()做同步请求还是使用enqueue()做异步请求，最终都会调用到OkHttpClient的Dispatcher的executed()方法和enqueue()方法，请求的核心代码是在RealCall的getResponseWithInterceptorChain()中，对于同步请求，Dispatcher只是将RealCall添加到正在执行同步请求的队列中做一个记录。 AsyncCall 我们可以看到RealCall里面有一个内部类AsyncCall，它是一个Runnable，我们在RealCall的enqueue()方法中有这么一行代码。1client.dispatcher().enqueue(new AsyncCall(responseCallback)); 可以看到在交给Dispatcher进行异步请求的时候会先构造一个AsyncCall的对象，那么AsyncCall是什么呢？实际上就是一个Runnable。123456789101112131415161718192021222324252627282930313233final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //咦咦咦，看到没有，这个方法由线程池执行Runnable后调用run()进一步调用这个方法，做请求的东西实际上和同步请求一样，还是调用了getResponseWithInterceptorChain() Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; 我们可以看到异步请求的核心代码和同步请求的核心代码都是getResponseWithInterceptorChain()；然后我们看看NamedRunnable，就只是在构造器中增加了对应的名称，然后当任务交给线程执行的时候，将线程的名称修改为指定的名称。123456789101112131415161718192021public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; //修改Thread的名称为指定名称 String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; //这里执行请求 execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; Dispatcher 这是个网络请求的分发器，我们上面有分析RealCall的源码，它里面的同步和异步请求都会分发给Dispatcher的同步和异步请求，这里同样只粘贴核心代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class Dispatcher &#123; //最大请求数 private int maxRequests = 64; //每个host的最大请求数 private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; //执行请求的线程池 private @Nullable ExecutorService executorService; //准备进行异步请求的Call队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //正在进行异步请求的Call队列 private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //正在进行同步请求的Call队列 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); //构造线程池 public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; synchronized void enqueue(AsyncCall call) &#123; //1.正在执行异步请求的Call队列小于最大请求数量；2.call对应的host的请求数量小于每个host的最大请求数量 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //添加到正在执行异步请求的Call队列中 runningAsyncCalls.add(call); //将Runnable交给线程池 executorService().execute(call); &#125; else &#123; //添加到等待队列 readyAsyncCalls.add(call); &#125; &#125; synchronized void executed(RealCall call) &#123; //添加到正在执行的同步请求队列 runningSyncCalls.add(call); &#125;&#125;//这个方法主要是调整用的，如果正在请求的Call队列没有到最大请求，且等待队列有Call则将等待队列中的Call移到正在请求队列，并将Runnable交给线程池处理 private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125; &#125; RealInterceptorChain 在RealCall的getResponseWithInterceptorChain()方法中，我们可以看到最终代码会调用到RealInterceptorChain.proceed()方法。123456789101112131415public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; calls++; //创建下一个RealInterceptorChain RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); //在interceptor的interceptor中实际上调用了chanin的proceed()，相当于交给了下一个RealInterceptorChain Response response = interceptor.intercept(next); return response;&#125; 可以看到这是一个链式调用，大致上如下图所示。 关于如何回传我们可以看看最后一个Interceptor的intercep()，也就是CallServerInterceptor的intercept()方法。12345678910@Override public Response intercept(Chain chain) throws IOException &#123; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); return response;&#125; 可以看到CallServerInterceptor的intercept()方法会返回Response。]]></content>
  </entry>
  <entry>
    <title><![CDATA[taskAffinity属性]]></title>
    <url>%2F2018%2F09%2F12%2FtaskAffinity%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[我们在AndroidManifest.xml文件中可以指定taskAffinity属性，如下所示。1234&lt;activity android:name=".CActivity" android:launchMode="singleTask" android:taskAffinity="com.yanfangxiong.taskAffinity" /&gt; 它表示任务相关性，实际上的作用是指定所在的任务栈的名称，指定taskAffinity也需要注意以下几点 taskAffinity的值不要和包名一样，因为默认情况下，Activity都是运行在包名的任务栈中； taskAffinity的值中必须要有”.”，不然无法运行。 像上面的代码，当启动CActivity的时候，会看是否有com.yanfangxiong.taskAffinity的任务栈存在，如果没有则会新建名为com.yanfangxiong.taskAffinity的任务栈，然后再将CActivity放入到任务栈，如果有该任务栈存在，则会看是否有CActivity的实例，如果有则调用onNewIntent()方法。但但但是，一般我们使用taskAffinity没有作用，为什么呢？因为taskAffinity属性要和singleTask启动模式(Intent的FLAG_ACTIVITY_NEW_TASK)一起使用，或者和allowTaskReparenting属性一起使用。 和singleTask一起使用 我们可以像上面一样在manifest文件中指定launchMode为singleTask，然后给Activity指定taskAffinity属性。123456789101112&lt;activity android:name=".AActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=".BActivity" android:launchMode="singleTask" android:screenOrientation="portrait" android:taskAffinity="com.yanfangxiong.taskAffinity" /&gt; 或者我们不置顶BActivity的launchMode，通过Intent的flag，如下。123456val intent = Intent(this@AActivity, BActivity::class.java)intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)val queryIntent = this@AActivity.packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY)if (queryIntent != null &amp;&amp; queryIntent.isNotEmpty()) &#123; this@AActivity.startActivity(intent)&#125; 上面的代码表示AActivity将会运行在名字为包名的任务栈，而BActivity将会运行在名字为com.yanfangxiong.taskAffinity的任务栈中。我们通过如下代码打印出taskId，看看两者是否是相同的。1234override fun onResume() &#123; super.onResume() Log.d("fxYan", "$taskId")&#125; 然后我们运行程序，之后从AActivity跳转到BActivity，看看两者是否在同一个任务栈中。可以看到两者在两个不同的任务栈中。 和allowTaskReparenting一起使用 栗子已备好，大人请品尝。我创建了两个app，一个是com.yanfangxiong.test，记为A应用，另外一个是com.yanfangxiong.test2，记为B应用。A应用中有一个AActivity，B应用中有一个AActivity和一个BActivity；然后从A应用的AActivity点击后会打开B应用的BActivity。然后我们分别修改BActivity的allowTaskReparenting属性，执行相同的流程。 打开A应用； 通过A应用的AActivity启动B应用的BActivity； 回到桌面； 通过B应用的launcher启动B应用。 这里涉及到一个命令，可以查看activity的信息。1$ adb shell dumpsys activity activities allowTaskReparenting为false 我们先来看看当B应用的BActivity的allowTaskReparenting为false的情况。为了简化，我这里只输出第四步的activity信息，如下所示。 先来看看B应用的任务栈信息，可以看到，只有我们启动的AActivity在任务栈中。 然后再看看A应用的任务栈信息，可以看到，有B应用的BActivity和A应用的AActivity在任务栈中。 allowTaskReparenting为true 然后我们看看allowTaskReparenting为true的情况，如下所示。 先来看看B应用的任务栈信息，可以看到神奇的一幕，有我们启动的AActivity以及之前通过A应用启动的BActivity在任务栈中，而且这个时候返回的时候是返回AActivity。 然后再看看A应用的任务栈信息，可以看到，只有A应用的AActivity在任务栈中。 allowTaskReparenting属性为true的时候，BActivity发现B应用启动后，有自己想要的任务栈，所以会从A应用的任务栈迁移到B应用的任务栈，就出现了上面神奇的一幕。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于http和https]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%85%B3%E4%BA%8Ehttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[http http(HyperText transfer protocol)是超文本传输协议的简称。它是浏览器和服务器之间传输信息的一种应用层协议，以明文的方式传输内容。 因为是明文传输，如果其他人通过拦截请求的方式就可以获取到传输数据，所以http协议是不安全的。 https 为了解决http协议传输数据的不安全性，就出现了https。https是安全超文本传输协议，它在http协议的基础上加入了SSL协议，SSL协议通过CA证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 单向认证双向认证http2.0新特性]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何使用Telegram客户端]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Telegram%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[嗯～，Telegram是一款工作沟通交流的工具。这里总结下各端上的Telegram客户端如何正常使用。 通用方法 适用于各个端的Telegram客户端，配置下MTPROTO代理 这里提供两个免费的MTPROTO代理。 配置一 server 74.120.175.43 port 400 secret bbd3d8c677df2c657bed1a1094a7e75a 配置二 Server 45.77.97.94 port 400 secret 5788c35845a9d6c9e8a0db182c60765e Android Android上面下载一个ShadowSocks的app，还可以进行翻墙，很方便吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈camera2API]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%B5%85%E8%B0%88camera2API%2F</url>
    <content type="text"><![CDATA[camera2是API21出的一套方便与camera devices进行交互的包。要使用camera2 API，我们首先得对其中的一些基本的类有一定的了解。 基础类CameraManager 它是一个系统服务，通过它我们可以访问CameraDevice以及获取关于CameraDevice的一些特性。 一般我们通过Context的getSystemService()方法就能获取到CameraManager的实例。1val camaraManager = context.getSystemService(Context.CAMERA_SERVICE) 它是在SystemServiceRegistry的static代码块中注册的。123456registerService(Context.CAMERA_SERVICE, CameraManager.class, new CachedServiceFetcher&lt;CameraManager&gt;() &#123; @Override public CameraManager createService(ContextImpl ctx) &#123; return new CameraManager(ctx); &#125;&#125;); 内部类AvailabilityCallback 就是监听Camera是否有用的一个回调。12345678public static abstract class AvailabilityCallback &#123; public void onCameraAvailable(@NonNull String cameraId) &#123; &#125; public void onCameraUnavailable(@NonNull String cameraId) &#123; &#125;&#125; TorchCallback 监听闪光灯模式的一个回调。123456789public static abstract class TorchCallback &#123; public void onTorchModeUnavailable(@NonNull String cameraId) &#123; &#125; public void onTorchModeChanged(@NonNull String cameraId, boolean enabled) &#123; &#125;&#125; 常用方法getCameraIdList() getCameraIdList()可以获取到硬件设备所有的可用camera id。1234@NonNullpublic String[] getCameraIdList() throws CameraAccessException &#123; return CameraManagerGlobal.get().getCameraIdList();&#125; 我们可以看到它里面实际上是调用的CameraManagerGlobal的getCameraIdList()方法。12345678910111213141516171819202122232425public String[] getCameraIdList() &#123; String[] cameraIds = null; synchronized(mLock) &#123; // Try to make sure we have an up-to-date list of camera devices. connectCameraServiceLocked(); int idCount = 0; for (int i = 0; i &lt; mDeviceStatus.size(); i++) &#123; int status = mDeviceStatus.valueAt(i); if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING) continue; idCount++; &#125; cameraIds = new String[idCount]; idCount = 0; for (int i = 0; i &lt; mDeviceStatus.size(); i++) &#123; int status = mDeviceStatus.valueAt(i); if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING) continue; cameraIds[idCount] = mDeviceStatus.keyAt(i); idCount++; &#125; &#125; return cameraIds;&#125; mDeviceStatus是一个map集合，key是camera id，value是camera id对应的camera status，mDeviceStatus的元素是在connectCameraServiceLocked()方法调用的时候存放的。1234567891011121314151617181920212223242526272829303132333435363738private void connectCameraServiceLocked() &#123; // 重连 if (mCameraService != null) return; //获取IBinder对象，进而获取到ICameraService的对象 IBinder cameraServiceBinder = ServiceManager.getService(CAMERA_SERVICE_BINDER_NAME); if (cameraServiceBinder == null) &#123; // Camera service下线 return; &#125; try &#123; cameraServiceBinder.linkToDeath(this, /*flags*/ 0); &#125; catch (RemoteException e) &#123; // Camera service下线 return; &#125; ICameraService cameraService = ICameraService.Stub.asInterface(cameraServiceBinder); try &#123; CameraMetadataNative.setupGlobalVendorTagDescriptor(); &#125; catch (ServiceSpecificException e) &#123; handleRecoverableSetupErrors(e); &#125; try &#123; CameraStatus[] cameraStatuses = cameraService.addListener(this); for (CameraStatus c : cameraStatuses) &#123; onStatusChangedLocked(c.status, c.cameraId); &#125; mCameraService = cameraService; &#125; catch(ServiceSpecificException e) &#123; // Unexpected failure throw new IllegalStateException("Failed to register a camera service listener", e); &#125; catch (RemoteException e) &#123; // Camera service is now down, leave mCameraService as null &#125;&#125; 我们再来看看onStatusChangeLocked()方法。123456789101112131415161718192021222324private void onStatusChangedLocked(int status, String id) &#123; // 判断当前camera id对应的状态是否是有效状态 if (!validStatus(status)) &#123; return; &#125; // 存放到mDeviceStatus中 Integer oldStatus = mDeviceStatus.put(id, status); if (oldStatus != null &amp;&amp; oldStatus == status) &#123; return; &#125; if (oldStatus != null &amp;&amp; isAvailable(status) == isAvailable(oldStatus)) &#123; return; &#125; // 如果camera id对应的状态发生改变，则回调给通过CameraManager的register方法注册的AvailabilityCallback final int callbackCount = mCallbackMap.size(); for (int i = 0; i &lt; callbackCount; i++) &#123; Handler handler = mCallbackMap.valueAt(i); final AvailabilityCallback callback = mCallbackMap.keyAt(i); postSingleUpdate(callback, handler, id, status); &#125;&#125; getCameraCharacteristics 通过这个方法，我们可以获取到对应camera id的CameraCharacteristics对象。12345678910111213141516171819202122232425262728293031323334public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId) throws CameraAccessException &#123; CameraCharacteristics characteristics = null; synchronized (mLock) &#123; ICameraService cameraService = CameraManagerGlobal.get().getCameraService(); if (cameraService == null) &#123; throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable"); &#125; try &#123; if (!supportsCamera2ApiLocked(cameraId)) &#123; // 遗留问题不兼容camera2 api locked int id = Integer.parseInt(cameraId); String parameters = cameraService.getLegacyParameters(id); CameraInfo info = cameraService.getCameraInfo(id); characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info); &#125; else &#123; CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId); characteristics = new CameraCharacteristics(info); &#125; &#125; catch (ServiceSpecificException e) &#123; throwAsPublicException(e); &#125; catch (RemoteException e) &#123; throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable", e); &#125; &#125; return characteristics;&#125; openCamera() 通过这个方法我们就可以获取到CameraDevice对象了，我们可以看到这个方法接受一个CameraDevice.StateCallback对象，当CameraDevice连接成功和失败的时候就会回调到这个Callback的对应方法中。 (un)registerAvailabilityCallback 注册和取消注册AvailabilityCallback，最终会将其放到CameraManagerGlobal的mCallbackMap中。 (un)registerTorchCallback 注册和取消注册TorchCallback，最终会将其放到CameraManagerGlobal的mTorchCallbackMap中。 CameraService的重连 在查看CameraManager的源码过程中，发现CameraService下线重连机制，通过IBinder的死亡代理进行重连，我们在connectCameraServiceLocked()中看到，在调用linkToDeath()的时候，如果发现CameraService下线了，会回调到binderDied()方法中，我们看看binderDied()方法做的事情是什么。1234567891011121314151617181920public void binderDied() &#123; synchronized(mLock) &#123; if (mCameraService == null) return; mCameraService = null; // 更新cameraId对应的status for (int i = 0; i &lt; mDeviceStatus.size(); i++) &#123; String cameraId = mDeviceStatus.keyAt(i); onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId); &#125; // for (int i = 0; i &lt; mTorchStatus.size(); i++) &#123; String cameraId = mTorchStatus.keyAt(i); onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId); &#125; // 这个方法里面进行cameraService的重连 scheduleCameraServiceReconnectionLocked(); &#125;&#125; 我们可以看scheduleCameraServiceReocnnectionLock()方法。12345678910111213141516171819202122232425262728private void scheduleCameraServiceReconnectionLocked() &#123; final Handler handler; if (mCallbackMap.size() &gt; 0) &#123; handler = mCallbackMap.valueAt(0); &#125; else if (mTorchCallbackMap.size() &gt; 0) &#123; handler = mTorchCallbackMap.valueAt(0); &#125; else &#123; // 如果没有注册callback，则不进行重连操作 return; &#125; handler.postDelayed( new Runnable() &#123; @Override public void run() &#123; // 重连 ICameraService cameraService = getCameraService(); if (cameraService == null) &#123; synchronized(mLock) &#123; // 重连失败，继续重连 scheduleCameraServiceReconnectionLocked(); &#125; &#125; &#125; &#125;, CAMERA_SERVICE_RECONNECT_DELAY_MS);&#125; CameraDevice 它表示的就是Android设备上的一个摄像头，允许你在高帧率的情况下对图像进行捕获以及后期处理有一个精细的控制。 TEMPLATE CameraDevice里面定义了一些TEMPLATE，使我们在创建CaptureRequest.Builder的时候需要的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * 创建一个适合于相机预览窗口的Request，这意味着高帧率优先于高质量处理，这个Request正常 * 情况下被用于CameraCaptureSession的setRepeatingRequest()，这个TEMPLATE在所有的 * camera devices上都支持 */ public static final int TEMPLATE_PREVIEW = 1; /* * 创建一个静态图像捕获的Request，这意味着优先考虑图片质量，而不是帧率。通常情况下被用于 * CameraCaptureSession的capture()，这个TEMPLATE在所有的camera devices上都支持 */ public static final int TEMPLATE_STILL_CAPTURE = 2; /* * 创建一个适合于视频录制的Request，这意味着需要一个稳定的帧率和质量。通常情况下被用于 * CameraCaptureSession的setRepeatingRequest()，这个TEMPLATE在所有的camera devices * 上都支持 */ public static final int TEMPLATE_RECORD = 3; /* * 创建一个在视频录制过程中静态图像捕获的Request，这意味着在不中断的录制过程中最大化图像质量。 * 通常情况下，你通过CameraDevice的createCaptureRequest(TEMPLATE_RECORD)创建一个 * Request，然后通过CameraCaptureSession的setRepeatingRequest()开启视频录制请求， * 然后你调用CameraCaptureSession的capture()可以使用这个TEMPLATE，这个TEMPLATE * 基本所有的camera devices都支持，除非旧设备的CameraCharacteristics的 * INFO_SUPPORTED_HARDWARE_LEVEL字段为INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY */ public static final int TEMPLATE_VIDEO_SNAPSHOT = 4; /* * 创建一个零延时的静态图像捕获Request，这意味着在不影响预览帧率的情况下，最大化图像质量。 * 这个TEMPLATE被所有支持 * CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING * CameraMetadata#PRIVATE_REPROCESSING * CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING * CameraMetadata#YUV_REPROCESSING * 的camera devices所支持 */ public static final int TEMPLATE_ZERO_SHUTTER_LAG = 5; /* * 用于直接应用程序控制捕获参数的basic TEMPLATE，所有的自动控制都会失效，比如自动曝光， * 自动白平衡，自动聚焦等。手动设置的参数诸如曝光等都被设置为合理的默认值，但是你可以根据 * 程序的需要修改这些值。 * 这个TEMPLATE被所有的支持 * CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR * CameraMetadata#MANUAL_SENSOR * 的camera devices所支持 */ public static final int TEMPLATE_MANUAL = 6; 内部类StateCallback Camera Device的各种状态回调。1234567891011121314151617181920212223242526272829303132333435public static abstract class StateCallback &#123; // 打开camera失败，camera device被一个优先级更高的client在使用 public static final int ERROR_CAMERA_IN_USE = 1; // 打开camera失败，所有的camera device正在被使用 public static final int ERROR_MAX_CAMERAS_IN_USE = 2; // setCameraDisabled();因为设备原因无法打开camera public static final int ERROR_CAMERA_DISABLED = 3; // camera device遇到一个致命的错误，需要重新打开以便使用 public static final int ERROR_CAMERA_DEVICE = 4; // Android设备遇到一个致命的错误，需要重新启动来加载camera相关功能 public static final int ERROR_CAMERA_SERVICE = 5; // camera device被打开的时候回调，表示camera可以被使用了 public abstract void onOpened(@NonNull CameraDevice camera); // Must implement // 当调用CameraDevice的close()方法的时候会回调， public void onClosed(@NonNull CameraDevice camera) &#123; &#125; /* * camera device不在可用的时候会回调，可能是安全策略或权限的改变，也可能是可拆卸摄像头连接 * 断开，亦或者是一个更高优先级的client需要使用camera device。此方法调用之后仍然会触发capture * 回调，或者将新的image buffer递送给活跃的输出。 */ public abstract void onDisconnected(@NonNull CameraDevice camera); // Must implement // camera device发生错误的时候会回调这个方法 public abstract void onError(@NonNull CameraDevice camera, @ErrorCode int error); // Must implement&#125; 常用方法close 尽可能快的关闭camera device的连接，一旦这个方法被调用，后续访问camera device将会抛出IllegalStateException。当和camera device的连接完全关闭的时候，会回调到StateCallback的onClosed()方法，此时camera device是可以被重新打开的。 这个方法调用之后，在StateCallback的onClosed()方法调用之前，camera device和活跃的session的callback都不会发生，那些已经提交的capture请求也会被丢弃，就好像CameraCaptureSession的abortCaptures()被调用了一样，但是失败的callback会被调用。 createCaptureSession 通过提供给camera device一个目标输出的Surface集合来创建一个新的camera capture session。活跃的camera session为camera device的每个capture request确定一组潜在的输出Surface集合，每个capture request可能使用其中的某个或者所有的输出Surface。一旦CameraCaptureSession被创建了，你就可以通过CameraCaptureSession的capture(),captureBurst(),setRepeatingCapture(),setRepeatingBurst()来发起capture请求。123public abstract void createCaptureSession(@NonNull List&lt;Surface&gt; outputs, @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler) throws CameraAccessException; createCaptureRequest 接受一个TEMPLATE来创建CaptureRequest.Builder，Request是用于CameraCaptureSession和硬件设备进行交互的。123@NonNullpublic abstract CaptureRequest.Builder createCaptureRequest(@RequestTemplate int templateType) throws CameraAccessException; CameraCaptureSession CaptureRequest使用常见问题拍摄图片方向反转 这个问题应该算是遇到的比较多的，图片拍摄保存后是倒着的。要弄清楚这个问题产生的原因我们得知道两个东西，一个是屏幕rotation，一个是camera sensor的角度，这两个因素决定了你拍摄的图片后的方向。一般我们竖屏的界面，屏幕rotation是Surface.ROTATION_0，然后一般的手机camera sensor的角度是90度，这个时候我们拍摄的图片保存是正常，但是有些手机的camera sensor是270度，这样拍摄就会导致图片保存的时候是倒着的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[APT揭露编译时注解的面纱]]></title>
    <url>%2F2018%2F08%2F01%2FAPT%E6%8F%AD%E9%9C%B2%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[有效的防止系统字体修改影响app]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%9C%89%E6%95%88%E7%9A%84%E9%98%B2%E6%AD%A2%E7%B3%BB%E7%BB%9F%E5%AD%97%E4%BD%93%E4%BF%AE%E6%94%B9%E5%BD%B1%E5%93%8Dapp%2F</url>
    <content type="text"><![CDATA[前言 不知道你们有没有这种烦恼，比如我们在使用TextView控件的时候，设置字体大小是16sp，然后我们在手机设置中将字体的大小从标准修改为小，大或者特大，然后再回到app，发现这个时候TextView上显示的文本完全就不是我们想要的，因为sp会受到系统字体大小设置的影响。 解决方法 这里提供两种解决方法，更推荐使用第二种方式。 方法一 这种方法比较暴躁，也比较简单，就是你布局文件中textSize的单位使用dp，这样就不会受到设置的影响了。但是，这样修改后会有警告，因为google是建议textSize的单位使用sp。 方法二 于是在google上搜索了N多篇博客，基本都是如下的方式，重写getResource()方法。1234567override fun getResources(): Resources &#123; val resources = super.getResources() val config = Configuration() config.setToDefaults() resources.updateConfiguration(config, resources.displayMetrics) return resources&#125; 我想问，你们这样写就没有一点点的疑问吗，这样会将Configuration的配置全部重置为默认的，也就是说你设置的一些配置都没有了。 于是我将代码修改为了下面的，从当前的resources获取configuration然后对其的fontScale进行修改。1234567891011override fun getResources(): Resources &#123; val resources = super.getResources() if (resources != null) &#123; val config = resources.configuration if (config != null &amp;&amp; config.fontScale != 1F) &#123; config.fontScale = 1F resources.updateConfiguration(config, resources.displayMetrics) &#125; &#125; return resources&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的给RecyclerView添加头尾]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%99RecyclerView%E6%B7%BB%E5%8A%A0%E5%A4%B4%E5%B0%BE%2F</url>
    <content type="text"><![CDATA[前言 RecyclerView的可定制化程度相较于ListView确实是方便了很多，但是RecyclerView是不支持添加头尾以及空布局的，经过一些实践，最终觉得对适配器进行扩展的方式是比较方便的。 内容 这里就不在赘述，直接上代码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192@SuppressWarnings("ALL")public abstract class BaseRecyclerAdapter&lt;T, VH extends RecyclerView.ViewHolder&gt; extends RecyclerView.Adapter &#123; private final int ITEM_TYPE = 0; private final int EMPTY_TYPE = 99; private final int BASE_HEADER_TYPE = 100; private final int BASE_FOOTER_TYPE = 200; protected Context context; protected LayoutInflater inflater; protected int resId; protected List&lt;T&gt; dataSource; protected SparseArray&lt;View&gt; headers; protected SparseArray&lt;View&gt; footers; protected View emptyView; protected OnItemClickListener&lt;T&gt; onItemClickListener; protected View.OnClickListener onClickListener; protected boolean showHeaderFooterWhenEmpty; public BaseRecyclerAdapter(@NonNull Context context, @LayoutRes int resId) &#123; this.context = context; this.inflater = LayoutInflater.from(context); this.resId = resId; this.dataSource = new ArrayList&lt;&gt;(); this.headers = new SparseArray&lt;&gt;(); this.footers = new SparseArray&lt;&gt;(); &#125; public void clearDataSource() &#123; dataSource.clear(); &#125; public void addAll(List&lt;T&gt; list) &#123; dataSource.addAll(list); &#125; public void addHeaderView(View header) &#123; if (headers.indexOfValue(header) &lt; 0) &#123; headers.put(BASE_HEADER_TYPE + headers.size(), header); &#125; &#125; public void addFooterView(View footer) &#123; if (footers.indexOfValue(footer) &lt; 0) &#123; footers.put(BASE_FOOTER_TYPE + footers.size(), footer); &#125; &#125; public int getHeaderCount() &#123; return headers.size(); &#125; public int getFooterCount() &#123; return footers.size(); &#125; public void setEmptyView(View view) &#123; this.emptyView = view; &#125; public void setShowHeaderFooterWhenEmpty(boolean showHeaderFooterWhenEmpty) &#123; this.showHeaderFooterWhenEmpty = showHeaderFooterWhenEmpty; &#125; public void setOnItemClickListener(OnItemClickListener&lt;T&gt; listener) &#123; this.onItemClickListener = listener; &#125; public void setOnClickListener(View.OnClickListener listener) &#123; this.onClickListener = onClickListener; &#125; @Override public int getItemViewType(int position) &#123; if (emptyView != null &amp;&amp; dataSource.isEmpty() &amp;&amp; !showHeaderFooterWhenEmpty) &#123; return EMPTY_TYPE; &#125; if (position &lt; headers.size()) &#123; return headers.keyAt(position); &#125; int index = position - headers.size(); int viewType; if (dataSource.isEmpty()) &#123; if (emptyView == null) &#123; viewType = footers.keyAt(index); &#125; else if (index == 0) &#123; viewType = EMPTY_TYPE; &#125; else &#123; index = index - 1; viewType = footers.keyAt(index); &#125; &#125; else &#123; if (index &lt; dataSource.size()) &#123; viewType = ITEM_TYPE; &#125; else &#123; index = index - dataSource.size(); viewType = footers.keyAt(index); &#125; &#125; return viewType; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; // empty if (viewType == EMPTY_TYPE) &#123; return new RecyclerView.ViewHolder(emptyView) &#123; &#125;; &#125; // header View view = headers.get(viewType); if (view != null) &#123; return new RecyclerView.ViewHolder(view) &#123; &#125;; &#125; // footer view = footers.get(viewType); if (view != null) &#123; return new RecyclerView.ViewHolder(view) &#123; &#125;; &#125; // item return createItemViewHolder(inflater.inflate(resId, parent, false)); &#125; protected abstract VH createItemViewHolder(View view); @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; if (getItemViewType(position) == ITEM_TYPE) &#123; final int index = position - headers.size(); final T obj = dataSource.get(index); if (onItemClickListener != null) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onItemClickListener.onItemClicked(obj, index); &#125; &#125;); &#125; bindData((VH) holder, dataSource.get(index), index); &#125; &#125; protected abstract void bindData(@NonNull VH h, T obj, int position); @Override public int getItemCount() &#123; if (emptyView != null &amp;&amp; dataSource.isEmpty()) &#123; if (showHeaderFooterWhenEmpty) &#123; return headers.size() + 1 + footers.size(); &#125; else &#123; return 1; &#125; &#125; return headers.size() + dataSource.size() + footers.size(); &#125; @Override public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123; RecyclerView.LayoutManager lm = recyclerView.getLayoutManager(); if (lm instanceof GridLayoutManager) &#123; final GridLayoutManager glm = (GridLayoutManager) lm; glm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; int type = getItemViewType(position); // fix span count for header and footer and empty view if (type == ITEM_TYPE) &#123; return 1; &#125; return glm.getSpanCount(); &#125; &#125;); &#125; &#125; public interface OnItemClickListener&lt;T&gt; &#123; void onItemClicked(T obj, int position); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于软键盘的一些思考]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%B3%E4%BA%8E%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[前言 公司的app大部分的界面都涉及到表单相关内容，所以要考虑软键盘和输入界面之间的协调性，于是在经过一系列的方法实践之后，总结了两种还算是比较和谐的方式。阅读本文前，请你先弄清楚windowSoftInputMode这个属性的作用，这个属性在Window与WindowManager一文中有讲解。 从布局入手 这种方式需要设置activity的windowSoftInputMode为adjustResize。然后通过对activity根布局的变化来知晓软键盘的显示和隐藏。1234567891011121314151617181920212223242526272829303132333435363738394041class KeyBoardInfo( private var rootView: View, var listener: OnKeyBoardHiddenChangeListener?) : ViewTreeObserver.OnGlobalLayoutListener &#123; constructor(rootView: View, keyboardHiddenChanged: (Boolean) -&gt; Unit) : this(rootView, object : OnKeyBoardHiddenChangeListener &#123; override fun onKeyBoardHiddenChanged(hidden: Boolean) &#123; keyboardHiddenChanged(hidden) &#125; &#125;) private val rootViewRect: Rect = Rect() private var rootViewVisibleHeight: Int = 0 init &#123; rootView.viewTreeObserver.addOnGlobalLayoutListener(this) &#125; override fun onGlobalLayout() &#123; rootView.getWindowVisibleDisplayFrame(rootViewRect) val visibleHeight = rootViewRect.height() when &#123; rootViewVisibleHeight == 0 -&gt; rootViewVisibleHeight = visibleHeight rootViewVisibleHeight - visibleHeight &gt; 200 -&gt; &#123; rootViewVisibleHeight = visibleHeight listener?.onKeyBoardHiddenChanged(false) &#125; visibleHeight - rootViewVisibleHeight &gt; 200 -&gt; &#123; rootViewVisibleHeight = visibleHeight listener?.onKeyBoardHiddenChanged(true) &#125; &#125; &#125; fun release() &#123; listener = null &#125; interface OnKeyBoardHiddenChangeListener &#123; fun onKeyBoardHiddenChanged(hidden: Boolean) &#125;&#125; 思路很简单，通过保存最近一次根布局的可视高度，然后和变化后的可是高度进行比较，达到某个差值就认为软键盘的状态发生了变化。 从事件分发入手 这种方式在BaseActivity中重写dispatchTouchEvent()，在ACTION_DOWN的时候查看当前聚焦控件是否需要隐藏软键盘，若需要，则直接隐藏掉。12345678910111213141516171819202122232425262728293031323334override fun dispatchTouchEvent(ev: MotionEvent?): Boolean &#123; when (ev?.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; if (shouldHideKeyboard(currentFocus, ev)) &#123; hideKeyboard(this) whenKeyboardHidden() &#125; &#125; &#125; return super.dispatchTouchEvent(ev)&#125;open fun whenKeyboardHidden() &#123; //todo 软键盘隐藏的时候需要做的时候&#125;fun hideKeyboard(context: Activity) &#123; context.currentFocus?.windowToken?.apply &#123; val service: InputMethodManager? = context.getSystemService(Context.INPUT_METHOD_SERVICE) as? InputMethodManager? service?.hideSoftInputFromWindow(this, InputMethodManager.HIDE_NOT_ALWAYS) &#125;&#125;fun shouldHideKeyboard(currentFocus: View?, event: MotionEvent): Boolean &#123; if (currentFocus == null || currentFocus !is EditText) return false val l = intArrayOf(0, 0) currentFocus.getLocationInWindow(l) val left = l[0] val top = l[1] val bottom = top + currentFocus.height val right = left + currentFocus.width return !(event.x &gt; left &amp;&amp; event.x &lt; right &amp;&amp; event.y &gt; top &amp;&amp; event.y &lt; bottom)&#125; 使用这种方式，请设置windowSoftInputMode为adjustPan。 推荐方式 我们来对比下两者的优缺点。 1. 对于第一种方式，windowSoftInputMode设置为adjustResize的时候，如果布局底部有按钮，那么得根据软键盘的显示和隐藏动态的设置按钮的可视性，这种方式会让用户在视觉上有不协调地方；你可能会说，一样可以设置windowSoftInputMode为adjustPan，但是这样会导致一些表单界面最下面必须将软键盘收起后才能看到，而且需要给最外层控件设置点击事件，在点击之后隐藏软键盘，这样就太麻烦了；其次，现在app一般都会沉浸式状态栏，一般情况下我们会让布局占据状态栏的部分，然后动态设置顶部控件的边距达到这种效果，但是在这种方式下，adjustResize是无效的，也就是说，全屏模式和adjustResize两者是冲突的。但是这种方式也有优点，就是我们可以很方便的知道软键盘何时显示何时隐藏。 2. 对于第二种方式，优点就是在手势触碰的时候，就会隐藏掉软键盘，然后再进行其他的响应。当然它也有缺点，一般软键盘的右上角都有一个收起软件盘的按钮，如果我们通过这个方式去隐藏软键盘，whenKeyboardHidden()方法是不会回调的，这显然就不是我们想要的那种效果。 分析完这两者的利弊之后，我决定将两者结合使用，于是乎就得到了下面的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.guoshujinfu.mobile.gscloud.uiimport android.content.res.Resourcesimport android.graphics.Rectimport android.os.Buildimport android.os.Bundleimport android.support.annotation.CallSuperimport android.support.v7.app.AppCompatActivityimport android.view.MotionEventimport android.view.WindowManagerimport com.guoshujinfu.mobile.gscloud.extension.hideKeyboardimport com.guoshujinfu.mobile.gscloud.extension.shouldHideKeyboardimport com.guoshujinfu.mobile.gscloud.ui.login.LoginActivityimport com.guoshujinfu.mobile.gscloud.utils.ActivityControllerimport com.guoshujinfu.mobile.gscloud.views.dialog.IphoneDialogimport com.guoshujinfu.mobile.gscloud.views.dialog.LoadingDialogimport com.gyf.barlibrary.ImmersionBar/** * @author fxYan */abstract class BaseActivity : AppCompatActivity() &#123; private var latestHeight: Int = 0 private var displayRect: Rect = Rect() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(getLayoutRes()) initComponents(savedInstanceState) &#125; abstract fun getLayoutRes(): Int @CallSuper open fun initComponents(savedInstanceState: Bundle?) &#123; window.decorView.viewTreeObserver.addOnGlobalLayoutListener &#123; window.decorView.getWindowVisibleDisplayFrame(displayRect) val visibleHeight = displayRect.height() when &#123; latestHeight == 0 -&gt; latestHeight = visibleHeight latestHeight - visibleHeight &gt; 200 -&gt; &#123; latestHeight = visibleHeight whenKeyboardShow() &#125; visibleHeight - latestHeight &gt; 200 -&gt; &#123; latestHeight = visibleHeight whenKeyboardHidden() &#125; &#125; &#125; &#125; override fun dispatchTouchEvent(ev: MotionEvent?): Boolean &#123; when (ev?.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; if (shouldHideKeyboard(currentFocus, ev)) &#123; hideKeyboard(this) &#125; &#125; &#125; return super.dispatchTouchEvent(ev) &#125; open fun whenKeyboardShow() &#123;&#125; open fun whenKeyboardHidden() &#123;&#125;&#125; 软键盘的显示和隐藏还是通过监听布局高度的变化来完成，然后再事件分发的时候如果需要隐藏软键盘就先将软键盘给隐藏掉，在进行其他的操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[android arch 学习之LiveData]]></title>
    <url>%2F2018%2F05%2F22%2Fandroid-arch-%E5%AD%A6%E4%B9%A0%E4%B9%8BLiveData%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[你真的了解git config吗]]></title>
    <url>%2F2018%2F05%2F18%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3git-config%E5%90%97%2F</url>
    <content type="text"><![CDATA[前言 记得当时刚使用git的时候，安装完git后就按照别人说的稀里糊涂配置了这些玩意。12$ git config --global user.name "xxx"$ git config --global user.email "xxx" 压根没有想过git config这玩意有没有其他的作用。而最近看完progit这本书后，发现git config的用法还是很多的。这里就记录一些比较常用的。 config文件 git config实际上有三个层级的配置文件，它们分别是： git config –system，在mac上，这个配置文件在/usr/local/git/etc/gitconfig； git config –global，在mac上，这个配置文件在~/.gitconfig； git config –local，这个配置文件是在本地仓库的.git/config。 而当你使用到这些配置属性的时候，git会根据层级来获得这个属性的值，本地仓库下的配置优先级最高，其次是global配置，最后才是system配置。 我们可以看下global文件下配置的属性。 可以看到我们通过git config –global属性配置的user.name和user.email。 不同仓库不同身份 这个很简答，我们只需要通过git config –lobal配置好本地仓库的name和email，然后再生成对应email的ssh key并配置在服务器端就可以了。12$ git config --local user.name "xxx"$ git config --local user.email "xxx" 多个远程仓库 我记得很早之前我有个朋友问我一个问题，说他们的git工作模式是fork，每个人都有一个远程仓库和一个本地仓库，同时也有一个中央仓库，而他想要把代码同时提交到多个远程仓库该怎么弄。 默认情况下，我们clone远程仓库的代码后，local 配置文件下会有一个名为origin的远程仓库别名。 我们只需要通过git remote add xxx repoUrl添加其他的远程仓库就可以了。123$ git remote add another xxxxxx# 移除$ git remote rm another 本地配置文件是这个样子的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[android arch 学习之lifecycle-aware components]]></title>
    <url>%2F2018%2F05%2F17%2Fandroid-arch-%E5%AD%A6%E4%B9%A0%E4%B9%8Blifecycle-aware-components%2F</url>
    <content type="text"><![CDATA[前言 早在去年的时候就看到了Google新发布的arch库，但是当时还是在alpha版本，就没有过多的去关注，现在arch库已经处于稳定的阶段，于是决定好好的学习一下arch库。 原文地址翻墙地址：https://developer.android.com/topic/libraries/architecture/lifecycle国内地址：https://developer.android.google.cn/topic/libraries/architecture/lifecycle 举个栗子 BroadcastReceiver相信大家用的非常多了，当然你说现在EventBus等总线框架这么强大， 基本没自己手写过广播那我就没办法了，但是用法总归是记得的。这里我们编写一个简单的监听电池信息的广播，同时使用动态注册的方式。123456789101112131415161718192021222324252627282930class BatteryReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; if (Intent.ACTION_BATTERY_CHANGED == intent?.action) &#123; //... &#125; &#125;&#125;class BatteryActivity : AppCompatActivity() &#123; private val receiver: BatteryReceiver by lazy &#123; BatteryReceiver() &#125; private val filter: IntentFilter by lazy &#123; IntentFilter(Intent.ACTION_BATTERY_CHANGED) &#125; override fun onResume() &#123; super.onResume() registerReceiver(receiver, filter) &#125; override fun onPause() &#123; super.onPause() unregisterReceiver(receiver) &#125;&#125; 这也是一般情况下我们通用的形式，一旦某个东西需要和生命周期联动，就重写组件的生命周期方法在里面做一些操作，一旦这些操作过多之后就会导致难以管理。于是乎lifecycle-aware Components就这么产生了。先看结果，后续再来详细的分析。123456789101112131415161718192021222324252627282930class BatteryLifecycleObserver( private val context: Context) : LifecycleObserver &#123; private val receiver: BatteryReceiver by lazy &#123; BatteryReceiver() &#125; private val filter: IntentFilter by lazy &#123; IntentFilter(Intent.ACTION_BATTERY_CHANGED) &#125; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun register() &#123; context.registerReceiver(receiver, filter) &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun unregister() &#123; context.unregisterReceiver(receiver) &#125;&#125;class BatteryActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123; super.onCreate(savedInstanceState, persistentState) lifecycle.addObserver(BatteryLifecycleObserver(this)) &#125;&#125; 可以看到我们完全将广播的操作从Activity中抽离出来，而我们需要做的仅仅是在Activity中通过lifecycle成员的addObserver()与BatteryLifecycleObserver进行关联，这样的Activity更加的易于阅读和管理。 Lifecycle 那么Lifecycle是什么呢？ Lifecycle它持有当前所关联的生命周期组件的生命周期状态； 它允许LifecycleObserver对这些生命周期进行监听。 Event 这些枚举值对应生命周期组件的生命周期回调。1234567ON_CREATEON_STARTON_RESUMEON_PAUSEON_STOPON_DESTROYON_ANY ON_CREATE,ON_START,ON_RESUME这些事件关联的方法会在生命周期组件的对应方法之后调用；而ON_PAUSE,ON_STOP,ON_DESTROY这些事件关联的方法会在生命周期组件的对应方法之前调用。(具体你们编写一个测试的项目就知道了，这里我就不粘贴测试相关的代码了) ON_ANY事件所关联的生命周期方法允许定义两个参数，一个是LifecycleOwner，另一个是Lifecycle.EVENT。其他的时间所关联的方法运行定义一个参数Lifecycle，这一点让同一个LifecycleObserver的实例观察不同的LifecycleOwner成为了可能。 State 表示生命周期组件的生命周期状态。123456789INITIALIZEDDESTROYEDCREATEDSTARTEDRESUMEDpublic boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0;&#125; 而State和Event之间的关系我们盗用下官方的图。。 其他方法 除了添加和移除LifecycleObserver外，还允许获取当前生命周期组件的状态。123public abstract void addObserver(@NonNull LifecycleObserver observer);public abstract void removeObserver(@NonNull LifecycleObserver observer);public abstract State getCurrentState(); LifecycleOwner 这是一个只含有一个方法的接口，它的作用实际上就是将Lifecycle从生命周期组件中抽象出来。123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 通常情况下你可以使用LifecycleRegistry来管理生命周期，但是如果你想管理整个application的生命周期，你可以考虑使用ProcessLifecycleOwner。 自定义LifecycleOwner 如果你的support library不低于26.1.0版本，那么SupportActivity默认就是实现了LifecycleOwner接口的，如果你是低于这个版本，那么就需要自己实现LifecycleOwner，前面说了，通常情况下你只要使用LifecycleRegistry就可以了。1234567891011121314151617181920212223public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry mLifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLifecycleRegistry = new LifecycleRegistry(this); mLifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); mLifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125;&#125; LifecycleObserver 这个接口没有任何的方法定义。123public interface LifecycleObserver &#123;&#125; 如果你的项目里面使用的是Java8，那么你完全可以实现DefaultLifecycleObserver即可，因为Java 8支持默认接口实现，如果仍旧使用的是Java7，你可以实现LifecycleObserver接口，并通过OnLifecycleEvent注解来进行编写。1234567891011121314151617181920212223/*Java 8*//** * 如果你出现这个问题 * method in super class are prohibited in JVM target 1.6. Recompile with -jvm-target 1.8 * * 请在build.gradle文件中添加 * kaptOption&#123; jvmTarget = '1.8' * &#125; */class TestObserver implements DefaultLifecycleObserver &#123; @Override public void onCreate(LifecycleOwner owner) &#123; // your code &#125;&#125;/*Java 7*/class TestObserver implements LifecycleObserver &#123; @OnLifecycleEvent(ON_STOP) void onStopped() &#123; // your code &#125;&#125; 源码分析 简单的介绍说完了，如果你只是想停留在如何使用的阶段下面的内容完全可以忽略了。 LifecycleRegistry 这个类继承自Lifecycle，我们可以看到在SupportActivity中就是通过这个类来管理lifecycle的。123public class SupportActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);&#125; 首先我们来看看addObserver()。123456789101112131415161718192021222324252627282930public void addObserver(@NonNull LifecycleObserver observer) &#123; //1. 生成ObserverWithState类 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); //2.当前缓存中存在则返回已存在的，否则添加到缓存，并返回null ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //这种情况是缓存中存在 if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; // 保证observer的前序事件方法都执行 while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; sync(); &#125; mAddingObserverCounter--;&#125; 处理生命周期事件分发的方法是handleLifecycleEvent()，这个方法是在ReportFragment的dispatch()方法中调用的。1234567891011121314private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 我们可以看到实际上处理时间的方法是在sync()中。123456789101112131415161718public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 所以我们还是来看看sync()。1234567891011121314151617181920private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; return; &#125; while (!isSynced()) &#123; mNewEventOccurred = false; //举个栗子，Observer的State是ON_RESUME,现在Activity退到后台，生命周期组件的State变成ON_START，反向迭代调用Observer的事件方法，并更新Observer的State if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); //举个栗子，Observer的State是ON_CREATE,现在Activity走到OnResume，生命周期组件的State变成ON_RESUME，则正序迭代调用Observer的事件方法，并更新Observer的State if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125; backwardPass()和forwardPass()方法的处理逻辑是一样的，只是遍历顺序不一样而已。这里只看关键代码。123456while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState();&#125; 调用给ObserverWithState的dispatchEvent()，而这个方法是调用GenericLifecycleObserver的onStateChanged()方法，里面就会调用到对应的LifecycleObserver，这就是生命周期事件的调用走向。123456void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; ObserverWithState 这是LifecycleRegistry里面定义的静态内部类。12345678910111213141516static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; 那么LifecycleObserver是如何被转换成GenericLifecycleObserver的呢，我们追溯一下Lifecycling的getCallback()方法。123456789101112131415161718192021222324static GenericLifecycleObserver getCallback(Object object) &#123; //... final Class&lt;?&gt; klass = object.getClass(); //这个方法会找GenerateAdapter的type int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; //这里通过createGeneratedAdapter方法获取到GeneratedAdapter GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); //生成GenericLifecycleObserver return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; // 如果是REFLECTIVE_CALLBACK return new ReflectiveGenericLifecycleObserver(object);&#125; 来看看getObserverConstructorType()方法。1234567891011private static int getObserverConstructorType(Class&lt;?&gt; klass) &#123; //1.如果在map中有observer type的缓存，就直接返回 if (sCallbackCache.containsKey(klass)) &#123; return sCallbackCache.get(klass); &#125; //2.如果缓存中没有则调用resolveObserverCallbackType() int type = resolveObserverCallbackType(klass); //3.然后再将其添加到缓存中 sCallbackCache.put(klass, type); return type;&#125; sCallbackCache是一个map，value保存的是class对应的ObserverType。再看这个方法是不是很清晰了。 首先从sCallbackCache缓存中获取ObserverType，如果有则直接返回； 如果没有则调用resolveObserverCallbackType()； 最后再将生成的type存放到sCallbackCache缓存中。 那么resolveObserverCallbackType()又做了什么事情呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344private static int resolveObserverCallbackType(Class&lt;?&gt; klass) &#123; //通过generatedConstructor生成适配器的构造器，典型的适配器模式 Constructor&lt;? extends GeneratedAdapter&gt; constructor = generatedConstructor(klass); if (constructor != null) &#123; //将GeneratedAdapter的构造器存放到缓存中 sClassToAdapters.put(klass, Collections .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor)); return GENERATED_CALLBACK; &#125; // 没有添加apt对应的compiler或者没有任何方法有OnLifecycleEvent注解 // 含有OnLifecycleEvent注解对应的方法 boolean hasLifecycleMethods = ClassesInfoCache.sInstance.hasLifecycleMethods(klass); if (hasLifecycleMethods) &#123; return REFLECTIVE_CALLBACK; &#125; Class&lt;?&gt; superclass = klass.getSuperclass(); List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; adapterConstructors = null; // 如果父类是LifecycleObserver的子类 if (isLifecycleParent(superclass)) &#123; if (getObserverConstructorType(superclass) == REFLECTIVE_CALLBACK) &#123; return REFLECTIVE_CALLBACK; &#125; adapterConstructors = new ArrayList&lt;&gt;(sClassToAdapters.get(superclass)); &#125; // 如果接口实现中有LifecycleObserver for (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123; if (!isLifecycleParent(intrface)) &#123; continue; &#125; if (getObserverConstructorType(intrface) == REFLECTIVE_CALLBACK) &#123; return REFLECTIVE_CALLBACK; &#125; if (adapterConstructors == null) &#123; adapterConstructors = new ArrayList&lt;&gt;(); &#125; adapterConstructors.addAll(sClassToAdapters.get(intrface)); &#125; if (adapterConstructors != null) &#123; sClassToAdapters.put(klass, adapterConstructors); return GENERATED_CALLBACK; &#125;&#125; generatedConstructor()这个方法是生成GeneratedAdapter构造器的。1234567891011121314151617181920212223private static Constructor&lt;? extends GeneratedAdapter&gt; generatedConstructor(Class&lt;?&gt; klass) &#123; try &#123; Package aPackage = klass.getPackage(); String name = klass.getCanonicalName(); final String fullPackage = aPackage != null ? aPackage.getName() : ""; final String adapterName = getAdapterName(fullPackage.isEmpty() ? name : name.substring(fullPackage.length() + 1)); //找packageName.className_LifecycleAdapter类，这个类是由apt在编译的时候生成的。 @SuppressWarnings("unchecked") final Class&lt;? extends GeneratedAdapter&gt; aClass = (Class&lt;? extends GeneratedAdapter&gt;) Class.forName( fullPackage.isEmpty() ? adapterName : fullPackage + "." + adapterName); Constructor&lt;? extends GeneratedAdapter&gt; constructor = aClass.getDeclaredConstructor(klass); if (!constructor.isAccessible()) &#123; constructor.setAccessible(true); &#125; return constructor; &#125; catch (ClassNotFoundException e) &#123; return null; &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125;&#125; 这个类做的事情非常明确，就一件事情，找到apt生成的GenerateAdapter类的constructor。 这里值得说一下，arch库使用的是编译时注解，在编译的时候会对使用了OnLifecycleEvent注解的类自动生成一个ClassName_LifecycleAdapter的类，这个类可以在/app/build/generated/source/apt/packageName下面找到。 什么，你说你没有找到，那你看看是不是没有添加annotationProcessor在build.gradle文件中。12345/*Java*/AnnotationProcessor "android.arch.lifecycle:compiler:1.1.1"/*kotlin*/apply plugin: "kotlin-kapt"kapt "android.arch.lifecycle:compiler:1.1.1" 下面是笔者生成的GenerateAdapter类。123456789101112131415161718192021222324public class BatteryLifecycleObserver_LifecycleAdapter implements GeneratedAdapter &#123; final BatteryLifecycleObserver mReceiver; BatteryLifecycleObserver_LifecycleAdapter(BatteryLifecycleObserver receiver) &#123; this.mReceiver = receiver; &#125; @Override public void callMethods(LifecycleOwner owner, Lifecycle.Event event, boolean onAny, MethodCallsLogger logger) &#123; boolean hasLogger = logger != null; if (event == Lifecycle.Event.ON_RESUME) &#123; if (!hasLogger || logger.approveCall("register", 2)) &#123; mReceiver.register(owner); &#125; return; &#125; if (event == Lifecycle.Event.ON_PAUSE) &#123; if (!hasLogger || logger.approveCall("register", 2)) &#123; mReceiver.unRegister(owner); &#125; return; &#125; &#125;&#125; GenericLifecycleObserver 这个接口继承自LifecycleObserver，提供了一个方法，onStateChanged()。123public interface GenericLifecycleObserver extends LifecycleObserver &#123; void onStateChanged(LifecycleOwner source, Lifecycle.Event event);&#125; SingleGeneratedLifecycleObserver 这个类是GenericLifecycleObserver的子类。12345678910111213141516public class SingleGeneratedAdapterObserver implements GenericLifecycleObserver &#123; // 有一个GeneratedAdapter的成员 private final GeneratedAdapter mGeneratedAdapter; SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123; mGeneratedAdapter = generatedAdapter; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; //非onAny事件 mGeneratedAdapter.callMethods(source, event, false, null); //onAny事件 mGeneratedAdapter.callMethods(source, event, true, null); &#125;&#125; ReflectiveGenericLifecycleObserver 这个类也是GenericLifecycleObserver的子类，如果type是GENERATIVE_CALLBACK，则会使用到这个类。1234567891011121314class ReflectiveGenericLifecycleObserver implements GenericLifecycleObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(LifecycleOwner source, Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; GeneratedAdapter 这也是只有一个方法的接口。123public interface GeneratedAdapter &#123; void callMethods(LifecycleOwner source, Lifecycle.Event event, boolean onAny, MethodCallsLogger logger);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的悬浮窗]]></title>
    <url>%2F2018%2F05%2F07%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%82%AC%E6%B5%AE%E7%AA%97%2F</url>
    <content type="text"><![CDATA[前言 前段时间学习了Window和WindowManager，但是并没有实际的用到它，只是简单的了解了其基本流程和功能，于是想写一个Demo来加深对Window以及WindowManager的理解，就有了这篇文章，写的比较粗糙。 项目地址 AssistiveTouch 实现type的选择 为了让其悬浮在桌面上，它必须有一个System Window的type类型。12345private fun getCompatWindowType(): Int = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#125; else &#123; WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#125; 这里会遇到一个问题，因为在Android6.0之后系统权限的限制，我们需要在6.0之后请求SYSTEM_ALERT_WINDOW权限。这里通过Settings的canDrawOverlays来做兼容处理。123456789101112131415161718192021222324private fun checkCompat() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (Settings.canDrawOverlays(this)) &#123; openFloating() &#125; else &#123; toSettingActivity() &#125; &#125; else &#123; openFloating() &#125;&#125;private fun openFloating() &#123; val intent = Intent(this, AssistiveTouchService::class.java) startService(intent) finish()&#125;@RequiresApi(Build.VERSION_CODES.M)private fun toSettingActivity() &#123; val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION) intent.data = Uri.parse("package:$packageName") startActivity(intent)&#125; 如果没有权限的情况下，通过Intent跳转到设置界面，让用户进行设置。 service 编写一个service，在service中对View进行添加，更新和删除操作，这里不和具体的Activity产生关联，所以onBind()返回null即可。12345678910111213141516171819class AssistiveTouchService : Service() &#123; private val assistiveTouch by lazy &#123; AssistiveTouch(this) &#125; override fun onBind(intent: Intent?): IBinder? &#123; return null &#125; override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int &#123; assistiveTouch.addAssistiveTouch() return super.onStartCommand(intent, flags, startId) &#125; override fun onDestroy() &#123; assistiveTouch.removeAssistiveTouch() super.onDestroy() &#125;&#125; 记得在manifest.xml文件中进行配置。 拖拽和点击 因为要同时设置onTouchListener和onClickListener，我们知道onTouchListener是先于onClickListener的。所以onTouchListener需要返回false，但是这样每次移动之后都会触发onClickListener，所以我添加了一个isMoving的标记。123456789101112131415161718192021222324252627282930assistiveTouch.menuView.setOnTouchListener &#123; _, event -&gt; when (event.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; scrollAnimator?.cancel() downX = event.rawX downY = event.rawY &#125; MotionEvent.ACTION_MOVE -&gt; &#123; val diffX = event.rawX - downX val diffY = event.rawY - downY downX = event.rawX downY = event.rawY lp.x = Math.floor(lp.x + diffX + 0.5).toInt() lp.y = Math.floor(lp.y + diffY + 0.5).toInt() adjustPositionWhenMove() assistiveTouchWindowManager.updateAssistiveTouch(assistiveTouch, lp) isMoving = true &#125; MotionEvent.ACTION_UP -&gt; adjustPositionWhenActionUp() &#125; false&#125;assistiveTouch.menuView.setOnClickListener &#123; if (!isMoving) &#123; assistiveTouch.menuView.visibility = View.GONE assistiveTouch.menuCl.visibility = View.VISIBLE &#125; else &#123; isMoving = false &#125;&#125; 弹性恢复 当拖拽到屏幕中央的时候取消拖拽，需要将View恢复到贴边状态，考虑到柔和，这里使用属性动画的方式进行处理。123456789101112131415161718192021222324252627282930313233private fun adjustPositionWhenActionUp() &#123; val left = lp.x val top = lp.y val right = assistiveTouchWindowManager.windowWidth - menuWidth - left val bottom = assistiveTouchWindowManager.windowHeight - menuHeight - top scrollAnimator = ObjectAnimator() when (mapOf(left to 0, top to 1, right to 2, bottom to 3).minBy &#123; it.key &#125;?.value) &#123; 0 -&gt; &#123; scrollAnimator?.propertyName = "layoutParamsX" scrollAnimator?.duration = left.toLong() scrollAnimator?.setIntValues(left, 0) &#125; 1 -&gt; &#123; scrollAnimator?.propertyName = "layoutParamsY" scrollAnimator?.duration = top.toLong() scrollAnimator?.setIntValues(top, 0) &#125; 2 -&gt; &#123; scrollAnimator?.propertyName = "layoutParamsX" scrollAnimator?.duration = right.toLong() scrollAnimator?.setIntValues(left, assistiveTouchWindowManager.windowWidth - menuWidth) &#125; 3 -&gt; &#123; scrollAnimator?.propertyName = "layoutParamsY" scrollAnimator?.duration = bottom.toLong() scrollAnimator?.setIntValues(top, assistiveTouchWindowManager.windowHeight - menuHeight) &#125; &#125; scrollAnimator?.target = this scrollAnimator?.interpolator = LinearInterpolator() scrollAnimator?.start()&#125; 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活得像最初的模样！]]></content>
  </entry>
  <entry>
    <title><![CDATA[git revert/reset]]></title>
    <url>%2F2018%2F04%2F27%2Fgit-revert-reset%2F</url>
    <content type="text"><![CDATA[前言 你是否也曾遇到版本回退的困扰，是否害怕使用版本回退，每次当错误提交之后，就惊的一身冷汗。很早以前，我就是这样子的。 场景一 提交了一个commit，发现修改了不该修改的内容，怎么办？在现有分支上修改完了之后再次提交？这样无疑是可以的，但是我们可以通过git revert命令优雅的解决这种问题。 提交一个commit 我们在A分支上提交一个commit。123$ vim a.txt$ git add .$ git commit -m "增加a.txt文件" revert最近一次commit 这个时候，我们使用revert命令将这次commit给重置。1$ git revert HEAD revert命令实际上做的事情就是重新生成一个commit覆盖掉之前的那个commit。这个时候git仓库的commit记录是这样的。 提交了多次commit才发现有问题 如果commit之后，你并没有发现问题，同时你又提交了多个commit，突然发现之前的commit有问题怎么办呢。123456789101112$ vim a.txt$ git add .$ git commit -m "增加a.txt文件"$ vim b.txt$ git add .$ git commit -m "增加b.txt文件"$ vim c.txt$ git add .$ git commit -m "增加c.txt文件"$ vim d.txt$ git add .$ git commit -m "增加d.txt文件" 发现a.txt的那次commit是不需要的。这个时候我们找到commit的唯一标识，然后使用revert将其废弃掉。123$ git log$ git revert be6afa6ee5 be6afa6ee5就是a.txt文件对应的commit唯一标识。这个时候git仓库的commit记录是这样的。 找不到parent 有时候你在revert的时候会出现如下的问题。 这个问题产生的原因是你revert的这个commit它是从两个不同的分支merge后产生的。所以它的parent有两个，你在revert的时候它不知道该revert到哪一个parent，所以就报错了。 这个时候你可以通过-m参数来指定你需要revert的parent。1$ git revert HEAD -m 1 上面的命令就表示你需要revert那个执行merge命令的分支。 场景二 一年以前，不是很懂git的我，每次版本上线之后都不会打入tag，也不会给每次上线的版本单独保存一个分支，所以就出现了这样的问题。当出现线上bug的时候，我需要找到上线的commit，然后将HEAD指向那个commit修改bug(当时的我是多么的智障啊，哈哈哈)。 版本上线后提交若干个commit 这里我们提交若干个commit。123456789101112$ vim a.txt$ git add .$ git commit -m "增加a.txt文件"$ vim b.txt$ git add .$ git commit -m "增加b.txt文件"$ vim c.txt$ git add .$ git commit -m "增加c.txt文件"$ vim d.txt$ git add .$ git commit -m "增加d.txt文件" 强制回退 线上出现问题，因为没有tag，也没有具体分支对应发布版本。我就copy了一份代码，然后reset强制回退后修改bug(千万不要学我，一年前的我就是这么做的)。123$ git log$ git reset --hard 01aa54f328 这样就将HEAD强制指向了之前发包的commit。 误操作reset 这尼玛就蛋疼了，你在开发过程中发现自己误操作使用了reset命令。卧槽，git log还没有之前的东西了，怎么办怎么办，大脑一片空白。不要慌不要慌，git还是有记录存在的。1$ git reflog 在我们reset –hard之后使用git log命令来查看得到如下结果。 而我们使用git reflog命令来查看可以得到如下结果。 看到这里我们就知道该怎么做了，我们可以直接通过reset命令再将HEAD指向对应的commit。1$ git reset --hard f06e667 这里千万不要用git reset –hard HEAD~1，因为你现在HEAD之前1个commit是init的那个commit。 无关联覆盖 前段时间，朋友遇到这样的问题。他在使用hexo做静态博客的过程中，repo仓库地址填写错误，导致hexo d命令执行后将原来一个项目的所有文件都被覆盖掉了。 其实解决是十分简单的，我们只需要强制覆盖掉远程仓库的代码就可以了。1$ git push origin -f master 但是我想说的并不是这个，因为这是两个完全没有关联的commit历史，执行pull命令的时候会报错。我们如果要pull远程仓库的代码就需要通过如下的命令了。1git pull origin master --allow-unrelated-histories 还可以这么用 比如你修改了若干个文件，但是你想将这些文件作为两次commit，而你又恰巧执行了git add .命令，这个时候该如何使用git reset命令呢？1234567$ vim a.txt$ vim b.txt$ git add .$ git reset HEAD b.txt$ git commit -m &quot;修改a.txt文件&quot;$ git add .$ git commit -m &quot;修改b.txt文件&quot; git reset命令添加–hard参数之后确实是一个很危险的命令，但是如果你只是使用git reset命令是并不危险的，因为它修改的仅仅是暂存区的内容，而不会修改到你工作目录的文件。 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活得像最初的模样！]]></content>
  </entry>
  <entry>
    <title><![CDATA[git cherry-pick]]></title>
    <url>%2F2018%2F04%2F27%2Fgit-cherry-pick%2F</url>
    <content type="text"><![CDATA[前言 前段时间，有位朋友在群里问了这样一个问题。他们开了两个分支在并行开发两个功能(以下记为A,B)，但是产品突然说A分支上的功能不上线，但是A分支上有部分东西的修改是本次迭代必须的。也就是说出现了需要部分合并的情况，当时我的反应就是使用cherry-pick命令。 举个栗子在A分支上开发功能 我们在A分支上提交若干个commit。123456$ vim a.txt$ git add .$ git commit -m "A分支提交"$ vim b.txt$ git add .$ git commit -m "A分支提交" 在B分支上开发功能 我们在B分支上提交若干个commit。123456$ vim c.txt$ git add.$ git commit -m "B分支提交"$ vim d.txt$ git add .$ git commit -m "B分支提交" 这个时候git仓库的commit记录是这样的。 部分合并 这个时候产品说A分支上的功能这个版本不上线。但是实际上A分支上的第一次commit是本次迭代所必须的。我们需要将其部分合并到B分支，我们需要找到这个commit的唯一标识。12345$ git checkout A$ git log$ git checkout B$ git cherry-pick d3088c71de2 这里的d3088c71de2是在A分支上通过git log命令查找的commit的唯一标识。这个时候我们就完成了将A分支上的功能部分合并到B分支，是不是很神奇呢？我们就可以继续B功能的开发了。 cherry-pick实际上做的事情是将指定的commit复制后拼接在当前分支的commit记录后。 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活得像最初的模样！]]></content>
  </entry>
  <entry>
    <title><![CDATA[git tag]]></title>
    <url>%2F2018%2F04%2F27%2Fgit-tag%2F</url>
    <content type="text"><![CDATA[平常在翻看书籍的时候，是不是经常的使用书签记录当前阅读的地方，方便下次接着阅读。其实，在git中，也有个类似的功能，就是tag。 场景 在手机app开发中，如果你没有使用热修复等功能，那么每次线上出现严重bug需要fix的时候，你就得check出发布的版本，然后修改bug之后发包上线，这是一个很麻烦的操作。 每个人的处理方式不一样，有些人会把每次发版的版本单独做一个分支，这是一个方法。但是版本迭代如此之快，岂不是会有若干个分支存在，你肯定会说，等后续版本发布之后就可以将前面的分支删除掉了。那么，这个时候，倘若产品需要以前的版本你该如何(我还真就遇到过)？ 实际上我们通过tag来管理每个版本十分方便。 举个栗子第一版开发 下面我们开始第一个版本的开发，提交若干个commit。1234567$ vim a.txt$ git add .$ git commit -m "第一次提交"$ vim b.txt$ git add .$ git commit -m "第二次提交"$ git push origin master 这个时候第一个版本迭代完成，我们可以发布上线。在发布上线的时候，我们使用tag记录当前版本最后的commit。123$ git tag --list$ git tag -a v1.0.0 -m "版本1.0.0上线"$ git push origin v1.0.0 这个时候git仓库的commit记录如下。 第二版迭代 发布上线之后，我们开始了第二版的迭代，再提交若干个commit。123456789$ vim c.txt$ git add .$ git commit -m "第二版开发"$ vim d.txt$ git add .$ git commit -m "第二版开发"$ vim a.txt$ git add .$ git commit -m "第二版开发" fix bug 这个时候，由用户反馈某个功能出现问题，需要修复重新打包上线。这个时候我们需要将tag来出来，然后修复bug。1$ git checkout v1.0.0 -b bugfix 这个时候我们将之前tag所对应的commit单独checkout出来为一个分支。然后在这个分支上进行bugfix。123$ vim a.txt$ git add .$ git commit -m "bug fix" 这个时候bug fix完成，然后我们需要将bug fix之后的代码merge到主分支，以保证主分支的代码也是bug fix的。这里a.txt文件是同时修改了，所以会有冲突，如果你知道如何解决冲突，请看git rebase/merge。1234$ git checkout master$ git merge bugfix$ git add .$ git commit -m "v1.0.0bug fix" 这个时候git仓库的commit是这个样子的。 重新打入tag 千万要记住，你bugfix之后要会从新打入tag，防止出现其他的问题。1234$ git checkout bugfix$ git tag --list$ git tag -a v1.0.1 -m "v1.0.1 bug fix"$ git push origin v1.0.1 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活得像最初的模样！]]></content>
  </entry>
  <entry>
    <title><![CDATA[git rebase/merge]]></title>
    <url>%2F2018%2F04%2F27%2Fgit-rebase-merge%2F</url>
    <content type="text"><![CDATA[之前git常用命令是放在一篇文章中的，但是学习的东西越来越多，导致文章的阅读行变差，于是决定将其拆分开。 场景 git rebase和git merge的作用有相似之处，在多分支开发中，经常会碰到分支代码合并的情况，而merge和rebase都可以实现这类需求。 举个栗子创建分支 接下来我们创建两个分支funA和funB。12$ git checkout -b funA$ git checkout -b funB 在A分支产生多次commit记录 然后我们再切回到A分支上，模拟产生多个commit。1234567$ git checkout funA$ vim a.txt$ git add .$ git commit -m "功能A第一次提交"$ vim a.txt$ git add .$ git commit -m "功能A第二次提交" 这个时候A分支上产生了2个commit记录。 在B分支产生多次commit记录 接着我们再切回到B分支上，模拟产生多个commit。1234567$ git checkout funB$ vim b.txt$ git add .$ git commit -m "功能B第一次提交"$ vim b.txt$ git add .$ git commit -m "功能B第二次提交" 这个时候B分支上也产生了2个commit记录。这个时候git仓库的commit记录是这个样子的。 接下来我们保持这个状态然后copy一份文件出来，分别测试git merge和git rebase两个命令。 git merge 我们将funB分支上的代码merge到funA分支上。12$ git checkout funA$ git merge funB merge操作产生了一个新的commit。这个时候git仓库的commit记录是这个样子的。 git rebase 看完了merge，我们再来将funA分支上的代码rebase到funB分支上。12$ git checkout funA$ git rebase funB rebase操作并不像merge操作产生一个新的commit，它会将某个分支上commit都复制一份然后拼接在指定分支后面。这个时候git仓库的commit记录是这个样子的。 冲突 上面只是简单的模拟了一下merge和rebase，但是实际开发过程中，肯定会遇到两个分支修改了相同文件的情况，这个时候我们就需要解决冲突。 git merge 我们来看看如果两个分支修改了相同的文件，在merge的时候会出现什么。 可以看到在终端中提示有冲突，这个时候我们打开a.txt文件进行查看。 这个时候我们需要将冲突的地方解决后重新提交就可以了。 git rebase 而git rebase对于解决冲突来说比merge要稍微复杂一点点。我们在两个分支上修改了同一个文件，然后执行rebase命令，发现终端有如下的提示。 而这个时候不在任何一个分支上，我们可以通过git branch查看当前的分支状态。 正如终端所说，你有两种选择 修改冲突文件，然后使用git rebase –continue继续rebase操作； 使用git rebase –abort终止rebase操作。 我们解决完冲突后，使用git add将修改添加，继续git rebase –continue操作，然后就rebase成功了。 异同 git rebase和git merge都可以将多个分支的commit合并到同一个分支上； rebase操作首先会复制当前分支上的每个commit，然后再拼接到另外的分支上；而merge会生成一个新的commit，它包含了待merge分支的所有commit，然后再拼接到分支上。更加复杂的场景 这里就不赘述了，直接给一张图自行理解提交记录，这里有三个分支master，server，client。 假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经 过更全面的测试。 这时，你就可以使用 git rebase 命令的 –onto 选项，选中在 client 分支里但不在 server 分支里的修改(即 C8 和 C9)，将它们在 master 分支上重放。1$ git rebase --onto master server client 这个命令的意思是:“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然 后把它们在 master 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。 余生没那么长，不要一味的付出去惯哪些得寸进尺的人，请忠于自己，活的像最初的模样~]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-代理模式]]></title>
    <url>%2F2018%2F04%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 前段时间我们分析了kotlin的委托，委托实际上有点类似于静态代理模式，趁着委托的记忆还没有消失(我的记忆力比鱼稍微好一丢丢(理直气壮))，我们来分析下代理模式。 静态代理 静态代理模式中，有3个重要的角色 协议，它抽离了代理类和真实类的共性； 代理类，直接与客户进行交互，在内部访问真实类，但同时又可以对真实类的访问附加额外的操作； 真实类，代理类中真正操作的。 协议 首先我们定义一个抽象接口，它有一个request方法。123interface IBase&#123; fun request() &#125; 真实类 然后，我们定义一个真实类，它实现了协议。12345class BaseImpl:IBase&#123; override fun request()&#123; //...request &#125;&#125; 代理类 最后，我们定义一个代理类，它同样也实现了协议，同时它包含了一个真实类的实例对象。12345678910class BaseImplProxy:IBase&#123; private val baseImpl:BaseImpl by lazy&#123; BaseImpl() &#125; override fun request()&#123; //这里实际调用真实角色的request() baseImpl.request() &#125;&#125; 写到这里，我们发现上面和kotlin的委托是一模一样的原理。但是静态代理中，我们可以在request()中做一些额外的操作。12345678910111213override fun request()&#123; preRequest() baseImpl.request() postRequest()&#125;private fun preRequest()&#123; //...请求前做的事情&#125;private fun postRequest()&#123; //...请求后做的事情&#125; kotlin的委托就不能做这些事情。 动态代理 Java中的动态代理，我们得认识两个玩意，一个是InvocationHandler，一个是Proxy，它们位于reflect包下面。 协议 动态代理中，我们同样需要定义协议。123interface IBase&#123; fun request()&#125; 真实类 然后我们定义一个真实类。1234class BaseImpl : IBase&#123; override fun request()&#123; &#125;&#125; 实现InvocationHandler 然后我们需要实现InvocationHandler接口，里面包含有一个BaseImpl的实例对象。1234567891011class InvocationHandlerImpl : InvocationHandler &#123; private val baseImpl:BaseImpl by lazy&#123; BaseImpl() &#125; override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any? &#123; return method?.invoke(baseImpl, args) &#125;&#125; 创建代理类 一般我们会通过Proxy.newProxyInstance()创建代理类，它接受ClassLoader, Class&lt;?&gt;[]和一个InvocationHandler。12val clazz = IBaseImpl::class.javaval iBase:IBase = Proxy.newProxyInstance(clazz.classLoader, clazz.interfaces, object: InvocationHandlerImpl()&#123;&#125;) as IBase 这样我们通过iBase对象调用request()的时候实际上会被回调到InvocationHandler的invoke()，而我们在invoke()中调用了BaseImpl的request()。 Retrofit的动态代理 我们知道Retrofit里面使用了动态代理模式的。我们可以翻看它的源码，在Retrofit.java文件的create()中我们可以看到有动态代理的调用。12345678910111213141516171819202122public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 比如我们定义如下一个接口请求。12345678interface AdsService &#123; @POST("v4/client/ad/config") fun fetchAdsInfo( @Body reqBean: AdsReqBean ): Single&lt;Response&lt;BaseRespBean&lt;AdsRespBean&gt;&gt;&gt;&#125; 然后通过Retrofit的create()方法，我们就可以得到一个AdsService的代理对象了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Window与WindowManager]]></title>
    <url>%2F2018%2F04%2F16%2FWindow%E4%B8%8EWindowManager%2F</url>
    <content type="text"><![CDATA[前言 日常开发过程中，接触更多的是View，对于Window却没有太多的接触，但实际上View都是通过Window来呈现的，而Window又是被WindowManager所管理的。这篇文章只是简单的介绍Window，WindowManager。 Window Window是一个抽象类，它的唯一实现是PhoneWindow。应用程序的启动流程中会调用ActivityThread的performLaunchActivity()，而在这个方法中会调用Activity的attach()，我们再来看看attach()。123456789101112131415161718192021222324252627282930313233final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; //1.创建PhoneWindow，并设置PhoneWindow的一些属性 mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //2.给PhoneWindow设置WindowManager mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mWindow.setColorMode(info.colorMode);&#125; Activity的attach()中主要做了两件事情 创建PhoneWindow； 给PhoneWindow设置WindowManager DecorView PhoneWindow中有一个成员变量。1private DecorView mDecor; 它是DecorView，它是一个FrameLayout，作为Window的顶层View。那么它是如何被创建的呢，这就要说到Activity的setContentView()了。追随源码。12345678public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125;public Window getWindow() &#123; return mWindow;&#125; getWindow()只是简单的返回了mWindow这个成员，还记得前面的attach()吗，这个方法里面将mWindow初始化为PhoneWindow。也就是说setContentView()实际上调用了PhoneWindow的setContentView()方法。12345678910111213141516171819public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; //1.创建decorView installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //2.将传入的布局文件加载到mContentParent中 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; //...&#125; 接下来我们来看看installDecor()里面做了什么事情。1234567891011121314151617private void installDecor() &#123; if (mDecor == null) &#123; //创建DecorView mDecor = generateDecor(-1); //... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); &#125; else &#123; //... &#125; //...&#125; installDecor()主要干了两件事情。 调用generator()方法创建DecorView； 调用generateLayout()加载布局。 generateDecor()就是创建DecorView。1234protected DecorView generateDecor(int featureId) &#123; //... return new DecorView(context, featureId, this, getAttributes());&#125; 我们再来看看generateLayout()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273protected ViewGroup generateLayout(DecorView decor) &#123; /** * 这里有一大段代码都是在设置属性信息，我就只粘贴关键代码 */ //...省略若干行代码 /** * 这里是根据feature找到加载进DecorView的布局文件 */ int layoutResource; int features = getLocalFeatures(); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; layoutResource = R.layout.screen_simple; &#125; mDecor.startChanging(); //将找到的layoutResource添加到DecorView中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //找到id是android.R.id.content ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; //... return contentParent;&#125; 可以看到这个方法的逻辑非常清晰。 设置属性信息； 根据feature找到layoutResource，用来加载进DecorView； 找到id为android.R.id.content的控件返回，这里就是赋给mContentParent的。 mDecor.onResourcesLoaded()里面就是将layoutResource加载进mDecorView中。1234567891011121314151617181920void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; //... final View root = inflater.inflate(layoutResource, null); //将root添加到DecorView中 if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root; initializeElevation();&#125; PhoneWindow的setContentView()主要做了两件事情 调用installDecor()创建DecorView； 通过LayoutInflater将我们setContentView()传入的布局加载到mContentParent中，也就是android.R.id.content中。 一般结构 这里我看了layoutResource的布局文件，发现大部分的布局都如下图所示。而我们的布局就是被放到这个android.R.id.content布局中的。到这里就差不多了，DecorView就这样加载完毕了。 Callback Window中定义了一个Callback接口，Activity实现了Window.Callback接口，所以Window可以将某些事情交给Activity处理，回调接口里面的方法目前用到的不是很多，以后有用到的时候再来更新下面的方法。12345678910111213141516171819202122232425262728293031//键盘事件分发public boolean dispatchKeyEvent(KeyEvent event);public boolean dispatchKeyShortcutEvent(KeyEvent event);//触摸事件分发public boolean dispatchTouchEvent(MotionEvent event);public boolean dispatchTrackballEvent(MotionEvent event);public boolean dispatchGenericMotionEvent(MotionEvent event);public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);public View onCreatePanelView(int featureId);public boolean onCreatePanelMenu(int featureId, Menu menu);public boolean onPreparePanel(int featureId, View view, Menu menu);//menu打开的时候public boolean onMenuOpened(int featureId, Menu menu);//menuitem 选中的时候public boolean onMenuItemSelected(int featureId, MenuItem item);public void onWindowAttributesChanged(WindowManager.LayoutParams attrs);public void onContentChanged();//Window焦点改变的时候public void onWindowFocusChanged(boolean hasFocus);public void onAttachedToWindow();public void onDetachedFromWindow();public void onPanelClosed(int featureId, Menu menu);public boolean onSearchRequested();public boolean onSearchRequested(SearchEvent searchEvent);public ActionMode onWindowStartingActionMode(ActionMode.Callback callback);public ActionMode onWindowStartingActionMode(ActionMode.Callback callback, int type);public void onActionModeStarted(ActionMode mode);public void onActionModeFinished(ActionMode mode);default public void onProvideKeyboardShortcuts( List&lt;KeyboardShortcutGroup&gt; data, @Nullable Menu menu, int deviceId) &#123; &#125;;default public void onPointerCaptureChanged(boolean hasCapture) &#123; &#125;; WindowManager WindowManager是一个接口，它继承自ViewManager，它的实现类是WindowManagerImpl。 ViewManager十分简单，只有添加，更新和删除三个方法。123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 它的具体实现是在WindowManagerImpl中。12345678910111213141516@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 可以看到WindowManagerImpl中的方法调用都是委托给了mGlobal成员变量，它是WindowManagerGlobal的单例对象。1private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); WINDOW_SERVICE 在前面讲过的attach()中，我们还有一点没有分析，就是调用mWindow的setWindowManager()。这个方法的实现是在Window中。1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125; 我们来看看mContext.getSystemService()是如何获取到WindowManager的。Context的实现类是ContextImpl。1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; SystemServiceRegistry是一个专门管理系统服务的类。1234public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; SYSTEM_SERVICE_FETCHERS是一个HashMap，通过Context.WINDOW_SERVICE可以获取到注册的WindowManagerImpl对象。在SystemServiceRegistry的静态代码块中我们可以找到注册WindowManager的代码。123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() &#123; @Override public WindowManager createService(ContextImpl ctx) &#123; return new WindowManagerImpl(ctx); &#125;&#125;); 通过CachedServiceFetcher的get()我们可以获取到WindowManagerImpl对象。123456789101112131415public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; Object service = cache[mCacheIndex]; if (service == null) &#123; try &#123; service = createService(ctx); cache[mCacheIndex] = service; &#125; catch (ServiceNotFoundException e) &#123; onServiceNotFound(e); &#125; &#125; return (T)service; &#125;&#125; 然后我们再回过头看看Window的setWindowManager()里面的createLocalWindowManager()。123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; 这里创建一个新的WindowManagerImpl，并将PhoneWindow与之关联。 LayoutParams WindowManager中有个重要的内部类，它里面定义了Window的一些重要属性，比如Z-order，window样式等。 type 我们知道Window有很多种，比如Toast，PopupWindow，Dialog，Activity等，在使用手机的过程中经常会看到有很多的Window层叠显示，但是它们必然会存在覆盖关系，也就是说Window在Z轴上是有排列顺序的。而type这个字段实际上表示的是Window在z轴上的排列顺序，也就是我们说的Z-Order，type值越大，Window的显示越靠前。 在LayoutParams中定义了很多的常量，我们可以将Window的分为3类。 Application Window，type值在1-99之间，一般对应着一个Activity； Sub Window，type值在1000-1999之间，一般不能独立存在，需要依附在父Window上，比如Dialog； System Window，type值在2000-2999之间，一般需要声明权限才能够创建。 Application Window的常量定义如下。123456public static final int FIRST_APPLICATION_WINDOW = 1;public static final int TYPE_BASE_APPLICATION = 1;public static final int TYPE_APPLICATION = 2;public static final int TYPE_APPLICATION_STARTING = 3;public static final int TYPE_DRAWN_APPLICATION = 4;public static final int LAST_APPLICATION_WINDOW = 99; Sub Window的常量定义如下。12345678public static final int FIRST_SUB_WINDOW = 1000;public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4;public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;public static final int LAST_SUB_WINDOW = 1999; System Window的常量定义比较多，这里只列举几个，具体的可以在LayoutParam中找到。123456789public static final int FIRST_SYSTEM_WINDOW = 2000;public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;public static final int TYPE_SECURE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+15;public static final int LAST_SYSTEM_WINDOW = 2999; softInputMode 这个东西我们在开发过程中经常用到，比如在manifest.xml文件中的activity中设置windowSoftInputMode属性，这就是在设置softInputMode值。softInputMode会影响两点内容 软键盘的显示状态，state； Window与软键盘之间的交互方式，adjust option。 软键盘的显示状态 softInputMode控制软键盘的显示状态的常量值有如下几种，在LayoutParams中都可以找到。12345678public static final int SOFT_INPUT_MASK_STATE = 0x0f;public static final int SOFT_INPUT_STATE_UNSPECIFIED = 0;public static final int SOFT_INPUT_STATE_UNCHANGED = 1;public static final int SOFT_INPUT_STATE_HIDDEN = 2;public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;public static final int SOFT_INPUT_STATE_VISIBLE = 4;public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5; 下面我们来看看这些常量值会怎样影响软键盘的显示状态。 SOFT_INPUT_STATE_UNSPECIFIED，不设置任何显示状态； SOFT_INPUT_STATE_UNCHANGED，不改变软件盘的显示状态，举个栗子，现在有两个界面A和B，如果A界面的softInputMode设置为stateUnchanged，当你从A界面跳转到B界面再返回A界面的时候，软键盘的显示状态不会发生改变，也就是说，在B界面软件盘如果是显示，那么返回A的时候就是显示的；反之，如果B界面软键盘显示状态是隐藏的，那么返回A的时候就是隐藏的； SOFT_INPUT_STATE_HIDDEN，在合适的时候隐藏软键盘，比如用户导航到界面的时候； SOFT_INPUT_STATE_ALWAYS_HIDDEN，当Window获得焦点的时候总是隐藏软件盘，这个和stateHidden还是有区别的。举个栗子，同样有两个界面A和B，如果A的softInputMode设置的是stateHidden，当第一次导航到A界面的时候软键盘是隐藏的，当从A跳转到B界面，B界面将软键盘显示出来后再返回A界面，这个时候A界面软键盘保持显示状态；但是，如果A界面的softInputMode设置的是stateAlwaysHidden，同样的操作从B返回A界面的时候，软键盘会被隐藏掉； SOFT_INPUT_STATE_VISIBLE，在合适的时候显示软键盘，比如用户导航到界面的时候； SOFT_INPUT_STATE_ALWAYS_VISIBLE，当Window获得焦点的时候总是显示软键盘，这个和stateVisible的区别我就不举栗子了，与stateHidden，stateAlwaysHidden的区别一样。 Window和软键盘的交互方式 softInputMode控制Window和软键盘之间的交互方式的常量值有如下几种，同样定义在LayoutParams中。123456public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;public static final int SOFT_INPUT_ADJUST_PAN = 0x20;public static final int SOFT_INPUT_ADJUST_NOTHING = 0x30; 同样我们再来看看这些常量值会如何影响Window和软键盘之间的交互方式。 SOFT_INPUT_ADJUST_UNSPECIFIED，不指定任何的交互方式； SOFT_INPUT_ADJUST_RESIZE，允许Window改变大小当软键盘显示的时候，这样能够保证Window不被软键盘所遮挡。前方高能，注意，如果Window的flag包含FLAG_FULLSCREEN，那这个值将被忽略，当软键盘显示的时候，Window依旧保持full screen； SOFT_INPUT_ADJUST_PAN，当软键盘显示的时候，设置一个窗口平移。这个值不需要处理Window的大小改变，而只需要通过framework层做一个平移保证当前的输入焦点相对于用户是可见的就可以了； SOFT_INPUT_ADJUST_NOTHING，当软键盘显示的时候不做任何调整。 flag 这个值主要设置的是Window的一些属性。这里列举一些比较有用的flags。123456789101112//隐藏所有的装饰窗口，比如statusbar等public static final int FLAG_FULLSCREEN = 0x00000400;//当前Window在前台会保持屏幕常亮public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;//当前Window允许在锁屏之上显示，大概和那些锁屏软件有关系public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;//当前Window在前台允许进行锁屏操作public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;//模糊所有在Window之下的东西public static final int FLAG_DIM_BEHIND = 0x00000002;//硬件加速public static final int FLAG_HARDWARE_ACCELERATED = 0x01000000; 其他 Window的left, top, right, bottom主要是由Gravity.apply()方法调用计算出来的。除了和Window的width，height有关外，还和以下几个值有关联x, y, verticalMargin, horizontalMargin。1public static void apply(int gravity, int w, int h, Rect container, int xAdj, int yAdj, Rect outRect) 这里的xAdj和yAdj的换算方式我们可以在WinodwState的applyGravityAndUpdateFrame()中找到。123Gravity.apply(mAttrs.gravity, w, h, containingFrame, (int) (x + mAttrs.horizontalMargin * pw), (int) (y + mAttrs.verticalMargin * ph), mFrame); 一般情况下x, y的值就是WindowManager.LayoutParams的x, y。 Window的操作 Window的操作分为添加，更新和删除。对于Window的操作，我们可以分为WindowManager对Window的操作，以及WindowManagerService对Window的操作。 Window的添加 我们来看看系统的StatusBar的添加流程。12345678private void addStatusBarWindow() &#123; //1.创建StatusBar makeStatusBarView(); mStatusBarWindowManager = Dependency.get(StatusBarWindowManager.class); mRemoteInputController = new RemoteInputController(mHeadsUpManager); //2.调用StatusBarWindowManager的add方法 mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight());&#125; 这个方法做了两件事情 makeStatusBarView()来创建StatusBar； 创建StatusBarWindowManager，然后调用其add()。 再来看看StatusBarWindowManager的add()。1234567891011121314151617181920212223242526public void add(View statusBarView, int barHeight) &#123; //1.构建WindowManager.LayoutParams mLp = new WindowManager.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, barHeight, //还记得这个值吗，它是一个SystemWindow类型 WindowManager.LayoutParams.TYPE_STATUS_BAR, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, PixelFormat.TRANSLUCENT); //下面都是设置WindowManager.LayoutParams的一些参数 mLp.token = new Binder(); mLp.gravity = Gravity.TOP; mLp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE; mLp.setTitle("StatusBar"); mLp.packageName = mContext.getPackageName(); mStatusBarView = statusBarView; mBarHeight = barHeight; //2.调用WindowManager的addView() mWindowManager.addView(mStatusBarView, mLp); mLpChanged = new WindowManager.LayoutParams(); mLpChanged.copyFrom(mLp);&#125; 这个方法做的事情也十分的明确 创建WindowManager.LayoutParams的对象，然后设置一些参数； 调用WindowManager的addView()，将StatusBar和LayoutParams对象传入。 前面我们分析过，WindowManager的addView()方法的实现是在WindowManagerImpl类中，但是这个类的方法实现都是委托给WindowManagerGlobal去做的，所以我们只需要查看WindowManagerGlobal的addView()即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //1.校验参数 if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (display == null) &#123; throw new IllegalArgumentException("display must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; //2.如果该Window作为一个子Window，就根据父Window来调整WindowManager.LayoutParams parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; //... //3.创建ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); try &#123; //4.调用ViewRootImpl的setView() root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; 这个方法做了如下事情 首先会校验传入的参数，包括view，Display，LayoutParams； 然后根据LayoutParams的type值以及对Context设置的flag对LayoutParams做不同的调整； 创建ViewRootImpl对象； 调用ViewRootImpl的setView()。 很明显，我们的调用进一步有转给了ViewRootImpl的setView()，因为setView()中的代码比较多，这里我就只写出我们关心的代码片段。12345678public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; //... res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); //...&#125; 可以看到，setView()会调用mWindowSession的addToDisplay()。到这里，WindowManager对Window的添加流程就结束了，后面的流程就通过Session与WindowManagerService进行通信了。 首先mWindowSession是一个IWindowSession的实现类。1final IWindowSession mWindowSession 但是你在framework层搜索不到这个类，因为它是一个aidl文件。在源码库中我们可以找到这个aidl的定义，IWindowSession。这里最终会调用给Session，它是IWindowSession.Stub的实现类，所以我们来看看Session的addToDisplay()。123456public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; 这个方法实际上调用了mService的addWindow()，mService就是WindowManagerService的实例。1final WindowManagerService mService; 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活的像最初的模样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[委托那点事]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%A7%94%E6%89%98%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[前言 本来这篇文章只是想写写kotlin中的lateinit和by lazy之间的区别，但是发现内容太少了，于是乎就想着顺便将我自己对于委托的理解写出来。 属性 kotlin中的属性，天生就带有setter()/getter()方法，比如我们在某个类中定义一个属性1var name:String = "fxyan" 实际上它和下面的代码是等价的。12345var name:String = "fxyan" get() = field set(value)&#123; field = value &#125; 起初我看到这个的时候很纳闷，这个field是什么，其实field就是代表了这个域本身。我们可以通过AndroidStudio的kotlin bytecode工具将字节码反编译成Java文件来揭露它神秘的面纱。1234567891011121314public final class TestClass &#123; @NotNull private String name = ""; @NotNull public final String getName() &#123; return this.name; &#125; public final void setName(@NotNull String value) &#123; Intrinsics.checkParameterIsNotNull(value, "value"); this.name = value; &#125;&#125; lateinit 我们知道，如果一个类里面的某个属性定义成lateinit之后，在使用的时候如果这个属性没有被初始化，就会抛异常，通过上面对属性的讲解，我们不难推出lateinit关键字做了什么事情。1lateinit var name 我们可以看到一个有趣的现象，lateinit关键字修饰的属性不能够自定义getter()/setter()方法。 其实lateinit关键字无非就是重写了name属性的getter()/setter()方法，在里面做了空值的判断，如果为空则抛出异常。这点我们同样可以通过kotlin bytecode工具来查看。12345678910111213141516171819public final class TestClass &#123; @NotNull public String name; @NotNull public final String getName() &#123; String var10000 = this.name; if (this.name == null) &#123; Intrinsics.throwUninitializedPropertyAccessException("name"); &#125; return var10000; &#125; public final void setName(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.name = var1; &#125;&#125; 所以我们可以很明显的知道一点，lateinit关键字不能修饰在可空的属性上，因为setter()方法中会校验，如果为空，则会抛出异常。 委托 下面我们来看看kotlin中的委托 类委托 类委托就是类中定义的方法实际上调用另外一个类的对象的方法。12345678910111213interface IBase &#123; fun print()&#125;class IBaseImpl( var name: String) : IBase &#123; override fun print() &#123; print(name) &#125;&#125;class Delegate(iBase: IBase) : IBase by iBase 我们执行下面的代码。1234fun main(args:Array&lt;String&gt;)&#123; val base:IBase = IBaseImpl("fxyan") Delegate(base).print()&#125; 得到了如下的运行结果。 通过运行结果我们大致上也能猜到它是怎么实现的。下面的代码不是通过反编译出来的，但是反编译出来的和下面的差不多。123456789101112131415161718192021222324252627282930313233343536373839public class DelegateTest &#123; public static void main(String[] args) &#123; IBase iBase = new IBaseImpl("fxyan"); new Delegate(iBase).print(); &#125;&#125;interface IBase &#123; void print();&#125;class IBaseImpl implements IBase &#123; private String name; public IBaseImpl(String name) &#123; this.name = name; &#125; @Override public void print() &#123; System.out.print(this.name); &#125;&#125;class Delegate implements IBase &#123; private IBase iBase; public Delegate(IBase iBase) &#123; this.iBase = iBase; &#125; @Override public void print() &#123; iBase.print(); &#125;&#125; 属性委托 定义一个委托属性很简单，只需要通过by关键字，by关键字后面就是属性委托。1var/val &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; 首先我们先定义一个委托类Delegate123class Delegate&#123;&#125; 然后定义一个类拥有一个委托属性。123class DelegateProperty&#123; var property:String by Deletage()&#125; 编译器报错了，我们需要给Delegate类增加getValue()，setValue()方法。12345678910class Delegate &#123; fun getValue(d: DelegateProperty, p: KProperty&lt;*&gt;): String &#123; return "" &#125; fun setValue(d: DelegateProperty, p: KProperty&lt;*&gt;, newValue: String) &#123; &#125;&#125; 这个时候编译器仍然在报错Delegate类的getValue()，setValue()方法需要添加operator关键字。1234567891011class Delegate &#123; operator fun getValue(d: DelegateProperty, p: KProperty&lt;*&gt;): String &#123; return "$d 对象的$&#123;p.name&#125;属性的getter()被委托给Delegate对象的getValue()" &#125; operator fun setValue(d: DelegateProperty, p: KProperty&lt;*&gt;, newValue: String) &#123; println("$d 对象的$&#123;p.name&#125;属性的setter()被委托给Delegate对象的setValue()") &#125;&#125; 这样一个完整的委托类就编写完了，下面我们来进行一下测试。1234567fun main(args: Array&lt;String&gt;) &#123; val d = DelegateProperty() println(d.property) d.property = "fxyan" print(d.property)&#125; 可以得到如下的运行结果。通过上面一系列的介绍，我们大致上可以推断出，属性委托实际上就是将属性的getter()/setter()方法委托给委托类的getValue()/setValue()。这点我们通过kotlin bytecode工具得到了证实。12345678910111213141516public final class DelegateProperty &#123; @NotNull private final Delegate property$delegate = new Delegate(); static final KProperty[] $$delegatedProperties = new KProperty[]&#123;(KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Reflection.getOrCreateKotlinClass(DelegateProperty.class), "property", "getProperty()Ljava/lang/String;"))&#125;; @NotNull public final String getProperty() &#123; return this.property$delegate.getValue(this, $$delegatedProperties[0]); &#125; public final void setProperty(@NotNull String var1) &#123; Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.property$delegate.setValue(this, $$delegatedProperties[0], var1); &#125;&#125; lazy属性 lazy实际上是一个扩展函数，接受一个lambda表达式作为参数1public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer) 同时我们看看SynchronizedLazyImpl()这个类。12345678910111213141516171819202122232425262728293031323334private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123; private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE private val lock = lock ?: this override val value: T get() &#123; val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T &#125; return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!() _value = typedValue initializer = null typedValue &#125; &#125; &#125; override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet." private fun writeReplace(): Any = InitializedLazyImpl(value)&#125; 我猜想，lazy实际上是在使用的时候调用这个类的get()方法，问了证实我的猜想，我在get()方法中断点了，同时我编写了如下几个类。1234567891011fun main(args: Array&lt;String&gt;) &#123; val d = Delegate() println(d.name) println(d.name)&#125;class Delegate &#123; val name: String by lazy &#123; "" &#125;&#125; 当执行val d = Delegate()这句话的时候并没有调用get()方法，当走到第二句话访问name属性的时候，走到了SynchronizedLazyImpl()类的get()方法，从SynchronizedLazyImpl类中，我们知道，第一次访问name属性的时候，value是一个单例类的对象private object UNINITIALIZED_VALUE。在get()方法中会走下面的分支，并使用lazy传入的lambda表达式赋值给value。123456789101112return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!() _value = typedValue initializer = null typedValue &#125;&#125; 而且我们发现它使用了同步，在多线程中使用lazy也不会发生问题，这一点是值得称赞的。当第二次访问的时候value已经被lambda表达式赋值，所以会走前面的分支。12345val _v1 = _valueif (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T&#125; 至此我们总结下lazy的使用 1. lazy只能修饰val的变量； 2. lazy是线程安全的； 3. 创建对象时，lazy修饰的域不会被初始化，只有第一次访问域的时候会使用lazy后面的lambda表达式进行初始化，之后再访问则直接返回初始化后的值。 Observable属性 这玩意实际上就一观察者，有点类似于Android新出的arch库中的LiveData，但是又没有其功能强大(斜眼笑)。通过Delegate.observable()我们可以创建一个可被观察的属性。123456class ObservableDelegate &#123; var name: String by Delegates.observable("") &#123; _, oldValue, newValue -&gt; println("oldValue is $oldValue, newValue is $newValue") &#125;&#125; 很好理解，每当name属性的值发生变化的时候，都会执行lambda表达式。我们来看看这个方法做了什么事情。1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 它接受一个初始值，和一个lambda表达式。然后我们看看ObservableProperty1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 每当给name属性赋值的时候都会调到这个类的setValue()，在里面检测是否发生了变化，如果变化了就会调用afterChange()，而这个方法在Delegate.observable()里面的实现就是直接调用我们传入的lambda表达式。 余生没那么长，不要一味的付出去惯那些得寸进尺的人，请忠于自己，活的像最初的模样~]]></content>
  </entry>
  <entry>
    <title><![CDATA[视图的载体View]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%A7%86%E5%9B%BE%E7%9A%84%E8%BD%BD%E4%BD%93View%2F</url>
    <content type="text"><![CDATA[什么是View View是屏幕上的一块矩形区域，负责绘制和触摸反馈。 View的生命周期 View中有很多回调方法，它们在View的不同生命周期阶段调用，比较常用的方法有下面这些。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * View在xml文件中加载完成的时候调用 */fun onFinishInflate()/** * View关联的Window可视性发生变化的时候调用 */fun onWindowVisibilityChanged(visibility: Int)/** * View的可视性发生变化的时候调用 */fun onVisibilityChanged(visibility: Int)/** * View关联的Window获取焦点或者失去焦点的时候调用 */fun onWindowFocusChanged(hasWindowFocus: Boolean)/** * View获取焦点或者失去焦点的时候调用 */fun onFocusChanged(gainFocus: Boolean, direction: Int, previouslyFocusedRect: Rect?)/** * 测量View及子View的时候调用 */fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int)/** * 当View的大小发生变化的时候调用 */fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int)/** * 布局View及其子View的时候调用 */fun onLayout(changed: Boolean, w: Int, h: Int, oldw: Int, oldh: Int)/** * 绘制View及其子View的时候调用 */fun onDraw(canvas: Canvas)/** * View被关联到Window的时候调用 */fun onAttachedToWindow()/** * View从Window上分离的时候调用 */fun onDetachedFromWindow()/** * 触摸事件发生的时候调用 */fun onTouchEvent(event: MotionEvent?)/** * 物理按键事件发生的时候调用 */fun onKeyDown(keyCode: Int, event: KeyEvent)/** * 物理按键事件发生的时候调用 */fun onKeyUp(keyCode: Int, event: KeyEvent) 和Activity生命周期的关系 为了研究View生命周期和Activity生命周期之间的关系，我编写了一个CustomView类，下面我们就来看看究竟发生了什么有趣的事情。 onCreate 当Activity创建的时候。 onPause 当Activity退到后台的时候。 onRestart 当Activity从后台进入前台的时候。 onDestroy 当Activity销毁的时候。 有什么作用呢 那我们了解View的这些生命周期方法有什么作用呢？下面我就列举下我们经常遇见的问题。 在Activity中获取View的宽高 你是否也曾经在Activity的onCreate，onResume等方法中获取过View的宽高，是否也同样得到了0的结果。从View的生命周期方法调用我们可以看出，在Activity的onResume方法调用的时候，View还没有完成测量，当然获取到的是0了。我们可以在Activity的onWindowFocusChanged()方法中获取View的宽高。1234567override fun onWindowFocusChanged(hasFocus: Boolean) &#123; super.onWindowFocusChanged(hasFocus) if (hasFocus) &#123; Log.d("Amoryan", "$&#123;customView.width&#125;") Log.d("Amoryan", "$&#123;customView.height&#125;") &#125;&#125; 保存和恢复数据 在Activity的生命周期发生变化的时候，View有可能需要作出相应的相应，比如VideoView需要保存和回复当前进度。12345678override fun onWindowVisibilityChanged(visibility: Int)&#123; super.onWindowVisibilityChanged(visibility) if (visibility == View.VISIBLE)&#123; // Activity Resumed &#125; else &#123; //Activity Paused &#125;&#125; 释放资源 有时候我们需要在View从Window上分离的时候释放一些占用内存的资源，比如Bitmap的回收，线程的释放等。1234override fun onDetachedFromWindow()&#123; super.onDetachedFromWindow() //释放资源&#125; 测量流程 View在做测量的时候，measure()方法会被父控件调用，在measure()方法中调用自身的onMeasure()方法进行实际的测量。 View和ViewGroup的测量是有区别的，View的测量会计算自身的尺寸；但是ViewGroup会先遍历子View的，调用子View的measure()方法，最后再计算自身的尺寸。 ViewGroup的测量 我们打开ViewGroup.java的源码文件，找到measureChildren()。123456789101112protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; //遍历子控件 for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; //如果子控件的Visibility属性不是View.GONE，则进行测量 if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 这个方法做的事情很明确，会遍历子控件，如果子控件的visibility属性不是View.GONE，则调用measureChild()方法。下面我们再来看看measureChild()方法做了什么事情。12345678910111213protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; //获取子控件的LayoutParams final LayoutParams lp = child.getLayoutParams(); //生成子控件width的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); //生成子控件height的MeasureSpec final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); //调用子控件的measure方法进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 从源码可以看出，这个方法做了如下几件事情 1. 会先获取子控件的LayoutParams； 2. 然后根据自身的MeasureSpec，和子控件的LayoutParams计算子控件的MeasureSpec； 3. 最后再调用子控件的measure()方法进行子控件的测量流程。 那么子控件的MeasureSpec是如何生成的呢，下面我们就来看看getChildMeasaureSpec()方法是如何计算的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; //获取ViewGroup的specMode和specSize int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //计算当前能够给予的最大值(父控件给予的值减去ViewGroup的内边距) int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; //根据ViewGroup的MeasureSpec和View的LayoutParams得到View的MeasureSpec case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; //子控件的LayoutParams是具体值 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //子控件的LayoutParams是MATCH_PARENT resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //子控件的LayoutParams是WRAP_CONTENT resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //调用MeasureSpec的makeMeasureSpec方法生成子控件的MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 这个方法的逻辑也十分明了 1. 得到ViewGroup的specMode和specSize； 2. 获取ViewGroup能够给予子View的最大size； 3. 根据ViewGroup的specMode以及子View的LayoutParams得到子View的specMode和specSize； 4. 通过MeasureSpec的makeMeasureSpec()方法生成子View的MeasureSpec。 最后再来看看makeMeasureSpec()方法。1234567public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125; 虽然if-else分支计算的值是一样的，但是我还是好奇的看了看sUseBrokenMakeMeasureSpec这个成员变量。发现在View构造的时候会根据版本修改这个值。1sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1 只是在API17之前使用旧的MeasureSpec计算方式。 View的测量 看完ViewGroup的测量之后，我们再来看看View的onMeasure()方法。1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 来看看getSuggestedMinimumWidth()和getSuggestedMinimumHeight()方法。1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 这个方法只是获取最小的宽度和高度。然后我们来看看getDefaultSize()方法。123456789101112131415161718public static int getDefaultSize(int size, int measureSpec) &#123; //先赋值为最小值 int result = size; //获取specMode和specSize int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); //根据specMode得到最终size，如果MeasureSpec不是UNSPECIFIED，那么最终的size就是ViewGroup能给予的最大size switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 可以看到这个方法会根据specMode得到View最终的size，但但是，AT_MOST表示LayoutParams是WRAP_CONTENT，从源码可以看出，如果设置为WRAP_CONTENT，最终计算的值实际上并不是包裹内容的，而是父控件能够给予的最大值，所所以，这就说明了为什么我们在自定义View的时候需要重写onMeasure方法给出specMode是AT_MOST的时候的实际size的计算方式了。 布局流程 View的布局流程主要是layout()和onLayout()方法，从ViewRootImpl的performLayout()中会调用根View的layout()方法，然后再逐层的遍历，在layout()中传入View的left, top, right, bottom值，并且调用onLayout()进行实际的布局。对于View，因为没有子控件，所以onLayout()什么也不做。12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; layout ViewGroup在onLayout()方法中会调用子View的layout()，告诉子View改如何进行布局。我们先来看看layout()方法做了一些什么事情。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; //先保存之前的left, top, right, bottom int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame()确定View的位置，changed表示View的矩阵是否发生了变化 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //调用onLayout() onLayout(changed, l, t, r, b); //是否需要绘制滚动条 if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; //调用onLayoutChangeListener的方法 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123; mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT; notifyEnterOrExitForAutoFillIfNeeded(true); &#125;&#125; 我们可以看到layout()方法主要做了两件事情 1. 调用setFrame()确定View的四个顶点的位置； 2. 对于ViewGroup，调用onLayout()确定子View的位置。 setFrame12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; //View的矩阵是否发生了变化 if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; int drawn = mPrivateFlags &amp; PFLAG_DRAWN; //View之前的宽高 int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; //父控件传入的宽高 int newWidth = right - left; int newHeight = bottom - top; //尺寸是否发生了变化 boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); invalidate(sizeChanged); //设置View的4个顶点 mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom); mPrivateFlags |= PFLAG_HAS_BOUNDS; //如果View的尺寸发生了变化，则调用sizeChange() if (sizeChanged) &#123; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123; mPrivateFlags |= PFLAG_DRAWN; invalidate(sizeChanged); invalidateParentCaches(); &#125; mPrivateFlags |= drawn; mBackgroundSizeChanged = true; mDefaultFocusHighlightSizeChanged = true; if (mForegroundInfo != null) &#123; mForegroundInfo.mBoundsChanged = true; &#125; notifySubtreeAccessibilityStateChangedIfNeeded(); &#125; return changed;&#125; FrameLayout的onLayout ViewGroup的onLayout()是一个抽象方法，因为不同的ViewGroup有不同的逻辑，这里我们来看看FrameLayout的onLayout()。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); //获取内边距 final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); //遍历子控件 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); //如果子View的visibility属性不是View.GONE if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; //没有设置gravity，则默认为Gravity.LEFT|Gravity.TOP int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; //根据水平Gravity确定子View的left位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL://如果是水平居中 childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT://如果是靠右 if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; //根据垂直Gravity确定View的top位置 switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL://垂直居中 childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; //调用子控件的layout() child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 这个方法实际上做的事情非常简单 1. 它将gravity分为了水平方向和垂直方向； 2. 通过水平方向的gravity计算出子View的left值； 3. 通过垂直方向的gravity计算出View的top值； 4. 最后再调用子View的layout()方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在windows系统中，我们可以发现无论我们如何去开启任务管理器，都只能打开一个窗口，因为每个窗口显示的数据，做的功能都是一样的。我们日常的编码中，经常会遇到这样的情况，某个类希望只存在一个实例，这就需要用到 单例模式了 。 饿汉式 饿汉式单例模式比较简单。1234567891011public class Singleton&#123; private static final Singleton instance = Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 从上面的代码可以看出，在类加载的时候就会创建Singleton的对象。 懒汉式 懒汉式单例模式，就是讲对象的实例化放在使用的时候。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 上面这串代码在单线程里面是能够保证只创建一个对象的。但是放到多线程里面就会出现创建多个对象的情况。所以我们如果要创建一个线程安全的单例，则需要加 synchronized 关键字。1234567891011121314public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是加上同步之后又出现了另外一个性能问题，如果有很多个线程都在请求这个方法，而且这个方法里面要做很多的初始化操作，就会导致其他线程持续等待等情况，下面不使用方法锁的情况，但是需要加双重校验，因为有可能A线程走完第一层的判断后，CPU执行片给了B线程，然后B线程获取锁创建了对象，如果同步代码块里面不添加一层校验就会导致A线程也会创建对象。123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; holder模式 饿汉式没有办法延时加载，而懒汉式的同步在高并发的情况下又会影响性能。那么有没有另外一种方式能够克服这两者的缺点呢？答案肯定是有的。1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Holder.instance; &#125; private static class Holder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类Holder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 Kotlin下的单例模式饿汉式 kotlin下的饿汉式就有意思了，如下就是一个饿汉式的单例模式。1object Singleton 你没有看错，他就是一个饿汉式，我们通过工具可以看到它对应的java代码如下。1234567891011public final class Singleton &#123; public static final Singleton INSTANCE; private Singleton() &#123; INSTANCE = (Singleton)this; &#125; static &#123; new Singleton(); &#125;&#125; 懒汉式 kotlin里面是没有synchronized关键字的，如果要是用同步方法的形式，则需要使用 @Synchronized 注解。而同步代码块的方式是使用 synchronized() 方法。1234567891011121314151617181920class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null fun getSingleton(): Singleton &#123; if (instance == null) &#123; synchronized(Singleton::class.java) &#123; if (instance == null) &#123; instance = Singleton() &#125; &#125; &#125; return instance!! &#125; &#125;&#125; holder方式 再来看看holder方式如何通过kotlin来实现。123456789101112131415class Singleton private constructor() &#123; companion object &#123; fun getSingleton(): Singleton &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance: Singleton = Singleton() &#125;&#125; 毒鸡汤 日子还长，别太失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于ViewPager如何一屏多显]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%85%B3%E4%BA%8EViewPager%E5%A6%82%E4%BD%95%E4%B8%80%E5%B1%8F%E5%A4%9A%E6%98%BE%2F</url>
    <content type="text"><![CDATA[前言 最近项目UI图上有个一屏显示多个Pager的控件，想了想直接通过ViewPager来实现。 实现方式 项目地址 getPageWidth 实际上PagerAdapter里面就提供了实现一屏多显的方法12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 这个方法返回的是 每个Pager的宽度 。然而，他的效果并不是我们想要的。来看看下面这段代码的运行效果。123override fun getPageWidth(position: Int): Float &#123; return 0.8f&#125; 它的效果如下所示，可以看到，默认每个pager都是 局左显示 的。 clipChildren 第二种实现方式就是通过控件的 clipChildren 属性，默认这个属性是true，我们需要将其设置为false，表示超出控件的内容范围也要显示出来。12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#bbbbbb" android:clipChildren="false" android:gravity="center" android:orientation="vertical" tools:context="com.yanfangxiong.multipagerdemo.MainActivity"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="180dp" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:clipChildren="false" android:overScrollMode="never"/&gt;&lt;/LinearLayout&gt; 这里将ViewPager和LinearLayout的clipChildren属性都设置为了false。然后在java代码中做如下设置。123456//设置预加载的数量是3，这个值默认是1viewPager.offscreenPageLimit = 3//pageMargin设置页面之间的距离val metrics = DisplayMetrics()windowManager.defaultDisplay.getMetrics(metrics)viewPager.pageMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 8f, metrics).toInt() 效果图如下所示。 扩展 感觉好像有点单调哈。我也是这么觉得的，那么我们来加点有趣的东西吧。ViewPager有个PageTransformer接口。1234567891011public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ void transformPage(View page, float position);&#125; 这里我就不写研究过程了，position的范围可以分为四段(通用的)，是当前page的左上角相对于ViewPager的位置。 position &lt; -1 -1 &lt;= position &lt; 0 0 &lt;= position &lt; 1 position &gt; 1 ScalePageTransformer 于是乎我写了一个切换尺寸变换的类ScalePageTransformer，如下。123456789101112131415class ScalePageTransformer( private var minScale: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val size = when &#123; position &lt; -1 -&gt; minScale position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minScale + (1 - minScale) * (1 + position) position &lt; 1 -&gt; minScale + (1 - minScale) * (1 - position) else -&gt; minScale &#125; page?.scaleY = size &#125;&#125; 效果图如下，这样就比较有趣了，嗯，我是这么认为的。 RotatePageTransformer 旋转跳跃，我闭着眼~1234567891011121314151617181920212223242526272829303132333435class RotatePageTransformer( private var rotateDegree: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; if (page == null) return val tPivotX: Float val degree: Float when &#123; position &lt; -1 -&gt; &#123; tPivotX = page.width.toFloat() degree = -rotateDegree &#125; position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; &#123; tPivotX = page.width.toFloat() degree = rotateDegree * position &#125; position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; &#123; tPivotX = 0f degree = rotateDegree * position &#125; else -&gt; &#123; tPivotX = 0f degree = rotateDegree &#125; &#125; page.apply &#123; pivotX = tPivotX pivotY = if (rotateDegree &lt; 0) 0f else page.height.toFloat() rotation = degree &#125; &#125;&#125; 来看看这个旋转变换的效果图。 AlphaPageTransformer 再来个透明度变化的吧。123456789101112131415class AlphaPageTransformer( private var minAlpha: Float) : ViewPager.PageTransformer &#123; override fun transformPage(page: View?, position: Float) &#123; val alpha: Float = when &#123; position &lt; -1 -&gt; minAlpha position &gt;= -1 &amp;&amp; position &lt; 0 -&gt; minAlpha + (1 - minAlpha) * (1 + position) position &gt;= 0 &amp;&amp; position &lt; 1 -&gt; minAlpha + (1 - minAlpha) * (1 - position) else -&gt; minAlpha &#125; page?.alpha = alpha &#125;&#125; 效果图如下 毒鸡汤 日子还长，别太失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-抽象工厂]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 不管是简单工厂还是工厂方法，每个工厂都只生产一种产品，而在现实生活中是会存在一个工厂生产多种商品的情况的。比如电器工厂，会生产电视机，电冰箱，空调等。 工厂方法 接下来我们使用工厂方法来实现上面的案例。 定义产品 现在有两种产品，冰箱和空调，有两个厂商(美的和海尔)都能够生产这两种产品。1234567891011121314151617interface IRefrigerator&#123;&#125;class HaierRefrigerator : IRefrigerator&#123;&#125;class MeidiRefrigerator : IRefrigerator&#123;&#125;interface IAirConditioner&#123;&#125;class HaierAirConditioner : IAirConditioner&#123;&#125;class MeidiAirConditioner : IAirConditioner&#123;&#125; 定义工厂 因为每个工厂只生产对应的产品，所以我们需要定义两个工厂接口。1234567891011121314151617181920212223interface IRefrigeratorFactory&#123; fun generateRefrigeratorImpl() : IRefrigerator&#125;class HaierRefrigeratorFactory : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125;class MeidiRefrigerator : IRefrigeratorFactory&#123; override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;interface IAirConditionerFactory&#123; fun generateAirConditionerImpl() : AirConditioner&#125;class HaierAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl() : AirConditioner = HaierAirConditioner()&#125;class MeidiAirConditionerFactory : IAirConditionerFactory&#123; override fun generateAirConditionerImpl(): AirConditioner = MeidiAirConditioner()&#125; 生产产品 比如现在要生产美的的冰箱和空调。1234fun main(args : Array&lt;String&gt;)&#123; val refrigerator = MeidiRefrigeratorFactory().generateRefrigeratorImpl() val airConditioner = MeidiAirConditionerFactory().generateAirConditionerImpl()&#125; 思考 如果有N个产品需要生产，那么就需要扩展N个工厂。一旦工厂的数量变多，在调用的时候就很容易遗漏某些产品的生产，而且类的数量也会多很多，导致结构越来越复杂。 抽象工厂 像美的冰箱，美的空调是由相同的公司生产的，我们可以将其归为一个产品族，抽象工厂可以理解为一个工厂生产一个产品族的产品。现在我们来简化上面的代码。12345678910111213141516interface IFactory&#123; fun generateAirConditionerImpl() : IAirConditioner fun generateRefrigeratorImpl() : IRefrigerator&#125;class MeidiFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = MeidiAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = MeidiRefrigerator()&#125;class HaierFactory : IFactory&#123; override fun generateAirConditionerImpl() : IAirConditioner = HaierAirConditioner() override fun generateRefrigeratorImpl() : IRefrigerator = HaierRefrigerator()&#125; 生产产品 现在工厂定义好了，我们想要生产美的的产品就可以直接通过一个工厂生产了。12345fun main(args : Array&lt;String&gt;)&#123; val factory : IFactory = MeidiFactory() val airConditioner = factory.generateAirConditionerImpl() val refrigerator = factory.generateRefrigeratorImpl()&#125; 如果某个产品族新增加了某个产品，只需要在抽象工厂中新增加生产该产品的方法就可以了，这样就减少了工厂方法会导致的结构复杂性。 毒鸡汤 日子还长，别太失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 在设计模式－简单工厂文章中介绍的简单工厂，我们发现，如果在此基础上新增加一种图表的展示，那么就得修改静态工厂的generateChartImpl()方法。这无疑违反了开放封闭原则。 修改Factory 于是在简单工厂的基础上我定义了一个IChartFactory的接口，如下。12345interface IChartFactory &#123; fun generateChartImpl(): IChart&#125; 拆分Factory 然后将简单工厂的ChartFactory拆分成下面的类，如下。1234567891011121314151617class PieChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = PieChart()&#125;class BarChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = BarChart()&#125;class LinearChartFactory : IChartFactory &#123; override fun generateChartImpl(): IChart = LinearChart()&#125; 测试 使用起来只需要通过对应的Factory创建对应的IChart对象就可以了。如下1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = PieChartFactory().generateChartImpl() chartImpl.display()&#125; 并且我们还发现，如果需要增加一种图表的显示只需要增加IChart的子类和对应的IChartFactory的子类就可以了，而不需要去修改已有的代码，这样就不会违反开闭原则了，而且具有一定的扩展性。 总结 从上面的代码中我们看出，虽然工厂方法能够有很好的扩展性，但是缺点也显而易见，它会导致类的数量越来越多，这样反而会增加系统的复杂度。 毒鸡汤 日子还长，请别失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于京东open-api-sdk的那些坑]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8E%E4%BA%AC%E4%B8%9Copen-api-sdk%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言 近来有位朋友让我用java测试下京东的open-api-sdk的调用，对此记录下在测试过程中遇到的那些坑。 ClassNotFound 于是乎我将sdk下载下来集成到项目中，然后按照文档上的内容编写了下面的代码。12345678910111213141516171819202122WareWriteUpdateWareRequest request = new WareWriteUpdateWareRequest();Ware ware = new Ware();ware.setWareId(/*wareId*/);ware.setTitle(/*title*/);ware.setTransportId(/*transportId*/);request.setWare(ware);JdClient client = new DefaultJdClient( "serverUrl", "accessToken", "appKey", "appSecret");try &#123; WareWriteUpdateWareResponse execute = client.execute(request); if (execute.getSuccess()) &#123; System.out.println("请求成功:" + execute.getMsg()); &#125; else &#123; System.out.println("请求失败:" + execute.getMsg()); &#125;&#125; catch (JdException e) &#123; e.printStackTrace();&#125; 似乎是没有毛病的，然后我运行了代码，得到了下面的结果！你没有看错，wtf，找不到类，什么鬼哦。 NoSuchMethod 然后朋友给我发了一篇博客，按照里面的配置，我修改了项目配置为maven项目，然后添加了如下的依赖。1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.8.11&lt;/version&gt;&lt;/dependency&gt; 本以为这样就没有问题了。但是事不如己愿，哈哈，又出现了下面的问题。 解决 看到这个异常我的第一反应就是open-api-sdk中调用的jar包的版本一定比我配置的要高，于是我在mavenrepository里面搜索了最新的jackson-core-asl和jackson-mapper-asl的jar最新版本，并且修改了pom.xml中的version信息。如下所示：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 然后，我再次运行了代码，得到以下结果。 吐槽 说实话，第一次见到sdk里面使用了三方的jar，但是又不在文档里面说明的，也是服气~ 毒鸡汤 日子还长，别太失望～]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂]]></title>
    <url>%2F2018%2F02%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[前言 之前写代码从来都没有注重设计模式这一块，熟知的并且用的最多的就是单例模式，但是并没有什么卵用，现在项目越来越庞大，每次迭代都要改一堆东西，印象中重复的代码也越来越多，有时候迭代一个版本要改N多个地方的相同代码，如果哪个地方忘了就很蛋疼，但是让我去重构又不知道从何处下手，最近打算将设计模式的东西系统的学习一下，然后将自己写的代码好好的梳理一下。 举个栗子 现在产品经理需要一个图表展示的功能，包括折线图，饼图和柱状图等。于是我写了一个IChart的接口，只有一个display()方法。12345interface IChart &#123; fun display() &#125; 然后编写了几个IChart的子类，如下。1234567891011121314151617181920212223class PieChart : IChart &#123; override fun display() &#123; println("显示饼状图") &#125;&#125;class BarChart : IChart &#123; override fun display() &#123; println("显示柱状图") &#125;&#125;class LinearChart : IChart &#123; override fun display() &#123; println("显示折线图") &#125;&#125; 就这样写好了图表的相关类。然后就是如何根据不同的类型产生不同的类的对象。1234567891011class ChartFactory &#123; fun generateChartImpl(type: String): IChart &#123; return when (type) &#123; "bar" -&gt; BarChart() "linear" -&gt; LinearChart() else -&gt; PieChart() &#125; &#125;&#125; 最后我们来测试一下就可以了。1234fun main(args: Array&lt;String&gt;) &#123; val chartImpl = ChartFactory.generateChartImpl("linear") chartImpl.display()&#125; 运行结果如下所示，这就是简单的工厂模式。 毒鸡汤 日子还长，请别失望～]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac插入U盘的只读问题]]></title>
    <url>%2F2018%2F02%2F21%2Fmac%E6%8F%92%E5%85%A5U%E7%9B%98%E7%9A%84%E5%8F%AA%E8%AF%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 最近帮我舅舅重装系统，因为要将我电脑上的系统镜像复制到U盘中， 然后发现我只能读取U盘里面的文件，而不能进行写入操作。 U盘文件系统格式 想要解决这个问题，首先你得了解U盘的文件系统格式。于是我将U盘插在windows电脑上进行格式化的时候，发现格式化的种类有3种，NTFS ， FAT32 ， exFAT 。那么我们来看看这几种格式的区别。 这里推荐一款免费的软件 Mounty11 。它支持在mac读写NTFS文件系统格式的U盘。 NTFS 它全称New Technology File System(新技术文件系统)。支持LZ77压缩、文件级加密、访问控制。主文件表(MFT)负责存储稳健的属性、位置、访问信息。这种格式在mac如果不使用工具是无法写入文件的，当然它还有一些弊端，比如最大分区，最大文件只支持2TB，（日常够用了）兼容范围不如FAT32，长时间使用会影响U盘寿命。所以这种文件系统格式肯定不是我们要的。 FAT32 它是1997年的Windows 95 OSR2，在第二版系统中首次引入的文件系统格式。 它有很好的兼容性，几乎所有主流系统都能对其格式写入读取 。既然有这么好的兼容性，那我们是不是就直接将U盘格式化为FAT32就可以了。当然不是，这种文件系统虽然有很好的兼容性，却有很多的弊端。 这种文件格式安全无保障，对于单个的文件移动，体积不能超过4G，并且文件名称长度不能超过255个字节 ，所以这不是最好的选择。 exFAT 微软专门为闪存设备设计的文件系统，高容量的SDXC卡默认都是这种格式。文件名最高可达65536个，分区和单个文件支持最大可达到16EB，写读取速度稳定。最主要的是它在mac和windows之间都可以进行读写操作。 解决 最终我并没有选择使用第三方工具在mac进行读写NTFS的U盘，而是将U盘格式化为exFAT的格式，然后再将文件拖放到U盘中，再制作启动盘。 总结 如果只是简单的拖放小文件，你完全可以选择使用FAT32文件系统格式，如果需要拖放大文件则可以考虑使用NTFS或者exFAT，当然不建议使用NTFS，因为它对U盘的使用寿命有影响。 毒鸡汤 日子还长，请别失望~ 祝大家新年快乐]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于迅雷下载BT出现的版权方问题]]></title>
    <url>%2F2018%2F02%2F13%2F%E5%85%B3%E4%BA%8E%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BDBT%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%88%E6%9D%83%E6%96%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 2月11号的动车从杭州回家，于是我为了打发在车上的5个多小时时间，2月10号的晚上准备下载一些电影在动车上看。当然是以前看过了的电影，哈哈。于是在google上搜索了速度与激情8和机器之血的BT文件，正当我准备通过迅雷下载这些文件的时候，发现任务的右下角显示 应版权方要求，该资源无法下载 。 WTF！！！ 原因 这个原因是版权方和迅雷交涉后，迅雷通过技术阻止了文件的下载。看到这里忍不住爆了一句粗口，mmp。 解决方案 作为一个程序猿怎么能够被这种问题影响而不看电影，是吧。于是我上google搜索了一些解决方案，找到了一个比较好的方法。 准备工作 首先你得有一个 百度网盘账号 ，因为接下来我们准备通过百度网盘来进行下载这些文件。 获取BT文件的下载地址 获取这个地址的方式比较简单，你只需要在迅雷的下载任务列表选择一个无法下载的文件，然后右键 复制文件下载链接 就可以了。 建立离线下载任务 然后，你就可以登录百度网盘，新建离线下载任务。如下图所示。 然后选择新建链接任务，将在迅雷上复制的链接粘贴上去，建立任务就可以了。 通过百度云盘app进行文件下载 最后你只需要通过百度云盘的app进行文件下载就可以了。 毒鸡汤 日子还长，请别失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[当Kotlin遇上Parcelable]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%BD%93Kotlin%E9%81%87%E4%B8%8AParcelable%2F</url>
    <content type="text"><![CDATA[由来 因为现在项目里面都是用 kotlin 在编写项目，在跨界面传递数据的时候经常需要传递对象数据，这就需要使用到 对象的序列化 ，就难免和 Parcelable 打交道。 序列化的方式 在Android中，对象的序列化方式是有两种的，一种是Java中的 Serializable ，一种是Android特有的 Parcelable 。既然Google新增加了一种 Parcelable 的方式，那必然有它的道理，我们先来看看两者有啥不可告人的秘密。 Serializable的序列化方式 这种序列化方式给我们的第一印象就是 简洁 。因为你只需要实现 Serializable 接口就可以了。这是一个标识接口，你不需要实现任何方法，Java就会对其进行序列化操作。但但但是，这种序列化的方式使用了 反射，而且在序列化过程中产生很多的临时对象，造成过多的内存消耗 。1234567891011package com.yanfangxiong.kotlinparcelabledemoimport java.io.Serializable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Serializable Parcelable的序列化方式 这种序列化方式是Android所特有的。而且使用起来 比较复杂 ，我们先来举个栗子。12345678910111213141516171819202122232425262728293031323334353637package com.yanfangxiong.kotlinparcelabledemoimport android.os.Parcelimport android.os.Parcelable/** * @author fxYan */data class Person( var name: String?, var sex: String?) : Parcelable &#123; companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(parcel: Parcel, flags: Int) &#123; parcel.writeString(name) parcel.writeString(sex) &#125; override fun describeContents(): Int &#123; return 0 &#125;&#125; 详解Parcelable writeToParcel() 通过这个方法你可以将对象的属性都写入到parcel中； describeContents() 这个方法一般情况下默认就好了。关于这个方法，API中是这么描述的，它表示这个Parcelable对象序列化内容的类别。举个栗子，如果你要序列化对象里面包含文件描述符，那么你需要将这个方法修改为返回 CONTENTS_FILE_DESCRIPTOR ； 编写一个类CREATOR继承自 Parcelable.Cretor ，这个接口包含两个方法，createFromParcel()从Parcel容器中值，newArray()这个方法是 供外部类反序列化本类数组使用的 。 从上面的代码我们就可以看出，如何序列化这个对象已经非常清楚的表现出来，根本不需要通过反射来知道来推断类型，所以能够更加高效的序列化对象。 区别与抉择 Serializable实现方式简单，但是比较消耗内存，一般建议在序列化对象保存到文件中的时候使用； Parcelable实现方式较为复杂，但是效率高，消耗内存小，在代码中建议使用这种方式。 问题所在 我们知道，在kotlin中伴生对象只能存在一个 ，一般一些在java中的静态常量我们可能会定义在伴生对象中，但是我们可以看上面的Person的Parcelable实现，系统默认给我们创建的CREATOR对象就直接指定为了伴生对象，这样虽然是没有问题的，但是你定义的一些常量就是属于CREATOR对象了，实际上这是不必要的，所以我们需要一种方式将伴生对象 “释放” 出来。 这里我们就直接上代码了。只需要使用 ＠JVMField 注解就可以解决这个问题。12345678910111213141516companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = object : Parcelable.Creator&lt;Person&gt; &#123; override fun createFromParcel(parcel: Parcel): Person &#123; return Person(parcel) &#125; override fun newArray(size: Int): Array&lt;Person?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 但但但是，前面说了，使用Parcelable的序列化方式，类里面的方法会增加很多，所以我们打算来优化优化。 首先，kotlin像java 8一样，接口中的方法可以有默认的实现 ，于是我决定写一个KParcelable的接口，如下12345interface KParcelable : Parcelable &#123; override fun describeContents() = 0 override fun writeToParcel(dest: Parcel, flags: Int)&#125; 这样就减少了对象中的 describeContents 方法的实现。然后我们再来优化CREATOR的实现方式。对此我写了下面的函数123456inline fun &lt;reified T&gt; parcelableCreator(crossinline creator: (Parcel) -&gt; T) = object : Parcelable.Creator&lt;T&gt; &#123; override fun createFromParcel(source: Parcel): T = creator(source) override fun newArray(size: Int): Array&lt;T?&gt; = arrayOfNulls(size) &#125; 它接受一个名为 creator 的方法，然后返回一个 Parcelable.Creator 的实现类，这样我的Person类就可以简化为如下的方式。12345678910111213141516171819202122data class Person( var name: String?, var sex: String?) : KParcelable &#123; companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;Person&gt; = parcelableCreator(::Person) &#125; constructor(parcel: Parcel) : this( parcel.readString(), parcel.readString()) override fun writeToParcel(dest: Parcel, flags: Int) = with(dest) &#123; writeString(name) writeString(sex) &#125;&#125; 这样看着就舒服多了，哈哈哈。 毒鸡汤 生活不如意时是上帝给你放的长假～]]></content>
  </entry>
  <entry>
    <title><![CDATA[Camera的使用]]></title>
    <url>%2F2018%2F01%2F10%2FCamera%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介 Android的framework支持通过android.hardware.camera2API或者是过时的Camera来拍摄图片和视频。这篇文章讲解的是Camera的使用，后续会写一篇关于camera2使用的文章。当然，如果你等不及的话可以去看看google博客关于camera2的文章，camera2文章地址，请翻墙查看。 基础 android.hardware.camera2，这个包是控制设备相机的主要API，它可以被用来拍摄图片或者视频当你想构建一个相机app的时候； Camera，这个类也是用来控制设备相机的，但是在API21之后过时了； SurfaceView，这个类用来给用户呈现相机的预览； MediaRecorder，这个类通过相机来录制视频； Intent，如果你的目的仅仅只是简单的拍摄一张图片或者一段视频，你完全可以调用系统的相机让它来完成这些事情，而不需要直接操控系统相机。你可以使用MediaStore.ACTION_IMAGE_CAPTURE来调用系统相机来拍摄图片，或者通过MediaStore.ACTION_VIDEO_CAPTURE来调用系统相机来拍摄视频。 Manifest声明 当你使用Camera API进行开发的时候，你必须确保你的manifest文件中声明了相关的东西。 Camera Permission，当app需要使用设备相机的时候必须声明这个权限 1&lt;uses-permission android:name="android.permission.CAMERA" /&gt; Camera Features，同时得声明使用相机相关的特性，比如。关于camera features的列表，可以查看Features Reference。添加camera features到manifest文件中会导致Google Play防止你的应用安装在那些没有相机或者是不支持相机特性的设备上。如果你的app并不是一定需要camera，你可以在manifest中通过 android:required 来指定。 1&lt;uses-permission android:name="android.hardware.camera" android:required="false" /&gt; Storage Permission，如果应用程序需要将图片或者视频保存到external storage中，还需要声明这个权限； 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; Audio Recording Permission，视频录制的过程中还需要录制音频，所以得添加音频录制的权限，音频录制在之前的文章中已经讲过，不懂的可以去 Android录制系列之音频录制进行查阅； 1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; Location Permission，如果app需要给图片打上GPS定位信息的tag，你需要申请 ACCESS_FINE_LOCATION 权限，这里需要注意，Android5.0及以上版本需要声明使用设备的GPS； 123&lt;uses-permission android:name ="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;!-- targetSdkVersion &gt;= 21 的需要添加 --&gt;&lt;uses-feature android:name="android.hardware.location.gps" /&gt; 如何使用访问相机 检索并访问相机，如果你的app没有在manifest文件中声明是否只能安装在有相机的设备上，那么在使用之前，请检测设备是否有相机的硬件支持。1fun hasFeatureCamera(context: Context) = context.packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) Android2.3 之后你可以直接通过 Camera.getNumberOfCameras() 方法直接获取到设备上可用的相机数量。如果你非常清楚你app运行在有相机支持的设备上运行时，你可以直接通过 Camera.open() 方法去请求并获取一个Camera的实例，它会 访问设备上的第一个后置摄像头。12345678910fun getCamera(): Camera? &#123; var camera: Camera? = null try &#123; camera = Camera.open() &#125; catch (e: Exception) &#123; //如果不捕获异常，相机在被其他的app使用，或者设备上根本没有相机的时候，就会导致app crash Log.d("Amoryan", "open camera error!") &#125; return camera&#125; Android 2.3 之后你可以通过 Camera.open(int) 访问指定的相机。比如，你可以这么玩。123456789101112131415fun getCameraInfo() &#123; try &#123; for (i in 0 until Camera.getNumberOfCameras()) &#123; val cameraInfo: Camera.CameraInfo = Camera.CameraInfo() Camera.getCameraInfo(i, cameraInfo) if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; Log.d("Amoryan", "$i is back facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; else &#123; Log.d("Amoryan", "$i is front facing,orientation is $&#123;cameraInfo.orientation&#125;") &#125; &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125;&#125; 设置预览 设置预览界面，你可以直接使用SurfaceView，或写一个SurfaceView的子类，然后实现SurfaceHolder.Callback的相关回调，这里我为了方便起见，直接在布局文件中使用SurfaceView了12345678&lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; 然后实现相对应的回调接口12345678910111213141516171819class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; &#125;&#125; 拍摄图片 通过 takePicture 方法拍摄图片，这里只是简单的将拍摄的图片显示在ImageView上了。1234567891011captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125;private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125;&#125; 释放Camera Camera是设备上的共享资源，当app获取到Camera的实例后就可以使用它，但是在app不需要Camera或者当界面变得不可见的时候应该正确的释放。举个栗子，当界面变得不可见的时候，如果你没有正确的释放掉资源，就会导致接下来想要访问Camera的app获取失败，而没办法正常工作。12345override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null&#125; 完整代码 github项目地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.yanfangxiong.camerademoimport android.Manifestimport android.content.pm.PackageManagerimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.hardware.Cameraimport android.os.Bundleimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.view.SurfaceHolderimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity(), SurfaceHolder.Callback &#123; companion object &#123; val REQUEST_CAMERA_PERMISSION = 1 &#125; private var camera: Camera? = null private var bitmap: Bitmap? = null private val pictureCallback = Camera.PictureCallback &#123; data, camera -&gt; data?.apply &#123; releaseBitmap() bitmap = BitmapFactory.decodeByteArray(this, 0, this.size) previewImage.setImageBitmap(bitmap) camera?.safeStopPreview() setupCamera() &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) surfaceView.holder.addCallback(this) captureTv.setOnClickListener &#123; camera?.safeTakePicture(null, null, pictureCallback) &#125; &#125; private fun checkCameraPermission() &#123; val cameraPermissionStatus = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) if (cameraPermissionStatus == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; &#125; private fun openCamera() &#123; camera = safeOpenCamera() setupCamera() &#125; private fun setupCamera() &#123; camera?.apply &#123; setDisplayOrientation(90) setPreviewDisplay(surfaceView.holder) safeStartPreview() &#125; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; if (camera == null) &#123; checkCameraPermission() &#125; else &#123; setupCamera() &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; camera?.safeStopPreview() setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun onPause() &#123; super.onPause() camera?.safeRelease() camera = null &#125; private fun releaseBitmap() &#123; bitmap?.recycle() bitmap = null &#125;&#125; 毒鸡汤 人生不如意的时候是上帝给的长假。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之视频录制]]></title>
    <url>%2F2018%2F01%2F09%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 视频录制使用的是 Camera 和前面讲过的 MediaRecorder。在视频录制的过程中你需要通过 Camera.unlock() 和 Camera.lock() 方法来允许MediaRecorder来访问硬件相机。和使用 Camera 拍摄图片不一样，拍摄视频有 严格的调用顺序。 如何使用 接下来我们就来看看该怎么玩这个玩意。 获取Camera 首先我们得获取到 Camera 。获取相机的方式这里就不在过多的说明了，如果你还是不知道可以去查看我的另外一个文章 Camera的使用。 设置预览界面 这里使用的是SurfaceView，你也可以去查看Camera的使用这篇文章。1234567891011121314151617181920212223242526override fun onCreate(savedInstanceState: Bundle?) &#123; //... surfaceView.holder.addCallback(this) //...&#125;override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera()&#125;override fun surfaceDestroyed(holder: SurfaceHolder?) &#123;&#125;override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission()&#125; 开始录制 相机的准备工作做好之后就可以开始录制了。 通过 Camera.unlock() 允许MediaRecorder访问Camera； 通过 MediaRecorder.setCamera() 将MediaRecorder和Camera关联； 设置音频源，通过 MediaRecorder.setAudioSource() 设置音频源为 MediaRecorder.AudioSource.CAMCORDER； 设置视频源，通过 MediaRecorder.setVideoSource() 设置视频源为 MediaRecorder.VideoSource.CAMERA； 设置输出格式和编码方式，不过在 Android2.2 之后你就可以通过 MediaRecorder.setProfile() 方法来设置一个录制视频的配置； 通过 MediaRecorder.setOutputFile() 设置录制视频后保存的文件路径； 通过 MediaRecorder.setPreviewDisplay() 设置预览界面是SurfaceView； 经过以上的配置之后MediaRecorder就已经准备完成，之后你就可以调用 MediaRecorder.prepare() 表示你已经准备完成了； 通过 MediaRecorder.start() 开始录制； 停止录制 当你录制完成之后，也需要正确的释放资源。 通过 MediaRecorder.stop() 停止当前的录制； 通过 MediaRecorder.reset() 重置当前的MediaRecorder配置，以便之后其他app的使用； 通过 MediaRecorder.release() 将MediaRecorder释放； 通过 Camera.lock() 将相机资源锁住，方便其他的app进行使用； 通过 Camera.stopPreview() 停止相机的预览； 通过 Camera.release() 释放相机的资源，方便其他的app进行使用。 小技巧 如果你使用Camera来录制视频，你可以通过 setRecordingHint() 在开启预览前设置为true，这个方法能够减少开始录制的时间。 项目地址 github项目地址 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package com.yanfangxiong.mediarecorderdemoimport android.Manifestimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.hardware.Cameraimport android.media.CamcorderProfileimport android.media.MediaRecorderimport android.os.Bundleimport android.os.Environmentimport android.support.v4.app.ActivityCompatimport android.support.v7.app.AppCompatActivityimport android.util.Logimport android.view.SurfaceHolderimport android.view.Viewimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_video_recorder.*import java.io.File/** * @author fxYan */class VideoRecorderActivity : AppCompatActivity(), View.OnClickListener, SurfaceHolder.Callback &#123; companion object &#123; const val REQUEST_CAMERA_PERMISSION = 1 const val REQUEST_RECORD_AUDIO_PERMISSION = 2 fun jumpToActivity(context: Context) &#123; val intent = Intent(context, VideoRecorderActivity::class.java) val queryIntentActivities = context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY) if (queryIntentActivities != null &amp;&amp; queryIntentActivities.isNotEmpty()) &#123; context.startActivity(intent) &#125; &#125; &#125; private var camera: Camera? = null private var mediaRecorder: MediaRecorder? = null private var isRecording = false override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_video_recorder) surfaceView.holder.addCallback(this) controlIv.setOnClickListener(this) &#125; override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.controlIv -&gt; &#123; if (camera == null) &#123; return &#125; if (isRecording) &#123; //如果在录制中 try &#123; mediaRecorder?.stop() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop media recorder error!") &#125; releaseMediaRecorder() &#125; else &#123; //开启录制 checkRecordAudioPermission() &#125; &#125; &#125; &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; try &#123; camera?.stopPreview() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "stop preview error!") releaseCamera() &#125; setupCamera() &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; checkCameraPermission() &#125; private fun checkCameraPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED -&gt; &#123; openCamera() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION) &#125; &#125; &#125; private fun checkRecordAudioPermission() &#123; when &#123; ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -&gt; &#123; startRecord() &#125; else -&gt; &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION) &#125; &#125; &#125; private fun openCamera() &#123; try &#123; camera = Camera.open() setupCamera() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "open camera error!") &#125; &#125; private fun setupCamera() &#123; try &#123; camera?.apply &#123; parameters.focusMode = Camera.Parameters.FOCUS_MODE_AUTO setPreviewDisplay(surfaceView.holder) setDisplayOrientation(90) startPreview() autoFocus(null) &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "set up camera error!") releaseCamera() &#125; &#125; private fun releaseCamera() &#123; try &#123; camera?.stopPreview() camera?.release() &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release camera error!") &#125; camera = null &#125; private fun startRecord() &#123; try &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; reset() camera?.unlock() setCamera(camera) setAudioSource(MediaRecorder.AudioSource.CAMCORDER) setVideoSource(MediaRecorder.VideoSource.CAMERA) setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_1080P)) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "videoRecorder.mp4") setOutputFile(file.absolutePath) setPreviewDisplay(surfaceView.holder.surface) prepare() start() isRecording = true Toast.makeText(this@VideoRecorderActivity, "开启录制...", Toast.LENGTH_SHORT).show() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "mediaRecorder error!") releaseMediaRecorder() &#125; &#125; private fun releaseMediaRecorder() &#123; try &#123; mediaRecorder?.apply &#123; reset() release() &#125; &#125; catch (e: Exception) &#123; Log.d("Amoryan", "release media recorder error!") &#125; camera?.lock() mediaRecorder = null isRecording = false &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CAMERA_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCamera() &#125; else if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecord() &#125; &#125; override fun onPause() &#123; super.onPause() releaseMediaRecorder() releaseCamera() &#125;&#125; 毒鸡汤 走过一些弯路，也好过原地踏步～]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android录制系列之音频录制]]></title>
    <url>%2F2018%2F01%2F06%2FAndroid%E5%BD%95%E5%88%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介 Android的多媒体框架包含并支持录制和解码多种多样的音视频格式。如果设备支持，你可以使用MediaRecorder来进行这些操作。( Android模拟器无法录制音频 ) MediaRecorder的使用权限 如果你想进行音频录制，你必须添加RECORDER_AUDIO的权限，这是一个 危险权限 ，如果你不知道如何请求权限，你可以查看之前的一篇文章 Android运行时权限的处理。1&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt; 配置MediaRecorder 配置一个MediaRecorder你只需要简单的几步就可以了。 首先，我们得创建一个 MediaRecorder 的实例对象； 1val mediaRecorder = MediaRecorder() 通过 setAudioSource() 方法设置音频源，音频源的取值你可以直接查看 MediaRecorder.AudioSource，一般情况下我们会选择 MIC 也就是麦克风作为音频源； 1mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC) 通过 setOutputFormat() 方法设置输出格式，输出格式的取值你可以直接查看 MediaRecorder.OutputFormat； 1mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) 通过 setAudioEncoder() 方法设置音频解码方式，解码方式的取值你可以直接查看 MediaRecorder.AudioEncoder 1mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC) 通过 setOutputFile() 方法设置保存文件的路径， 12val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "audioRecorder.3gp")mediaRecorder.setOutputFile(file.absolutePath) 完成初始化配置后，你就可以调用 prepare()方法 ；然后调用 start() 你就可以开始录制了。 12mediaRecorder.prepare()mediaRecorder.start() 值得注意的 大部分(包括DEFAULT)的音频源 都会对音频信号做处理 ，如果你想录制原始的音频，你可以选择MediaRecorder.AudioSource.UNPROCESSED(当然你也可以选择AudioRecorder这个更接近底层的类，后面会找时间写一篇关于AudioRecorder录制的文章)。 有些设备是不支持录制未处理的音频，你可以通过下面的这种方式来获取设备是否支持录制原始音频。1234567val audioManager: AudioManager? = getSystemService(Context.AUDIO_SERVICE) as? AudioManagervar isSupportedRawAudioInput = "false"audioManager?.apply &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; isSupportedRawAudioInput = getProperty("android.media.property.SUPPORT_AUDIO_SOURCE_UNPROCESSED") &#125;&#125; 嗯~what，我相信你也发现了，这个方法是 API 17 才出现的。目前公司项目的最低支持是16，所以得找一种方式在 API 16 上也能够获取到这个属性。结合之前的一些经验，我最初的想法是先看看API16的AudioManager的源码，希望这个方法是本身存在的，只是被隐藏了，这样我就可以直接通过反射的方式去调用，但是事实不是如此，在API16中，AudioManager确实是没有getProperty()方法 ；于是，本着学习的态度，我翻看了更高版本的AudioManager的源码，发现它的调用链是这个样子的。123if (PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED.equals(key)) &#123; return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportAudioSourceUnprocessed));&#125; 仿佛抓到一颗救命稻草，于是我想我直接在代码里面获取这个属性不就好了，这里给你萌看一张图吧，上面代码是这个样子的，找不到com.android.interal.R。 然后，我去google上搜索了关于如何引用这个资源文件，首先，通过反射是肯定可以获取到的，但是google会有一个警告告诉你 通过反射的方式访问内部APIs可能会在某些设备上不支持 ，所以还是用下面这个安全的方式吧。1resources.getBoolean(Resources.getSystem().getIdentifier("config_supportAudioSourceUnprocessed", "bool", "android")) 嗯哼，高兴的太早了，于是乎我就开启了API16的模拟器运行了起来，当走到这一行代码的时候，就出现了下面的结果，好吧，这个属性的判断似乎只能是API17才能用，所以还是用官方推荐的那种方式吧。 如果不支持的情况下，你可以尝试使用 MediaRecorder.AudioSource.VOICE_RECOGNITION 。它不使用AGC(Auto Gain Control，自动增益控制，当信号源较强的时候，使其增益自动降低；当信号源较弱的时候，使其增益自动增高)，并且不会做降噪处理。当然，即使设备不支持UNPROCESSED，你仍旧可以设置为这个，只是这样你就不知道音频信号有没有被处理了。 MediaRecorder的状态 这里直接使用官方的状态图了，如下 事件监听 MediaRecorder提供了两个监听事件的接口，一个是MediaRecorder.OnInfoListener，另一个是MediaRecorder.OnErrorListener。 OnInfoListener 可以用来监听MediaRecorder的一些状态，比如最大录制事件到了等等。12345678910111213141516mediaRecorder.setOnInfoListener&#123; _,what,_-&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED-&gt;&#123; //这个枚举值对应mediaRecorder.setMaxDuration()，当设置的最大录制时间到了后，会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING-&gt;&#123; //这个枚举值对应setMaxFileSize()，当录制文件大小快接近最大值的时候会回调这个，这个是API26新增 &#125; MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED-&gt;&#123; //当录制文件大小达到最大文件大小的时候会回调这个 &#125; MediaRecorder.MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED-&gt;&#123; //这个方法对应的是setNextOutputFile()，当录制视频超过指定大小后保存到next文件中的时候就会回调这个值，这个是API26新增 &#125; &#125;&#125; OnErrorListener 监听Error信息，12345678mediaRecorder.setOnErrorListener&#123;_, what, _ -&gt; when(what)&#123; MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN-&gt;&#123; &#125; MediaRecorder.MEDIA_ERROR_SERVER_DIED-&gt;&#123; &#125; &#125;&#125; 举个栗子 布局文件就不细说了，只有一个录制按钮和一个停止按钮。我们来看看Activity中核心的的代码。 请求权限123456789101112131415161718192021222324252627282930override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.startRecorderTv -&gt; checkRecordAudioPermission() R.id.stopRecorderTv -&gt; stopRecorder() &#125;&#125;private fun checkRecordAudioPermission() &#123; val hasRecordAudioPermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) when &#123; hasRecordAudioPermission == PackageManager.PERMISSION_GRANTED -&gt; startRecorder() ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.RECORD_AUDIO) -&gt; AlertDialog.Builder(this) .setCancelable(false) .setMessage("请求音频录制权限，否则无法录制音频") .setNegativeButton("取消") &#123; _, _ -&gt; &#125; .setPositiveButton("确定") &#123; _, _ -&gt; requestRecordAudioPermission() &#125; .show() else -&gt; requestRecordAudioPermission() &#125;&#125;private fun requestRecordAudioPermission() &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_RECORD_AUDIO_PERMISSION)&#125;override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; if (requestCode == REQUEST_RECORD_AUDIO_PERMISSION &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startRecorder() &#125;&#125; 开始录制123456789101112131415161718private fun startRecorder() &#123; if (!isRecording) &#123; mediaRecorder = MediaRecorder() mediaRecorder?.apply &#123; setAudioSource(MediaRecorder.AudioSource.MIC) setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) setAudioEncoder(MediaRecorder.AudioEncoder.AAC) val file = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), AUDIO_RECORDER_FILE_NAME) setOutputFile(file.absolutePath) try &#123; prepare() &#125; catch (e: Exception) &#123; &#125; start() isRecording = true &#125; &#125;&#125; 停止录制12345678910private fun stopRecorder() &#123; if (isRecording) &#123; mediaRecorder?.apply&#123; stop() release() &#125; isRecording = false mediaRecorder = null &#125;&#125; 项目地址github地址 官方文档 官网的Guide也是给出了MediaRecorder的详细使用，以及在 API 26 中新增的 MediaMuxer to record multiple channels 。 毒鸡汤 将来的你一定会感谢现在拼命的自己～]]></content>
  </entry>
  <entry>
    <title><![CDATA[选择列表请对CheckBox说No]]></title>
    <url>%2F2018%2F01%2F05%2F%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E8%AF%B7%E5%AF%B9CheckBox%E8%AF%B4No%2F</url>
    <content type="text"><![CDATA[由来 我记得刚学习Android的时候，有个需求是这个样子的，做一个单选或者多选的选择列表。然后那个时候懂得不是很多，就用CheckBox去做。做来做去，发现很多的坑，比如控件会被重用，导致选中的状态也被重用了。后来随着自己接触的东西变多，想到用另外一种方式来实现选择列表，但是这并不是我写这篇文章的原因。主要原因是最近在看同事写的代码(我们是两个人在开发)的时候，发现选择列表还是用的CheckBox，我觉得有必要分享下自己的实现方式，当然如果你们有什么好的建议记得及时告诉我。 实现方式 接下来我就说一下我是如何实现选择列表的(欢迎大家来吐槽)。先来一张效果图，比较简单。github项目地址 level-list 官方文档的介绍请戳这里。它可以通过一些值来管理一系列的图片，然后通过level属性修改这些值后就会显示对应的图片。 举个栗子 因为是选择列表，那必然会有两张图片，一张是未选中的，我们记为ic_select_off，一张是选中的，我们记为ic_select_on。然后我们可以在drawable文件夹下新建一个level_list_common_select.xml的资源文件。具体代码如下123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_select_off" android:maxLevel="0"/&gt; &lt;item android:drawable="@mipmap/ic_select_on" android:maxLevel="1"/&gt;&lt;/level-list&gt; 布局文件 接下来，我们说说布局文件，我们不会用到CheckBox，这里我们用ImageView来顶替CheckBox，大致如下所示。123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff" android:orientation="horizontal" android:paddingLeft="12dp" android:paddingRight="12dp"&gt; &lt;ImageView android:id="@+id/selectStatusIv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:src="@drawable/level_list_common_select"/&gt; &lt;TextView android:id="@+id/selectTitleTv" android:layout_width="match_parent" android:layout_height="match_parent" android:ellipsize="end" android:gravity="center_vertical" android:lines="1" android:paddingLeft="12dp" android:singleLine="true" android:textColor="#333333" android:textSize="16sp"/&gt;&lt;/LinearLayout&gt; 这里并没有太多花里胡哨的东西，只是用一个ImageView替换掉了CheckBox。 核心逻辑 你需要找一个能够唯一标记这个选项的字段，比如id，这个字段一般都会有。然后我们的适配器里面会存放一个selectId，在渲染View的方法中校验当前项的id是否和选中的id是一致的，如果一致，则将level设置为1，否则设置为0就可以了。12345678910111213141516171819202122232425262728package com.yanfangxiong.levellistimplementselectlistimport android.content.Contextimport android.view.Viewimport com.guoshujinfu.mobile.gscloud.migration.adapter.CommonListAdapterimport kotlinx.android.synthetic.main.listitem_select.view.*/** * @author fxYan */class SelectListAdapter( context: Context, resId: Int, data: List&lt;SelectBean&gt;) : CommonListAdapter&lt;SelectBean&gt;(context, resId, data) &#123; private var selectId: Long? = null fun setSelected(selectId: Long) &#123; this.selectId = selectId &#125; override fun bindData(view: View, position: Int, data: SelectBean) &#123; view.selectStatusIv.drawable.level = if (data.id == selectId) 1 else 0 view.selectTitleTv.text = data.title &#125;&#125; 这里用的kotlin编写的，CommonListAdapter可以去看之前写的用kotlin封装的适配器。这样这个单选的逻辑就写完了。嗯，就是这么简单，不用关心CheckBox重用导致的状态复用问题。 总结 如果我不去思考该如何简化，那我永远都只是死板的用CheckBox来完成选择列表。所以，要学会思考，只根据产品给的需求完成相应的任务那是一个初级程序猿做的事情。日子还长，别太失望~]]></content>
  </entry>
  <entry>
    <title><![CDATA[kotlin之集合的惰性操作]]></title>
    <url>%2F2017%2F12%2F16%2Fkotlin%E4%B9%8B%E9%9B%86%E5%90%88%E7%9A%84%E6%83%B0%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 最近在学习kotlin的时候，发现了一个 骚操作 ，它叫集合的惰性操作。什么，你问我为什么称它 骚 ？我也不知道，反正脑海中就浮现了这么个词语！可能是贫穷限制了我的想象力！ 举个栗子 比如有这么一个场景，你是一家猎头公司的人员(别问我为什么是猎头，因为我看完猎场了)。然后你需要从一批人员中筛选符合条件的人选。123456data class Person(var name: String, var age: Int = 0, var workYear: Int = 0, var mail: String?)val persons = listOf(Person("Tom", 20, 2, "Tom@mail.com"), Person("Mike", 22, 3, "Mike@mail.com"), Person("Jerry", 21, 3, "Jerry@mail.com"), Person("Atom", 22, 2, "Atom@mail.com")) 你需要筛选出工作年限不小于３年的人的联系方式，然后联系他们准备进行面试。1234567println(persons.filter &#123; println("filter operate!") it.workYear &gt;= 3&#125;.map &#123; println("map operate!") it.mail&#125;) 上面的代码会输出如下的结果，这样你就成功的筛选出了Mike和Jerry。 如果你不了解 filter 和 map 两个扩展函数，可以查看源码中的这两个扩展函数是怎么写的 _Collections.kt。从输出结果上我们也可以看出它的流程是这样的，先对persons集合的每一个元素调用filter，然后会产生一个新的集合，然后对新的集合调用map，这样就得到了所有符合条件人员的联系方式。 Sequence序列 上面已经说明了这段代码的执行流程，倘若你要从你们成百上千万的人才库中筛选这些人员，执行效率是不是就非常低下了，而且如果变换操作过多的时候，你会创建很多个临时的集合。这时候，惰性操作就出来的，解释排后，代码先行！12345678910println("result is:" + persons.asSequence() .filter &#123; println("filter operate!") it.workYear &gt;= 3 &#125; .map &#123; println("map operate!") it.mail &#125; .toList()) 上面这段代码输出结果是这样的。 我们很容易就能够看出，它会对persons中的每一个元素先调用filter，如果满足条件再调用map；它是一个元素操作完之后再对另外一个元素做操作。我们再来看看一个神奇的现象，先把toList()删除掉，它会输出这个结果。 很神奇吧，它没有对persons中的元素做任何操作，只是单纯的返回了一个TransformingSequence的对象。 序列的操作 我们可以将序列的操作分为两类，intermediate operation 和 terminal operation 。看下面这张图你就明白了。 intermediate operation是惰性的。从上面的代码我们可以看出，只有当terminal operation执行的时候，intermediate operation才会执行。 总结 序列是对集合的每一个元素做所有的操作，而没有使用序列的时候是对一个集合做完某个操作后再对新的集合做后续操作； 序列只有在terminal operation调用的时候才会执行所有的操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限的处理]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 Android运行时权限机制 是在 API 23(Android M) 中提出来的，今年已经发布了API 26、27(Android O)，已经过去几个版本了，但是为什么我要写这个东西。首先，以前在开发的过程中，为了图方便，只是 简单的将build.gradle 中的 targetSdkVersion 设置为 22，所以基本上没有太多的和运行时权限打交道，但是随着这个人啊越来越老( 帅 )，觉得不应该躲避新的东西，而应该正视它，不然自己的技术永远都不会得到提高。所以最近打算将targetSdkVersion逐渐升上去，玩点新东西。 这是什么 在 API 23 以前，如果用户在安装应用后，默认是同意了应用所需要的权限(但是Android厂商众多，也有很多手机会弹窗提示用户是否授予权限)。而运行时权限的加入，简化了应用的安装过程，因为用户在安装的过程中不需要授予权限，而在应用的运行过程中，可以选择是否授予应用相关的权限。举个简单的例子，用户可以为相机提供相机访问权限，但是不提供位置的访问权限。 权限分类 系统权限分为两类：Normal Permission 和 Dangerous Permission” ，前者 不会直接给用户的隐私带来风险 ，所以如果你的app在Manifest文件中列出了应用需要这些权限，系统会自动赋予该权限。后者 会赋予app访问用户隐私数据的权限，是有可能对用户隐私造成风险的 。所以如果你的app在Manifest文件中列出了这些权限，则这些 权限的授予是由用户决定的 。 如何使用 接下来，我们就要开始来玩运行时权限了。 检测权限 如果你的app需要 Dangerous Permission ，则每次执行需要这一权限操作的时候都应该检测自己是否具有该权限，因为用户始终可以自由的调用此权限。检测的方法有两种，但是源码是一样的，只是穿了个不同的外套而已。12345678int cameraPermissionState = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);cameraPermissionState = ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA);//判断权限是否授予if (cameraPermissionState == PermissionChecker.PERMISSION_GRANTED) &#123; //...已经具有该权限，你可以做一些羞羞的事情了&#125; else &#123; //...没有权限，这个时候你需要获取该权限了&#125; 请求权限 Android提供了多种权限请求方式，调用这些方法将会显示一个无法自定义的Android对话框。你可以调用 requestPermission() 方法来请求你所需要的权限。1ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 处理权限请求响应 当用户响应权限弹窗的时候，系统将回调 onRequestPermissionsResult() 方法，告知用户的响应情况。所以我们必须重写这个方法，如下。1234567if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...用户允许相机访问权限，你可以做一些羞羞的事情了 &#125; else &#123; //...用户拒绝了相机访问权限 &#125;&#125; 注意，系统显示的权限弹窗是对于 权限组 而言的，它不会列出app需要的具体权限。比如，app想要READ_CONTACTS权限，系统会告诉用户app想要访问设备的联系人。同时，用户只需要为每个权限组授予一次权限，如果应用请求该权限组中的任何其他权限，系统将自动授予应用这些权限 。具体过程是你在 requestPermissions() 方法之后，系统会自动回调 onRequestPermissionsResult() 方法，并传入 PERMISSION_GRANTED 。 权限组 你可能会询问权限组又是什么东西，是的，我也问过自己。所有的Dangerous Permission都属于权限组。 如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。您可以查看官方文档 。 我就知道你懒，给你截图了。如果你想看官方文档，就看看下面的图。 告诉用户你为什么需要这个权限 当用户选择单次拒绝权限的时候，你再次请求该权限，可以告知用户为什么你的app需要这些权限，以便让用户理解这些权限的作用。系统也提供了对应的方法 ActivityCompat.shouldShowRequestPermissionRationale() 。如果app之前请求过此权限，并且用户拒绝了请求这个方法就会返回true。如果app之前请求过此权限，并且用户勾选了”禁止后不再询问”，这个方法将返回false。 一次完整的权限请求 动态权限的相关其实并没有多少，来看看一段完整的请求CAMERA权限的示例。123456789101112131415161718192021222324252627282930313233343536private void checkPermission()&#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PermissionChecker.PERMISSION_GRANTED) &#123; //...开始做羞羞的事情 &#125; else &#123; requestCameraPermission(); &#125;&#125;private void requestCameraPermission() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; new AlertDialog.Builder(this) .setMessage("需要请求相机访问权限以便进行预览，拍摄") .setPositiveButton("好的", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125; &#125;) .create() .show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, PERMISSION_REQUEST_CAMERA); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CAMERA) &#123; if (grantResults.length == 1 &amp;&amp; grantResults[0] == PermissionChecker.PERMISSION_GRANTED) &#123; //...又可以做羞羞的事情了 &#125; &#125;&#125; 你该知道的 1. 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限 。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统 会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED ，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。 2. 要活用 shouldShowRequestPermissionRationale() 方法。这个方法是在用户拒绝过某个权限的请求(但不是禁止后不再询问)后会返回true，然后你可以在这个方法中做一些对该权限的解释，以便用户更了解为什么需要授予该权限。]]></content>
  </entry>
  <entry>
    <title><![CDATA[致敬2017，关于以后]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%87%B4%E6%95%AC2017%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[由来 今天从人事那里要到了年会拍摄的全部照片，看到自己的照片已经可以弄成一个表情包还是挺意外的。不过更让我意外的是，有些照片我竟然一点记忆片段都没有，为什么，因为喝醉了，喝醉了，喝醉了！！！是的，你没有猜错，写这篇文章只是想告诉自己以后不能胡来，有些事情该做，但是也要有底线。 关于2017 自2016年6月大学毕业以来，这是我工作的第一个完整年头，从16年8月23号从1号店辞职，9月8号来到杭州，到10月17日入职果树以来，已经过去1个多年头，在此经历了很多有意思的事情，遇到了很多有意思的人，也做了人生第一次表白！嗯，是的，第一次，你没听错。虽然讲给朋友听的时候，他们说我很蠢，表白这种事情应该当面说，怎么能够在手机上说呢，哈哈，但是对于我来说，至少是跨出过第一步！嗯，这是一个值得回忆的事情(虽然有时候我确实不太会表达自己内心的想法)。这一个年头，自己的技术虽然没有得到突飞猛进的增长，但是多多少少还是有一定的提高的。 反思 1. 喝酒误事，这句话你已经体验过两次了；一次是在16年的一次公司聚会上，红酒掺杂着啤酒和白酒，导致再次醒来的时候躺在医院的病床上挂着葡萄糖；一次是刚刚过去的的年会，但是这次却没有上次那样的安静，做了很多 不可描述 的事情。虽然在同事看来可能并没有什么，但是我觉得，有些事情能避免发生就应该把它扼杀在萌芽处。俗话说 “事不过三” ，时刻告诫自己，喝酒既伤身，又误事！！！ 2. 熬夜，2017年马上就要过去了，但是这个坏习惯还是一直伴随着自己，每次并不是不想睡觉，而是强行找点事情来做，我也不知道为什么，就是不想那么早的睡着，可能我有点“黑暗恐惧症”(可能吧，哈哈)。在今后的日子里，尽量早点休息，不要熬夜； 3. 充实自己，是的，每次空闲的时间不是拿来玩游戏，就是拿来玩游戏！导致自己不太善于与人交谈；其次导致自己很宅，这也是自己一直是单身的原因之一吧！哈哈哈。所以，2018，努力改变自己，充实自己，多多接触外面的世界，外面的人，找点摆脱单身的生活。 关于博客 时刻记住自己创建这个博客的初衷！生活，不管有意思没意思，只要是值得回味的事情，都可以记录下来；技术，不管简单或是困难，只要是有自己的感悟，就值得分享出来，因为它是你成长的路程。 关于自己 我竟然对自己无话可说，哈哈哈！！！但记住，时刻做好自己，做好自己经手的每一件事情！相信你会成长为一位优秀的人员！]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo d引发的思考]]></title>
    <url>%2F2017%2F12%2F07%2Fhexo-d%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[引发思考的导火索 最近用github pages和hexo搭建了自己的博客，每次本地写好后，需要同步到github上，这需要执行下面一系列的命令123$ hexo clean$ hexo g &amp;&amp; gulp$ hexo d 为了图个方便，于是我写了一个blog.sh的脚本文件，将上面的命令添加在脚本中，每次想要更新博客的时候直接执行脚本文件就可以了。但是令我很烦恼的是每次执行到hexo d的时候就需要输入密码，对于我这个懒癌深入骨髓的人来说是无法容忍的。 问题出在哪里 我也这么问过自己。但是对于被git工具惯坏的我来说，对于git的一些命令行着实不太会玩。我在google上搜索了相关的问题，得到的答案都是不要使用https的方式，使用ssh的方式，然后再将生成的ssh公钥配置在github上就不用每次输入密码了，但实际上我就是这么做的。于是我去询问了八哥，他说你是不是给ssh设置了密码，仔细一想，好像还真是，生成ssh的时候，我还确实设置过密码。于是我重新生成了ssh，然后将公钥更新到github上，再次执行blog.sh脚本文件的时候就没有出现过需要输入密码的情况了。 好奇心驱使 这个简单的问题确实是很快得到了解决，但是好奇心驱使的我还有几个问题需要弄明白。 ssh的密码是否是必要的？ https方式和ssh方式的区别？ ssh的密码是否是有必要的 当我们通过ssh的方式试图建立连接的时候，如果客户端的私钥和服务端的公钥能够匹配上，那么这个客户端才会被授予访问权限。ssh公钥可以确保在没有密码的情况下安全的使用，但是如果你的电脑被黑了，别人就可以不受限制的通过你的电脑和服务端进行通信，所以如果你不觉得麻烦的话，最好还是给ssh设置一个密码吧。 如何生成ssh 在此记录下如何生成ssh密钥，免得每次都得google。1$ ssh-keygen -t rsa -C "你的邮箱" 执行上面的脚本，如果你嫌麻烦就一路回车就好，生成的ssh密钥是没有密码的。这样就保证每次提交git的时候不用输入密码。1$ pbcopy &lt; ~/.ssh/id_rsa.pub 然后通过上面的命令，将ssh的公钥copy出来，最后将其粘贴到github上就可以了。 https方式和ssh方式的区别 这个问题产生是我发现github上clone代码的地方有两种方式，一种是https，一种是ssh。于是我尝试用https的方式clone了代码，然后修改了代码再push到github上，但是发现每次提交代码的时候我都需要输入用户名和密码，而通过ssh的方式我什么都不用管了。 因为使用https的时候，服务器是不知道这个请求由谁发起的，所以得每次输入用户名和密码进行验证，这样服务器才能知道执行push操作的是谁，有没有权限进行push。 而使用ssh方式服务器可以根据私钥和公钥是否匹配来知道你是谁，是否有权限进行push操作。 打破砂锅问到底 那我有没有一种方式是在使用https的时候也不用输入账户名和密码呢？其实也是有方式的，将用户名和密码保存在本地。1$ git config credential.helper store 当我们再提交代码的时候，会将repo的url和用户名密码以 明文 的方式保存在根目录下面的 .git-credentials 文件中，你可以通过下面这种方式打开这个文件。1$ open ~/.git-credentials 那么问题又来了，有没有加密方式去保存这个东西，嗯，于是我又去google了下，找到如下的命令1$ git config --global credential.helper osxkeychain 这会告诉git用 osxkeychain 这种方式进行保存。可以参考这个链接 总结 这确实是一个简单的问题，但是让我明白了很多新东西。怀揣着疑问的态度去看待事情，你会发现很多有趣的东西。同时告诫自己以后要多用命令行，不能被工具惯坏了！！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[留下成长的足迹]]></title>
    <url>%2F2017%2F12%2F06%2F%E7%95%99%E4%B8%8B%E6%88%90%E9%95%BF%E7%9A%84%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[来杭州不知不觉已经过去一年之久，发现自己变得越来越阳(臭)光(不)帅(要)气(脸)了。 一年来，绝大部分的时候都是在撸代码，但是却没有静下心来认真的思考和总结过，以至于有些技术一段时间后就遗忘掉了。很早以前，就想着搭一个属于自己的博客，但是由于各种原因一直没有实际行动过。刚好前段时间，看到挚友自己搭的博客，于是又燃起了这份冲动。 感谢HeZhou的帮助，我不是一个前端开发人员，很多东西都是在这位挚友不辞辛劳的指导下弄好的。 其实搭建这个博客不单单只是想做技(吹)术(牛)上的总结，同时还想着有意思的事情记录下来。若干年后回首，不悔当初的选择。 如果您在阅读文章的过程中觉得有些地方写的不对，或者没有写清楚的，欢迎留下您宝贵的意见，我会认真分析并改正，谢谢！]]></content>
  </entry>
</search>
